{"ast":null,"code":"var _jsxFileName = \"/Users/radhika.bajaj/Documents/GitHub/Knowledge-Graph-Frontend/src/components/NetworkDiagram.js\",\n  _s = $RefreshSig$();\nimport * as d3 from 'd3';\nimport { useEffect, useRef } from 'react';\nimport DrawNetwork from './DrawNetwork';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const NetworkDiagram = ({\n  graph,\n  width,\n  height\n}) => {\n  _s();\n  // The force simulation mutates links and nodes, so create a copy first\n  // Node positions are initialized by d3\n  const RADIUS = 40;\n  const links = graph.links.map(d => ({\n    ...d\n  }));\n  const nodes = graph.nodes.map(d => ({\n    ...d\n  }));\n  let cameraOffset = {\n    x: window.innerWidth / 2,\n    y: window.innerHeight / 2\n  };\n  let cameraZoom = 1;\n  let MAX_ZOOM = 5;\n  let MIN_ZOOM = 0.1;\n  let SCROLL_SENSITIVITY = 0.0005;\n  const canvasRef = useRef(null);\n  useEffect(() => {\n    // set dimension of the canvas element\n    const canvas = canvasRef.current;\n    const context = canvas === null || canvas === void 0 ? void 0 : canvas.getContext('2d');\n    if (!context) {\n      return;\n    }\n    context.translate(window.innerWidth / 2, window.innerHeight / 2);\n    context.scale(cameraZoom, cameraZoom);\n    context.translate(-window.innerWidth / 2 + cameraOffset.x, -window.innerHeight / 2 + cameraOffset.y);\n\n    // Gets the relevant location from a mouse or single touch event\n    function getEventLocation(e) {\n      if (e.touches && e.touches.length == 1) {\n        return {\n          x: e.touches[0].clientX,\n          y: e.touches[0].clientY\n        };\n      } else if (e.clientX && e.clientY) {\n        return {\n          x: e.clientX,\n          y: e.clientY\n        };\n      }\n    }\n    let isDragging = false;\n    let dragStart = {\n      x: 0,\n      y: 0\n    };\n    function onPointerDown(e) {\n      isDragging = true;\n      dragStart.x = getEventLocation(e).x / cameraZoom - cameraOffset.x;\n      dragStart.y = getEventLocation(e).y / cameraZoom - cameraOffset.y;\n    }\n    function onPointerUp(e) {\n      isDragging = false;\n      initialPinchDistance = null;\n      lastZoom = cameraZoom;\n    }\n    function onPointerMove(e) {\n      if (isDragging) {\n        cameraOffset.x = getEventLocation(e).x / cameraZoom - dragStart.x;\n        cameraOffset.y = getEventLocation(e).y / cameraZoom - dragStart.y;\n      }\n    }\n    function handleTouch(e, singleTouchHandler) {\n      if (e.touches.length == 1) {\n        singleTouchHandler(e);\n      } else if (e.type == \"touchmove\" && e.touches.length == 2) {\n        isDragging = false;\n        handlePinch(e);\n      }\n    }\n    let initialPinchDistance = null;\n    let lastZoom = cameraZoom;\n    function handlePinch(e) {\n      e.preventDefault();\n      let touch1 = {\n        x: e.touches[0].clientX,\n        y: e.touches[0].clientY\n      };\n      let touch2 = {\n        x: e.touches[1].clientX,\n        y: e.touches[1].clientY\n      };\n\n      // This is distance squared, but no need for an expensive sqrt as it's only used in ratio\n      let currentDistance = (touch1.x - touch2.x) ** 2 + (touch1.y - touch2.y) ** 2;\n      if (initialPinchDistance == null) {\n        initialPinchDistance = currentDistance;\n      } else {\n        adjustZoom(null, currentDistance / initialPinchDistance);\n      }\n    }\n    function adjustZoom(zoomAmount, zoomFactor) {\n      if (!isDragging) {\n        if (zoomAmount) {\n          cameraZoom += zoomAmount;\n        } else if (zoomFactor) {\n          console.log(zoomFactor);\n          cameraZoom = zoomFactor * lastZoom;\n        }\n        cameraZoom = Math.min(cameraZoom, MAX_ZOOM);\n        cameraZoom = Math.max(cameraZoom, MIN_ZOOM);\n        console.log(zoomAmount);\n      }\n    }\n    canvas.addEventListener('mousedown', onPointerDown);\n    canvas.addEventListener('touchstart', e => handleTouch(e, onPointerDown));\n    canvas.addEventListener('mouseup', onPointerUp);\n    canvas.addEventListener('touchend', e => handleTouch(e, onPointerUp));\n    canvas.addEventListener('mousemove', onPointerMove);\n    canvas.addEventListener('touchmove', e => handleTouch(e, onPointerMove));\n    canvas.addEventListener('wheel', e => adjustZoom(e.deltaY * SCROLL_SENSITIVITY));\n\n    // run d3-force to find the position of nodes on the canvas\n    d3.forceSimulation(nodes)\n\n    // list of forces we apply to get node positions\n    .force('link', d3.forceLink(links).id(d => d.id)).force('collide', d3.forceCollide().radius(RADIUS)).force('charge', d3.forceManyBody()).force('center', d3.forceCenter(width / 2, height / 2))\n\n    // at each iteration of the simulation, draw the network diagram with the new node positions\n    .on('tick', () => {\n      DrawNetwork(context, canvas.width, canvas.height, nodes, links, RADIUS);\n    });\n  }, [nodes, links]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      style: {\n        width: width,\n        height: height,\n        backgroundColor: \"#F2F1F1\"\n      },\n      width: window.innerWidth,\n      height: window.innerHeight\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 152,\n      columnNumber: 17\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 151,\n    columnNumber: 17\n  }, this);\n};\n_s(NetworkDiagram, \"UJgi7ynoup7eqypjnwyX/s32POg=\");\n_c = NetworkDiagram;\nvar _c;\n$RefreshReg$(_c, \"NetworkDiagram\");","map":{"version":3,"names":["d3","useEffect","useRef","DrawNetwork","jsxDEV","_jsxDEV","NetworkDiagram","graph","width","height","_s","RADIUS","links","map","d","nodes","cameraOffset","x","window","innerWidth","y","innerHeight","cameraZoom","MAX_ZOOM","MIN_ZOOM","SCROLL_SENSITIVITY","canvasRef","canvas","current","context","getContext","translate","scale","getEventLocation","e","touches","length","clientX","clientY","isDragging","dragStart","onPointerDown","onPointerUp","initialPinchDistance","lastZoom","onPointerMove","handleTouch","singleTouchHandler","type","handlePinch","preventDefault","touch1","touch2","currentDistance","adjustZoom","zoomAmount","zoomFactor","console","log","Math","min","max","addEventListener","deltaY","forceSimulation","force","forceLink","id","forceCollide","radius","forceManyBody","forceCenter","on","children","ref","style","backgroundColor","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/radhika.bajaj/Documents/GitHub/Knowledge-Graph-Frontend/src/components/NetworkDiagram.js"],"sourcesContent":["import * as d3 from 'd3';\nimport { useEffect, useRef } from 'react';\nimport DrawNetwork from './DrawNetwork';\n\nexport const NetworkDiagram = ({graph, width, height}) => {\n  // The force simulation mutates links and nodes, so create a copy first\n  // Node positions are initialized by d3\n  const RADIUS = 40;\n  const links = graph.links.map((d) => ({ ...d }));\n  const nodes = graph.nodes.map((d) => ({ ...d }));\n\n  let cameraOffset = { x: window.innerWidth/2, y: window.innerHeight/2 }\n  let cameraZoom = 1\n  let MAX_ZOOM = 5\n  let MIN_ZOOM = 0.1\n  let SCROLL_SENSITIVITY = 0.0005\n\n  const canvasRef = useRef(null);\n  \n\n  useEffect(() => {\n    // set dimension of the canvas element\n    const canvas = canvasRef.current;\n    const context = canvas?.getContext('2d');\n\n    if (!context) {\n      return;\n    }\n\n    context.translate( window.innerWidth / 2, window.innerHeight / 2 )\n    context.scale(cameraZoom, cameraZoom)\n    context.translate( -window.innerWidth / 2 + cameraOffset.x, -window.innerHeight / 2 + cameraOffset.y )\n\n    // Gets the relevant location from a mouse or single touch event\n    function getEventLocation(e) {\n        if (e.touches && e.touches.length == 1)\n        {\n            return { x:e.touches[0].clientX, y: e.touches[0].clientY }\n        }\n        else if (e.clientX && e.clientY)\n        {\n            return { x: e.clientX, y: e.clientY }        \n        }\n    }\n\n    let isDragging = false\n    let dragStart = { x: 0, y: 0 }\n\n    function onPointerDown(e) {\n        isDragging = true\n        dragStart.x = getEventLocation(e).x/cameraZoom - cameraOffset.x\n        dragStart.y = getEventLocation(e).y/cameraZoom - cameraOffset.y\n    }\n\n    function onPointerUp(e) {\n        isDragging = false\n        initialPinchDistance = null\n        lastZoom = cameraZoom\n    }\n\n    function onPointerMove(e) {\n        if (isDragging)\n        {\n            cameraOffset.x = getEventLocation(e).x/cameraZoom - dragStart.x\n            cameraOffset.y = getEventLocation(e).y/cameraZoom - dragStart.y\n        }\n    }\n\n    function handleTouch(e, singleTouchHandler) {\n        if ( e.touches.length == 1 )\n        {\n            singleTouchHandler(e)\n        }\n        else if (e.type == \"touchmove\" && e.touches.length == 2)\n        {\n            isDragging = false\n            handlePinch(e)\n        }\n    }\n\n    let initialPinchDistance = null\n    let lastZoom = cameraZoom\n\n    function handlePinch(e) {\n        e.preventDefault()\n        \n        let touch1 = { x: e.touches[0].clientX, y: e.touches[0].clientY }\n        let touch2 = { x: e.touches[1].clientX, y: e.touches[1].clientY }\n        \n        // This is distance squared, but no need for an expensive sqrt as it's only used in ratio\n        let currentDistance = (touch1.x - touch2.x)**2 + (touch1.y - touch2.y)**2\n        \n        if (initialPinchDistance == null)\n        {\n            initialPinchDistance = currentDistance\n        }\n        else\n        {\n            adjustZoom( null, currentDistance/initialPinchDistance )\n        }\n    }\n\n    function adjustZoom(zoomAmount, zoomFactor) {\n        if (!isDragging)\n        {\n            if (zoomAmount)\n            {\n                cameraZoom += zoomAmount\n            }\n            else if (zoomFactor)\n            {\n                console.log(zoomFactor)\n                cameraZoom = zoomFactor*lastZoom\n            }\n            \n            cameraZoom = Math.min( cameraZoom, MAX_ZOOM )\n            cameraZoom = Math.max( cameraZoom, MIN_ZOOM )\n            \n            console.log(zoomAmount)\n        }\n    }\n\n    canvas.addEventListener('mousedown', onPointerDown)\n    canvas.addEventListener('touchstart', (e) => handleTouch(e, onPointerDown))\n    canvas.addEventListener('mouseup', onPointerUp)\n    canvas.addEventListener('touchend',  (e) => handleTouch(e, onPointerUp))\n    canvas.addEventListener('mousemove', onPointerMove)\n    canvas.addEventListener('touchmove', (e) => handleTouch(e, onPointerMove))\n    canvas.addEventListener( 'wheel', (e) => adjustZoom(e.deltaY*SCROLL_SENSITIVITY))\n\n    // run d3-force to find the position of nodes on the canvas\n    d3.forceSimulation(nodes)\n\n      // list of forces we apply to get node positions\n      .force(\n        'link',\n        d3.forceLink(links).id((d) => d.id)\n      )\n      .force('collide', d3.forceCollide().radius(RADIUS))\n      .force('charge', d3.forceManyBody())\n      .force('center', d3.forceCenter(width / 2, height / 2))\n\n      // at each iteration of the simulation, draw the network diagram with the new node positions\n      .on('tick', () => {\n        DrawNetwork(context, canvas.width, canvas.height, nodes, links, RADIUS);\n      });\n  }, [nodes, links]);\n\n    \n    return (\n                <div>\n                <canvas\n                    ref={canvasRef}\n                    style={{\n                    width: width,\n                    height: height,\n                    backgroundColor: \"#F2F1F1\"\n                    }}\n                    width={window.innerWidth}\n                    height={window.innerHeight}\n                />\n                </div>\n        \n    );\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}