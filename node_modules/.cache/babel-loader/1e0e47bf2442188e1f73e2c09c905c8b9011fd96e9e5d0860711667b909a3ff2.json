{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.rectangleCollidesWithQuad = exports.squareCollidesWithQuad = exports.getCircumscribedAlignedRectangle = exports.isRectangleAligned = void 0;\n/**\n * Sigma.js Quad Tree Class\n * =========================\n *\n * Class implementing the quad tree data structure used to solve hovers and\n * determine which elements are currently in the scope of the camera so that\n * we don't waste time rendering things the user cannot see anyway.\n * @module\n */\n/* eslint no-nested-ternary: 0 */\n/* eslint no-constant-condition: 0 */\nvar extend_1 = __importDefault(require(\"@yomguithereal/helpers/extend\"));\n/**\n * Notes:\n *\n *   - a square can be represented as topleft + width, saying for the quad blocks,\n *     to reduce overall memory usage (which is already pretty low).\n *   - this implementation of a quadtree is often called a MX-CIF quadtree.\n *   - we could explore spatial hashing (hilbert quadtrees, notably).\n */\n/**\n * Constants.\n *\n * Note that since we are representing a static 4-ary tree, the indices of the\n * quadrants are the following:\n *   - TOP_LEFT:     4i + b\n *   - TOP_RIGHT:    4i + 2b\n *   - BOTTOM_LEFT:  4i + 3b\n *   - BOTTOM_RIGHT: 4i + 4b\n */\nvar BLOCKS = 4;\nvar MAX_LEVEL = 5;\n// Outside block is max block index + 1, i.e.:\n// BLOCKS * ((4 * (4 ** MAX_LEVEL) - 1) / 3)\nvar OUTSIDE_BLOCK = 5460;\nvar X_OFFSET = 0;\nvar Y_OFFSET = 1;\nvar WIDTH_OFFSET = 2;\nvar HEIGHT_OFFSET = 3;\nvar TOP_LEFT = 1;\nvar TOP_RIGHT = 2;\nvar BOTTOM_LEFT = 3;\nvar BOTTOM_RIGHT = 4;\nvar hasWarnedTooMuchOutside = false;\n/**\n * Geometry helpers.\n */\n/**\n * Function returning whether the given rectangle is axis-aligned.\n *\n * @param  {Rectangle} rect\n * @return {boolean}\n */\nfunction isRectangleAligned(rect) {\n  return rect.x1 === rect.x2 || rect.y1 === rect.y2;\n}\nexports.isRectangleAligned = isRectangleAligned;\n/**\n * Function returning the smallest rectangle that contains the given rectangle, and that is aligned with the axis.\n *\n * @param {Rectangle} rect\n * @return {Rectangle}\n */\nfunction getCircumscribedAlignedRectangle(rect) {\n  var width = Math.sqrt(Math.pow(rect.x2 - rect.x1, 2) + Math.pow(rect.y2 - rect.y1, 2));\n  var heightVector = {\n    x: (rect.y1 - rect.y2) * rect.height / width,\n    y: (rect.x2 - rect.x1) * rect.height / width\n  };\n  // Compute all corners:\n  var tl = {\n    x: rect.x1,\n    y: rect.y1\n  };\n  var tr = {\n    x: rect.x2,\n    y: rect.y2\n  };\n  var bl = {\n    x: rect.x1 + heightVector.x,\n    y: rect.y1 + heightVector.y\n  };\n  var br = {\n    x: rect.x2 + heightVector.x,\n    y: rect.y2 + heightVector.y\n  };\n  var xL = Math.min(tl.x, tr.x, bl.x, br.x);\n  var xR = Math.max(tl.x, tr.x, bl.x, br.x);\n  var yT = Math.min(tl.y, tr.y, bl.y, br.y);\n  var yB = Math.max(tl.y, tr.y, bl.y, br.y);\n  return {\n    x1: xL,\n    y1: yT,\n    x2: xR,\n    y2: yT,\n    height: yB - yT\n  };\n}\nexports.getCircumscribedAlignedRectangle = getCircumscribedAlignedRectangle;\n/**\n *\n * @param x1\n * @param y1\n * @param w\n * @param qx\n * @param qy\n * @param qw\n * @param qh\n */\nfunction squareCollidesWithQuad(x1, y1, w, qx, qy, qw, qh) {\n  return x1 < qx + qw && x1 + w > qx && y1 < qy + qh && y1 + w > qy;\n}\nexports.squareCollidesWithQuad = squareCollidesWithQuad;\nfunction rectangleCollidesWithQuad(x1, y1, w, h, qx, qy, qw, qh) {\n  return x1 < qx + qw && x1 + w > qx && y1 < qy + qh && y1 + h > qy;\n}\nexports.rectangleCollidesWithQuad = rectangleCollidesWithQuad;\nfunction pointIsInQuad(x, y, qx, qy, qw, qh) {\n  var xmp = qx + qw / 2,\n    ymp = qy + qh / 2,\n    top = y < ymp,\n    left = x < xmp;\n  return top ? left ? TOP_LEFT : TOP_RIGHT : left ? BOTTOM_LEFT : BOTTOM_RIGHT;\n}\n/**\n * Helper functions that are not bound to the class so an external user\n * cannot mess with them.\n */\nfunction buildQuadrants(maxLevel, data) {\n  // [block, level]\n  var stack = [0, 0];\n  while (stack.length) {\n    var level = stack.pop(),\n      block = stack.pop();\n    var topLeftBlock = 4 * block + BLOCKS,\n      topRightBlock = 4 * block + 2 * BLOCKS,\n      bottomLeftBlock = 4 * block + 3 * BLOCKS,\n      bottomRightBlock = 4 * block + 4 * BLOCKS;\n    var x = data[block + X_OFFSET],\n      y = data[block + Y_OFFSET],\n      width = data[block + WIDTH_OFFSET],\n      height = data[block + HEIGHT_OFFSET],\n      hw = width / 2,\n      hh = height / 2;\n    data[topLeftBlock + X_OFFSET] = x;\n    data[topLeftBlock + Y_OFFSET] = y;\n    data[topLeftBlock + WIDTH_OFFSET] = hw;\n    data[topLeftBlock + HEIGHT_OFFSET] = hh;\n    data[topRightBlock + X_OFFSET] = x + hw;\n    data[topRightBlock + Y_OFFSET] = y;\n    data[topRightBlock + WIDTH_OFFSET] = hw;\n    data[topRightBlock + HEIGHT_OFFSET] = hh;\n    data[bottomLeftBlock + X_OFFSET] = x;\n    data[bottomLeftBlock + Y_OFFSET] = y + hh;\n    data[bottomLeftBlock + WIDTH_OFFSET] = hw;\n    data[bottomLeftBlock + HEIGHT_OFFSET] = hh;\n    data[bottomRightBlock + X_OFFSET] = x + hw;\n    data[bottomRightBlock + Y_OFFSET] = y + hh;\n    data[bottomRightBlock + WIDTH_OFFSET] = hw;\n    data[bottomRightBlock + HEIGHT_OFFSET] = hh;\n    if (level < maxLevel - 1) {\n      stack.push(bottomRightBlock, level + 1);\n      stack.push(bottomLeftBlock, level + 1);\n      stack.push(topRightBlock, level + 1);\n      stack.push(topLeftBlock, level + 1);\n    }\n  }\n}\nfunction insertNode(maxLevel, data, containers, key, x, y, size) {\n  var x1 = x - size,\n    y1 = y - size,\n    w = size * 2;\n  var level = 0,\n    block = 0;\n  while (true) {\n    // If we reached max level\n    if (level >= maxLevel) {\n      containers[block] = containers[block] || [];\n      containers[block].push(key);\n      return;\n    }\n    var topLeftBlock = 4 * block + BLOCKS,\n      topRightBlock = 4 * block + 2 * BLOCKS,\n      bottomLeftBlock = 4 * block + 3 * BLOCKS,\n      bottomRightBlock = 4 * block + 4 * BLOCKS;\n    var collidingWithTopLeft = squareCollidesWithQuad(x1, y1, w, data[topLeftBlock + X_OFFSET], data[topLeftBlock + Y_OFFSET], data[topLeftBlock + WIDTH_OFFSET], data[topLeftBlock + HEIGHT_OFFSET]);\n    var collidingWithTopRight = squareCollidesWithQuad(x1, y1, w, data[topRightBlock + X_OFFSET], data[topRightBlock + Y_OFFSET], data[topRightBlock + WIDTH_OFFSET], data[topRightBlock + HEIGHT_OFFSET]);\n    var collidingWithBottomLeft = squareCollidesWithQuad(x1, y1, w, data[bottomLeftBlock + X_OFFSET], data[bottomLeftBlock + Y_OFFSET], data[bottomLeftBlock + WIDTH_OFFSET], data[bottomLeftBlock + HEIGHT_OFFSET]);\n    var collidingWithBottomRight = squareCollidesWithQuad(x1, y1, w, data[bottomRightBlock + X_OFFSET], data[bottomRightBlock + Y_OFFSET], data[bottomRightBlock + WIDTH_OFFSET], data[bottomRightBlock + HEIGHT_OFFSET]);\n    var collisions = [collidingWithTopLeft, collidingWithTopRight, collidingWithBottomLeft, collidingWithBottomRight].reduce(function (acc, current) {\n      if (current) return acc + 1;else return acc;\n    }, 0);\n    // If we have no collision at root level, inject node in the outside block\n    if (collisions === 0 && level === 0) {\n      containers[OUTSIDE_BLOCK].push(key);\n      if (!hasWarnedTooMuchOutside && containers[OUTSIDE_BLOCK].length >= 5) {\n        hasWarnedTooMuchOutside = true;\n        console.warn(\"sigma/quadtree.insertNode: At least 5 nodes are outside the global quadtree zone. \" + \"You might have a problem with the normalization function or the custom bounding box.\");\n      }\n      return;\n    }\n    // If we don't have at least a collision but deeper, there is an issue\n    if (collisions === 0) throw new Error(\"sigma/quadtree.insertNode: no collision (level: \".concat(level, \", key: \").concat(key, \", x: \").concat(x, \", y: \").concat(y, \", size: \").concat(size, \").\"));\n    // If we have 3 collisions, we have a geometry problem obviously\n    if (collisions === 3) throw new Error(\"sigma/quadtree.insertNode: 3 impossible collisions (level: \".concat(level, \", key: \").concat(key, \", x: \").concat(x, \", y: \").concat(y, \", size: \").concat(size, \").\"));\n    // If we have more that one collision, we stop here and store the node\n    // in the relevant containers\n    if (collisions > 1) {\n      containers[block] = containers[block] || [];\n      containers[block].push(key);\n      return;\n    } else {\n      level++;\n    }\n    // Else we recurse into the correct quads\n    if (collidingWithTopLeft) block = topLeftBlock;\n    if (collidingWithTopRight) block = topRightBlock;\n    if (collidingWithBottomLeft) block = bottomLeftBlock;\n    if (collidingWithBottomRight) block = bottomRightBlock;\n  }\n}\nfunction getNodesInAxisAlignedRectangleArea(maxLevel, data, containers, x1, y1, w, h) {\n  // [block, level]\n  var stack = [0, 0];\n  var collectedNodes = [];\n  var container;\n  while (stack.length) {\n    var level = stack.pop(),\n      block = stack.pop();\n    // Collecting nodes\n    container = containers[block];\n    if (container) (0, extend_1.default)(collectedNodes, container);\n    // If we reached max level\n    if (level >= maxLevel) continue;\n    var topLeftBlock = 4 * block + BLOCKS,\n      topRightBlock = 4 * block + 2 * BLOCKS,\n      bottomLeftBlock = 4 * block + 3 * BLOCKS,\n      bottomRightBlock = 4 * block + 4 * BLOCKS;\n    var collidingWithTopLeft = rectangleCollidesWithQuad(x1, y1, w, h, data[topLeftBlock + X_OFFSET], data[topLeftBlock + Y_OFFSET], data[topLeftBlock + WIDTH_OFFSET], data[topLeftBlock + HEIGHT_OFFSET]);\n    var collidingWithTopRight = rectangleCollidesWithQuad(x1, y1, w, h, data[topRightBlock + X_OFFSET], data[topRightBlock + Y_OFFSET], data[topRightBlock + WIDTH_OFFSET], data[topRightBlock + HEIGHT_OFFSET]);\n    var collidingWithBottomLeft = rectangleCollidesWithQuad(x1, y1, w, h, data[bottomLeftBlock + X_OFFSET], data[bottomLeftBlock + Y_OFFSET], data[bottomLeftBlock + WIDTH_OFFSET], data[bottomLeftBlock + HEIGHT_OFFSET]);\n    var collidingWithBottomRight = rectangleCollidesWithQuad(x1, y1, w, h, data[bottomRightBlock + X_OFFSET], data[bottomRightBlock + Y_OFFSET], data[bottomRightBlock + WIDTH_OFFSET], data[bottomRightBlock + HEIGHT_OFFSET]);\n    if (collidingWithTopLeft) stack.push(topLeftBlock, level + 1);\n    if (collidingWithTopRight) stack.push(topRightBlock, level + 1);\n    if (collidingWithBottomLeft) stack.push(bottomLeftBlock, level + 1);\n    if (collidingWithBottomRight) stack.push(bottomRightBlock, level + 1);\n  }\n  return collectedNodes;\n}\n/**\n * QuadTree class.\n *\n * @constructor\n * @param {object} boundaries - The graph boundaries.\n */\nvar QuadTree = /** @class */function () {\n  function QuadTree(params) {\n    var _a;\n    if (params === void 0) {\n      params = {};\n    }\n    this.containers = (_a = {}, _a[OUTSIDE_BLOCK] = [], _a);\n    this.cache = null;\n    this.lastRectangle = null;\n    // Allocating the underlying byte array\n    var L = Math.pow(4, MAX_LEVEL);\n    this.data = new Float32Array(BLOCKS * ((4 * L - 1) / 3));\n    if (params.boundaries) this.resize(params.boundaries);else this.resize({\n      x: 0,\n      y: 0,\n      width: 1,\n      height: 1\n    });\n  }\n  QuadTree.prototype.add = function (key, x, y, size) {\n    insertNode(MAX_LEVEL, this.data, this.containers, key, x, y, size);\n    return this;\n  };\n  QuadTree.prototype.resize = function (boundaries) {\n    this.clear();\n    // Building the quadrants\n    this.data[X_OFFSET] = boundaries.x;\n    this.data[Y_OFFSET] = boundaries.y;\n    this.data[WIDTH_OFFSET] = boundaries.width;\n    this.data[HEIGHT_OFFSET] = boundaries.height;\n    buildQuadrants(MAX_LEVEL, this.data);\n  };\n  QuadTree.prototype.clear = function () {\n    var _a;\n    this.containers = (_a = {}, _a[OUTSIDE_BLOCK] = [], _a);\n    return this;\n  };\n  QuadTree.prototype.point = function (x, y) {\n    var nodes = this.containers[OUTSIDE_BLOCK].slice();\n    var block = 0,\n      level = 0;\n    do {\n      if (this.containers[block]) (0, extend_1.default)(nodes, this.containers[block]);\n      var quad = pointIsInQuad(x, y, this.data[block + X_OFFSET], this.data[block + Y_OFFSET], this.data[block + WIDTH_OFFSET], this.data[block + HEIGHT_OFFSET]);\n      block = 4 * block + quad * BLOCKS;\n      level++;\n    } while (level <= MAX_LEVEL);\n    return nodes;\n  };\n  QuadTree.prototype.rectangle = function (x1, y1, x2, y2, height) {\n    var lr = this.lastRectangle;\n    if (lr && x1 === lr.x1 && x2 === lr.x2 && y1 === lr.y1 && y2 === lr.y2 && height === lr.height) {\n      return this.cache;\n    }\n    this.lastRectangle = {\n      x1: x1,\n      y1: y1,\n      x2: x2,\n      y2: y2,\n      height: height\n    };\n    // If the rectangle is shifted, we use the smallest aligned rectangle that contains the shifted one:\n    if (!isRectangleAligned(this.lastRectangle)) this.lastRectangle = getCircumscribedAlignedRectangle(this.lastRectangle);\n    this.cache = getNodesInAxisAlignedRectangleArea(MAX_LEVEL, this.data, this.containers, x1, y1, Math.abs(x1 - x2) || Math.abs(y1 - y2), height);\n    // Add all the nodes in the outside block, since they might be relevant, and since they should be very few:\n    (0, extend_1.default)(this.cache, this.containers[OUTSIDE_BLOCK]);\n    return this.cache;\n  };\n  return QuadTree;\n}();\nexports.default = QuadTree;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","rectangleCollidesWithQuad","squareCollidesWithQuad","getCircumscribedAlignedRectangle","isRectangleAligned","extend_1","require","BLOCKS","MAX_LEVEL","OUTSIDE_BLOCK","X_OFFSET","Y_OFFSET","WIDTH_OFFSET","HEIGHT_OFFSET","TOP_LEFT","TOP_RIGHT","BOTTOM_LEFT","BOTTOM_RIGHT","hasWarnedTooMuchOutside","rect","x1","x2","y1","y2","width","Math","sqrt","pow","heightVector","x","height","y","tl","tr","bl","br","xL","min","xR","max","yT","yB","w","qx","qy","qw","qh","h","pointIsInQuad","xmp","ymp","top","left","buildQuadrants","maxLevel","data","stack","length","level","pop","block","topLeftBlock","topRightBlock","bottomLeftBlock","bottomRightBlock","hw","hh","push","insertNode","containers","key","size","collidingWithTopLeft","collidingWithTopRight","collidingWithBottomLeft","collidingWithBottomRight","collisions","reduce","acc","current","console","warn","Error","concat","getNodesInAxisAlignedRectangleArea","collectedNodes","container","default","QuadTree","params","_a","cache","lastRectangle","L","Float32Array","boundaries","resize","prototype","add","clear","point","nodes","slice","quad","rectangle","lr","abs"],"sources":["/Users/radhika.bajaj/Documents/GitHub/Knowledge-Graph-Frontend/node_modules/sigma/core/quadtree.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.rectangleCollidesWithQuad = exports.squareCollidesWithQuad = exports.getCircumscribedAlignedRectangle = exports.isRectangleAligned = void 0;\n/**\n * Sigma.js Quad Tree Class\n * =========================\n *\n * Class implementing the quad tree data structure used to solve hovers and\n * determine which elements are currently in the scope of the camera so that\n * we don't waste time rendering things the user cannot see anyway.\n * @module\n */\n/* eslint no-nested-ternary: 0 */\n/* eslint no-constant-condition: 0 */\nvar extend_1 = __importDefault(require(\"@yomguithereal/helpers/extend\"));\n/**\n * Notes:\n *\n *   - a square can be represented as topleft + width, saying for the quad blocks,\n *     to reduce overall memory usage (which is already pretty low).\n *   - this implementation of a quadtree is often called a MX-CIF quadtree.\n *   - we could explore spatial hashing (hilbert quadtrees, notably).\n */\n/**\n * Constants.\n *\n * Note that since we are representing a static 4-ary tree, the indices of the\n * quadrants are the following:\n *   - TOP_LEFT:     4i + b\n *   - TOP_RIGHT:    4i + 2b\n *   - BOTTOM_LEFT:  4i + 3b\n *   - BOTTOM_RIGHT: 4i + 4b\n */\nvar BLOCKS = 4;\nvar MAX_LEVEL = 5;\n// Outside block is max block index + 1, i.e.:\n// BLOCKS * ((4 * (4 ** MAX_LEVEL) - 1) / 3)\nvar OUTSIDE_BLOCK = 5460;\nvar X_OFFSET = 0;\nvar Y_OFFSET = 1;\nvar WIDTH_OFFSET = 2;\nvar HEIGHT_OFFSET = 3;\nvar TOP_LEFT = 1;\nvar TOP_RIGHT = 2;\nvar BOTTOM_LEFT = 3;\nvar BOTTOM_RIGHT = 4;\nvar hasWarnedTooMuchOutside = false;\n/**\n * Geometry helpers.\n */\n/**\n * Function returning whether the given rectangle is axis-aligned.\n *\n * @param  {Rectangle} rect\n * @return {boolean}\n */\nfunction isRectangleAligned(rect) {\n    return rect.x1 === rect.x2 || rect.y1 === rect.y2;\n}\nexports.isRectangleAligned = isRectangleAligned;\n/**\n * Function returning the smallest rectangle that contains the given rectangle, and that is aligned with the axis.\n *\n * @param {Rectangle} rect\n * @return {Rectangle}\n */\nfunction getCircumscribedAlignedRectangle(rect) {\n    var width = Math.sqrt(Math.pow(rect.x2 - rect.x1, 2) + Math.pow(rect.y2 - rect.y1, 2));\n    var heightVector = {\n        x: ((rect.y1 - rect.y2) * rect.height) / width,\n        y: ((rect.x2 - rect.x1) * rect.height) / width,\n    };\n    // Compute all corners:\n    var tl = { x: rect.x1, y: rect.y1 };\n    var tr = { x: rect.x2, y: rect.y2 };\n    var bl = {\n        x: rect.x1 + heightVector.x,\n        y: rect.y1 + heightVector.y,\n    };\n    var br = {\n        x: rect.x2 + heightVector.x,\n        y: rect.y2 + heightVector.y,\n    };\n    var xL = Math.min(tl.x, tr.x, bl.x, br.x);\n    var xR = Math.max(tl.x, tr.x, bl.x, br.x);\n    var yT = Math.min(tl.y, tr.y, bl.y, br.y);\n    var yB = Math.max(tl.y, tr.y, bl.y, br.y);\n    return {\n        x1: xL,\n        y1: yT,\n        x2: xR,\n        y2: yT,\n        height: yB - yT,\n    };\n}\nexports.getCircumscribedAlignedRectangle = getCircumscribedAlignedRectangle;\n/**\n *\n * @param x1\n * @param y1\n * @param w\n * @param qx\n * @param qy\n * @param qw\n * @param qh\n */\nfunction squareCollidesWithQuad(x1, y1, w, qx, qy, qw, qh) {\n    return x1 < qx + qw && x1 + w > qx && y1 < qy + qh && y1 + w > qy;\n}\nexports.squareCollidesWithQuad = squareCollidesWithQuad;\nfunction rectangleCollidesWithQuad(x1, y1, w, h, qx, qy, qw, qh) {\n    return x1 < qx + qw && x1 + w > qx && y1 < qy + qh && y1 + h > qy;\n}\nexports.rectangleCollidesWithQuad = rectangleCollidesWithQuad;\nfunction pointIsInQuad(x, y, qx, qy, qw, qh) {\n    var xmp = qx + qw / 2, ymp = qy + qh / 2, top = y < ymp, left = x < xmp;\n    return top ? (left ? TOP_LEFT : TOP_RIGHT) : left ? BOTTOM_LEFT : BOTTOM_RIGHT;\n}\n/**\n * Helper functions that are not bound to the class so an external user\n * cannot mess with them.\n */\nfunction buildQuadrants(maxLevel, data) {\n    // [block, level]\n    var stack = [0, 0];\n    while (stack.length) {\n        var level = stack.pop(), block = stack.pop();\n        var topLeftBlock = 4 * block + BLOCKS, topRightBlock = 4 * block + 2 * BLOCKS, bottomLeftBlock = 4 * block + 3 * BLOCKS, bottomRightBlock = 4 * block + 4 * BLOCKS;\n        var x = data[block + X_OFFSET], y = data[block + Y_OFFSET], width = data[block + WIDTH_OFFSET], height = data[block + HEIGHT_OFFSET], hw = width / 2, hh = height / 2;\n        data[topLeftBlock + X_OFFSET] = x;\n        data[topLeftBlock + Y_OFFSET] = y;\n        data[topLeftBlock + WIDTH_OFFSET] = hw;\n        data[topLeftBlock + HEIGHT_OFFSET] = hh;\n        data[topRightBlock + X_OFFSET] = x + hw;\n        data[topRightBlock + Y_OFFSET] = y;\n        data[topRightBlock + WIDTH_OFFSET] = hw;\n        data[topRightBlock + HEIGHT_OFFSET] = hh;\n        data[bottomLeftBlock + X_OFFSET] = x;\n        data[bottomLeftBlock + Y_OFFSET] = y + hh;\n        data[bottomLeftBlock + WIDTH_OFFSET] = hw;\n        data[bottomLeftBlock + HEIGHT_OFFSET] = hh;\n        data[bottomRightBlock + X_OFFSET] = x + hw;\n        data[bottomRightBlock + Y_OFFSET] = y + hh;\n        data[bottomRightBlock + WIDTH_OFFSET] = hw;\n        data[bottomRightBlock + HEIGHT_OFFSET] = hh;\n        if (level < maxLevel - 1) {\n            stack.push(bottomRightBlock, level + 1);\n            stack.push(bottomLeftBlock, level + 1);\n            stack.push(topRightBlock, level + 1);\n            stack.push(topLeftBlock, level + 1);\n        }\n    }\n}\nfunction insertNode(maxLevel, data, containers, key, x, y, size) {\n    var x1 = x - size, y1 = y - size, w = size * 2;\n    var level = 0, block = 0;\n    while (true) {\n        // If we reached max level\n        if (level >= maxLevel) {\n            containers[block] = containers[block] || [];\n            containers[block].push(key);\n            return;\n        }\n        var topLeftBlock = 4 * block + BLOCKS, topRightBlock = 4 * block + 2 * BLOCKS, bottomLeftBlock = 4 * block + 3 * BLOCKS, bottomRightBlock = 4 * block + 4 * BLOCKS;\n        var collidingWithTopLeft = squareCollidesWithQuad(x1, y1, w, data[topLeftBlock + X_OFFSET], data[topLeftBlock + Y_OFFSET], data[topLeftBlock + WIDTH_OFFSET], data[topLeftBlock + HEIGHT_OFFSET]);\n        var collidingWithTopRight = squareCollidesWithQuad(x1, y1, w, data[topRightBlock + X_OFFSET], data[topRightBlock + Y_OFFSET], data[topRightBlock + WIDTH_OFFSET], data[topRightBlock + HEIGHT_OFFSET]);\n        var collidingWithBottomLeft = squareCollidesWithQuad(x1, y1, w, data[bottomLeftBlock + X_OFFSET], data[bottomLeftBlock + Y_OFFSET], data[bottomLeftBlock + WIDTH_OFFSET], data[bottomLeftBlock + HEIGHT_OFFSET]);\n        var collidingWithBottomRight = squareCollidesWithQuad(x1, y1, w, data[bottomRightBlock + X_OFFSET], data[bottomRightBlock + Y_OFFSET], data[bottomRightBlock + WIDTH_OFFSET], data[bottomRightBlock + HEIGHT_OFFSET]);\n        var collisions = [\n            collidingWithTopLeft,\n            collidingWithTopRight,\n            collidingWithBottomLeft,\n            collidingWithBottomRight,\n        ].reduce(function (acc, current) {\n            if (current)\n                return acc + 1;\n            else\n                return acc;\n        }, 0);\n        // If we have no collision at root level, inject node in the outside block\n        if (collisions === 0 && level === 0) {\n            containers[OUTSIDE_BLOCK].push(key);\n            if (!hasWarnedTooMuchOutside && containers[OUTSIDE_BLOCK].length >= 5) {\n                hasWarnedTooMuchOutside = true;\n                console.warn(\"sigma/quadtree.insertNode: At least 5 nodes are outside the global quadtree zone. \" +\n                    \"You might have a problem with the normalization function or the custom bounding box.\");\n            }\n            return;\n        }\n        // If we don't have at least a collision but deeper, there is an issue\n        if (collisions === 0)\n            throw new Error(\"sigma/quadtree.insertNode: no collision (level: \".concat(level, \", key: \").concat(key, \", x: \").concat(x, \", y: \").concat(y, \", size: \").concat(size, \").\"));\n        // If we have 3 collisions, we have a geometry problem obviously\n        if (collisions === 3)\n            throw new Error(\"sigma/quadtree.insertNode: 3 impossible collisions (level: \".concat(level, \", key: \").concat(key, \", x: \").concat(x, \", y: \").concat(y, \", size: \").concat(size, \").\"));\n        // If we have more that one collision, we stop here and store the node\n        // in the relevant containers\n        if (collisions > 1) {\n            containers[block] = containers[block] || [];\n            containers[block].push(key);\n            return;\n        }\n        else {\n            level++;\n        }\n        // Else we recurse into the correct quads\n        if (collidingWithTopLeft)\n            block = topLeftBlock;\n        if (collidingWithTopRight)\n            block = topRightBlock;\n        if (collidingWithBottomLeft)\n            block = bottomLeftBlock;\n        if (collidingWithBottomRight)\n            block = bottomRightBlock;\n    }\n}\nfunction getNodesInAxisAlignedRectangleArea(maxLevel, data, containers, x1, y1, w, h) {\n    // [block, level]\n    var stack = [0, 0];\n    var collectedNodes = [];\n    var container;\n    while (stack.length) {\n        var level = stack.pop(), block = stack.pop();\n        // Collecting nodes\n        container = containers[block];\n        if (container)\n            (0, extend_1.default)(collectedNodes, container);\n        // If we reached max level\n        if (level >= maxLevel)\n            continue;\n        var topLeftBlock = 4 * block + BLOCKS, topRightBlock = 4 * block + 2 * BLOCKS, bottomLeftBlock = 4 * block + 3 * BLOCKS, bottomRightBlock = 4 * block + 4 * BLOCKS;\n        var collidingWithTopLeft = rectangleCollidesWithQuad(x1, y1, w, h, data[topLeftBlock + X_OFFSET], data[topLeftBlock + Y_OFFSET], data[topLeftBlock + WIDTH_OFFSET], data[topLeftBlock + HEIGHT_OFFSET]);\n        var collidingWithTopRight = rectangleCollidesWithQuad(x1, y1, w, h, data[topRightBlock + X_OFFSET], data[topRightBlock + Y_OFFSET], data[topRightBlock + WIDTH_OFFSET], data[topRightBlock + HEIGHT_OFFSET]);\n        var collidingWithBottomLeft = rectangleCollidesWithQuad(x1, y1, w, h, data[bottomLeftBlock + X_OFFSET], data[bottomLeftBlock + Y_OFFSET], data[bottomLeftBlock + WIDTH_OFFSET], data[bottomLeftBlock + HEIGHT_OFFSET]);\n        var collidingWithBottomRight = rectangleCollidesWithQuad(x1, y1, w, h, data[bottomRightBlock + X_OFFSET], data[bottomRightBlock + Y_OFFSET], data[bottomRightBlock + WIDTH_OFFSET], data[bottomRightBlock + HEIGHT_OFFSET]);\n        if (collidingWithTopLeft)\n            stack.push(topLeftBlock, level + 1);\n        if (collidingWithTopRight)\n            stack.push(topRightBlock, level + 1);\n        if (collidingWithBottomLeft)\n            stack.push(bottomLeftBlock, level + 1);\n        if (collidingWithBottomRight)\n            stack.push(bottomRightBlock, level + 1);\n    }\n    return collectedNodes;\n}\n/**\n * QuadTree class.\n *\n * @constructor\n * @param {object} boundaries - The graph boundaries.\n */\nvar QuadTree = /** @class */ (function () {\n    function QuadTree(params) {\n        var _a;\n        if (params === void 0) { params = {}; }\n        this.containers = (_a = {}, _a[OUTSIDE_BLOCK] = [], _a);\n        this.cache = null;\n        this.lastRectangle = null;\n        // Allocating the underlying byte array\n        var L = Math.pow(4, MAX_LEVEL);\n        this.data = new Float32Array(BLOCKS * ((4 * L - 1) / 3));\n        if (params.boundaries)\n            this.resize(params.boundaries);\n        else\n            this.resize({\n                x: 0,\n                y: 0,\n                width: 1,\n                height: 1,\n            });\n    }\n    QuadTree.prototype.add = function (key, x, y, size) {\n        insertNode(MAX_LEVEL, this.data, this.containers, key, x, y, size);\n        return this;\n    };\n    QuadTree.prototype.resize = function (boundaries) {\n        this.clear();\n        // Building the quadrants\n        this.data[X_OFFSET] = boundaries.x;\n        this.data[Y_OFFSET] = boundaries.y;\n        this.data[WIDTH_OFFSET] = boundaries.width;\n        this.data[HEIGHT_OFFSET] = boundaries.height;\n        buildQuadrants(MAX_LEVEL, this.data);\n    };\n    QuadTree.prototype.clear = function () {\n        var _a;\n        this.containers = (_a = {}, _a[OUTSIDE_BLOCK] = [], _a);\n        return this;\n    };\n    QuadTree.prototype.point = function (x, y) {\n        var nodes = this.containers[OUTSIDE_BLOCK].slice();\n        var block = 0, level = 0;\n        do {\n            if (this.containers[block])\n                (0, extend_1.default)(nodes, this.containers[block]);\n            var quad = pointIsInQuad(x, y, this.data[block + X_OFFSET], this.data[block + Y_OFFSET], this.data[block + WIDTH_OFFSET], this.data[block + HEIGHT_OFFSET]);\n            block = 4 * block + quad * BLOCKS;\n            level++;\n        } while (level <= MAX_LEVEL);\n        return nodes;\n    };\n    QuadTree.prototype.rectangle = function (x1, y1, x2, y2, height) {\n        var lr = this.lastRectangle;\n        if (lr && x1 === lr.x1 && x2 === lr.x2 && y1 === lr.y1 && y2 === lr.y2 && height === lr.height) {\n            return this.cache;\n        }\n        this.lastRectangle = {\n            x1: x1,\n            y1: y1,\n            x2: x2,\n            y2: y2,\n            height: height,\n        };\n        // If the rectangle is shifted, we use the smallest aligned rectangle that contains the shifted one:\n        if (!isRectangleAligned(this.lastRectangle))\n            this.lastRectangle = getCircumscribedAlignedRectangle(this.lastRectangle);\n        this.cache = getNodesInAxisAlignedRectangleArea(MAX_LEVEL, this.data, this.containers, x1, y1, Math.abs(x1 - x2) || Math.abs(y1 - y2), height);\n        // Add all the nodes in the outside block, since they might be relevant, and since they should be very few:\n        (0, extend_1.default)(this.cache, this.containers[OUTSIDE_BLOCK]);\n        return this.cache;\n    };\n    return QuadTree;\n}());\nexports.default = QuadTree;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}