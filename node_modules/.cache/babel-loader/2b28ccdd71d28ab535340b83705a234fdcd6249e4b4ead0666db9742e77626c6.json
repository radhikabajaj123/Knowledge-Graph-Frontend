{"ast":null,"code":"(() => {\n  \"use strict\";\n\n  var o = {\n      d: (t, e) => {\n        for (var n in e) o.o(e, n) && !o.o(t, n) && Object.defineProperty(t, n, {\n          enumerable: !0,\n          get: e[n]\n        });\n      },\n      o: (o, t) => Object.prototype.hasOwnProperty.call(o, t),\n      r: o => {\n        \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(o, Symbol.toStringTag, {\n          value: \"Module\"\n        }), Object.defineProperty(o, \"__esModule\", {\n          value: !0\n        });\n      }\n    },\n    t = {};\n  o.r(t), o.d(t, {\n    default: () => e\n  });\n  const e = \"attribute vec2 a_position;\\nattribute float a_size;\\nattribute vec4 a_color;\\n\\nuniform float u_ratio;\\nuniform float u_scale;\\nuniform mat3 u_matrix;\\n\\nvarying vec4 v_color;\\nvarying float v_border;\\n\\nconst float bias = 255.0 / 254.0;\\n\\nvoid main() {\\n  gl_Position = vec4(\\n    (u_matrix * vec3(a_position, 1)).xy,\\n    0,\\n    1\\n  );\\n\\n  // Multiply the point size twice:\\n  //  - x SCALING_RATIO to correct the canvas scaling\\n  //  - x 2 to correct the formulae\\n  gl_PointSize = a_size * u_ratio * u_scale * 2.0;\\n\\n  v_border = (1.0 / u_ratio) * (0.5 / a_size);\\n\\n  // Extract the color:\\n  v_color = a_color;\\n  v_color.a *= bias;\\n}\\n\";\n  module.exports = t;\n})();","map":{"version":3,"names":["o","d","t","e","n","Object","defineProperty","enumerable","get","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","default","module","exports"],"sources":["/Users/radhika.bajaj/Documents/GitHub/Knowledge-Graph-Frontend/node_modules/sigma/rendering/webgl/shaders/node.fast.vert.glsl.js"],"sourcesContent":["(()=>{\"use strict\";var o={d:(t,e)=>{for(var n in e)o.o(e,n)&&!o.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:e[n]})},o:(o,t)=>Object.prototype.hasOwnProperty.call(o,t),r:o=>{\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(o,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(o,\"__esModule\",{value:!0})}},t={};o.r(t),o.d(t,{default:()=>e});const e=\"attribute vec2 a_position;\\nattribute float a_size;\\nattribute vec4 a_color;\\n\\nuniform float u_ratio;\\nuniform float u_scale;\\nuniform mat3 u_matrix;\\n\\nvarying vec4 v_color;\\nvarying float v_border;\\n\\nconst float bias = 255.0 / 254.0;\\n\\nvoid main() {\\n  gl_Position = vec4(\\n    (u_matrix * vec3(a_position, 1)).xy,\\n    0,\\n    1\\n  );\\n\\n  // Multiply the point size twice:\\n  //  - x SCALING_RATIO to correct the canvas scaling\\n  //  - x 2 to correct the formulae\\n  gl_PointSize = a_size * u_ratio * u_scale * 2.0;\\n\\n  v_border = (1.0 / u_ratio) * (0.5 / a_size);\\n\\n  // Extract the color:\\n  v_color = a_color;\\n  v_color.a *= bias;\\n}\\n\";module.exports=t})();"],"mappings":"AAAA,CAAC,MAAI;EAAC,YAAY;;EAAC,IAAIA,CAAC,GAAC;MAACC,CAAC,EAACA,CAACC,CAAC,EAACC,CAAC,KAAG;QAAC,KAAI,IAAIC,CAAC,IAAID,CAAC,EAACH,CAAC,CAACA,CAAC,CAACG,CAAC,EAACC,CAAC,CAAC,IAAE,CAACJ,CAAC,CAACA,CAAC,CAACE,CAAC,EAACE,CAAC,CAAC,IAAEC,MAAM,CAACC,cAAc,CAACJ,CAAC,EAACE,CAAC,EAAC;UAACG,UAAU,EAAC,CAAC,CAAC;UAACC,GAAG,EAACL,CAAC,CAACC,CAAC;QAAC,CAAC,CAAC;MAAA,CAAC;MAACJ,CAAC,EAACA,CAACA,CAAC,EAACE,CAAC,KAAGG,MAAM,CAACI,SAAS,CAACC,cAAc,CAACC,IAAI,CAACX,CAAC,EAACE,CAAC,CAAC;MAACU,CAAC,EAACZ,CAAC,IAAE;QAAC,WAAW,IAAE,OAAOa,MAAM,IAAEA,MAAM,CAACC,WAAW,IAAET,MAAM,CAACC,cAAc,CAACN,CAAC,EAACa,MAAM,CAACC,WAAW,EAAC;UAACC,KAAK,EAAC;QAAQ,CAAC,CAAC,EAACV,MAAM,CAACC,cAAc,CAACN,CAAC,EAAC,YAAY,EAAC;UAACe,KAAK,EAAC,CAAC;QAAC,CAAC,CAAC;MAAA;IAAC,CAAC;IAACb,CAAC,GAAC,CAAC,CAAC;EAACF,CAAC,CAACY,CAAC,CAACV,CAAC,CAAC,EAACF,CAAC,CAACC,CAAC,CAACC,CAAC,EAAC;IAACc,OAAO,EAACA,CAAA,KAAIb;EAAC,CAAC,CAAC;EAAC,MAAMA,CAAC,GAAC,2oBAA2oB;EAACc,MAAM,CAACC,OAAO,GAAChB,CAAC;AAAA,CAAC,EAAE,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}