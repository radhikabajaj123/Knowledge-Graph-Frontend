{"ast":null,"code":"var _jsxFileName = \"/Users/radhika.bajaj/Documents/GitHub/Knowledge-Graph-Frontend/src/components/NetworkDiagram.js\",\n  _s = $RefreshSig$();\nimport * as d3 from 'd3';\nimport { useEffect, useRef } from 'react';\nimport DrawNetwork from './DrawNetwork';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const NetworkDiagram = ({\n  graph\n}) => {\n  _s();\n  // The force simulation mutates links and nodes, so create a copy first\n  // Node positions are initialized by d3\n  const RADIUS = 40;\n  const links = graph.links.map(d => ({\n    ...d\n  }));\n  const nodes = graph.nodes.map(d => ({\n    ...d\n  }));\n  const canvasRef = useRef(null);\n  useEffect(() => {\n    // set dimension of the canvas element\n    const canvas = canvasRef.current;\n    const context = canvas === null || canvas === void 0 ? void 0 : canvas.getContext('2d');\n    if (!context) {\n      return;\n    }\n    let cameraOffset = {\n      x: window.innerWidth / 2,\n      y: window.innerHeight / 2\n    };\n    let cameraZoom = 1;\n    let MAX_ZOOM = 5;\n    let MIN_ZOOM = 0.1;\n    let SCROLL_SENSITIVITY = 0.0005;\n    context.translate(window.innerWidth / 2, window.innerHeight / 2);\n    context.scale(cameraZoom, cameraZoom);\n    context.translate(-window.innerWidth / 2 + cameraOffset.x, -window.innerHeight / 2 + cameraOffset.y);\n\n    // Gets the relevant location from a mouse or single touch event\n    function getEventLocation(e) {\n      if (e.touches && e.touches.length === 1) {\n        return {\n          x: e.touches[0].clientX,\n          y: e.touches[0].clientY\n        };\n      } else if (e.clientX && e.clientY) {\n        return {\n          x: e.clientX,\n          y: e.clientY\n        };\n      }\n    }\n    let isDragging = false;\n    let dragStart = {\n      x: 0,\n      y: 0\n    };\n    function onPointerDown(e) {\n      isDragging = true;\n      dragStart.x = getEventLocation(e).x / cameraZoom - cameraOffset.x;\n      dragStart.y = getEventLocation(e).y / cameraZoom - cameraOffset.y;\n    }\n    function onPointerUp(e) {\n      isDragging = false;\n      initialPinchDistance = null;\n      lastZoom = cameraZoom;\n    }\n    function onPointerMove(e) {\n      if (isDragging) {\n        cameraOffset.x = getEventLocation(e).x / cameraZoom - dragStart.x;\n        cameraOffset.y = getEventLocation(e).y / cameraZoom - dragStart.y;\n      }\n    }\n    function handleTouch(e, singleTouchHandler) {\n      if (e.touches.length === 1) {\n        singleTouchHandler(e);\n      } else if (e.type === \"touchmove\" && e.touches.length === 2) {\n        isDragging = false;\n        handlePinch(e);\n      }\n    }\n    let initialPinchDistance = null;\n    let lastZoom = cameraZoom;\n    function handlePinch(e) {\n      e.preventDefault();\n      let touch1 = {\n        x: e.touches[0].clientX,\n        y: e.touches[0].clientY\n      };\n      let touch2 = {\n        x: e.touches[1].clientX,\n        y: e.touches[1].clientY\n      };\n\n      // This is distance squared, but no need for an expensive sqrt as it's only used in ratio\n      let currentDistance = (touch1.x - touch2.x) ** 2 + (touch1.y - touch2.y) ** 2;\n      if (initialPinchDistance == null) {\n        initialPinchDistance = currentDistance;\n      } else {\n        adjustZoom(null, currentDistance / initialPinchDistance);\n      }\n    }\n    function adjustZoom(zoomAmount, zoomFactor) {\n      if (!isDragging) {\n        if (zoomAmount) {\n          cameraZoom += zoomAmount;\n        } else if (zoomFactor) {\n          console.log(zoomFactor);\n          cameraZoom = zoomFactor * lastZoom;\n        }\n        cameraZoom = Math.min(cameraZoom, MAX_ZOOM);\n        cameraZoom = Math.max(cameraZoom, MIN_ZOOM);\n        console.log(zoomAmount);\n      }\n    }\n    canvas.addEventListener('mousedown', onPointerDown);\n    canvas.addEventListener('touchstart', e => handleTouch(e, onPointerDown));\n    canvas.addEventListener('mouseup', onPointerUp);\n    canvas.addEventListener('touchend', e => handleTouch(e, onPointerUp));\n    canvas.addEventListener('mousemove', onPointerMove);\n    canvas.addEventListener('touchmove', e => handleTouch(e, onPointerMove));\n    canvas.addEventListener('wheel', e => adjustZoom(e.deltaY * SCROLL_SENSITIVITY));\n\n    // run d3-force to find the position of nodes on the canvas\n    d3.forceSimulation(nodes)\n\n    // list of forces we apply to get node positions\n    .force('link', d3.forceLink(links).id(d => d.id)).force('collide', d3.forceCollide().radius(RADIUS)).force('charge', d3.forceManyBody()).force('center', d3.forceCenter(window.innerWidth / 2, window.innerHeight / 2))\n\n    // at each iteration of the simulation, draw the network diagram with the new node positions\n    .on('tick', () => {\n      DrawNetwork(context, window.innerWidth, window.innerHeight, nodes, links, RADIUS);\n    });\n  }, [nodes, links]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      style: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        backgroundColor: \"#F2F1F1\"\n      },\n      width: window.innerWidth,\n      height: window.innerHeight\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 152,\n      columnNumber: 17\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 151,\n    columnNumber: 17\n  }, this);\n};\n_s(NetworkDiagram, \"UJgi7ynoup7eqypjnwyX/s32POg=\");\n_c = NetworkDiagram;\nvar _c;\n$RefreshReg$(_c, \"NetworkDiagram\");","map":{"version":3,"names":["d3","useEffect","useRef","DrawNetwork","jsxDEV","_jsxDEV","NetworkDiagram","graph","_s","RADIUS","links","map","d","nodes","canvasRef","canvas","current","context","getContext","cameraOffset","x","window","innerWidth","y","innerHeight","cameraZoom","MAX_ZOOM","MIN_ZOOM","SCROLL_SENSITIVITY","translate","scale","getEventLocation","e","touches","length","clientX","clientY","isDragging","dragStart","onPointerDown","onPointerUp","initialPinchDistance","lastZoom","onPointerMove","handleTouch","singleTouchHandler","type","handlePinch","preventDefault","touch1","touch2","currentDistance","adjustZoom","zoomAmount","zoomFactor","console","log","Math","min","max","addEventListener","deltaY","forceSimulation","force","forceLink","id","forceCollide","radius","forceManyBody","forceCenter","on","children","ref","style","width","height","backgroundColor","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/radhika.bajaj/Documents/GitHub/Knowledge-Graph-Frontend/src/components/NetworkDiagram.js"],"sourcesContent":["import * as d3 from 'd3';\nimport { useEffect, useRef } from 'react';\nimport DrawNetwork from './DrawNetwork';\n\nexport const NetworkDiagram = ({graph}) => {\n  // The force simulation mutates links and nodes, so create a copy first\n  // Node positions are initialized by d3\n  const RADIUS = 40;\n  const links = graph.links.map((d) => ({ ...d }));\n  const nodes = graph.nodes.map((d) => ({ ...d }));\n\n  const canvasRef = useRef(null);\n  \n\n  useEffect(() => {\n    // set dimension of the canvas element\n    const canvas = canvasRef.current;\n    const context = canvas?.getContext('2d');\n\n    if (!context) {\n      return;\n    }\n\n    let cameraOffset = { x: window.innerWidth/2, y: window.innerHeight/2 }\n    let cameraZoom = 1\n    let MAX_ZOOM = 5\n    let MIN_ZOOM = 0.1\n    let SCROLL_SENSITIVITY = 0.0005\n\n    context.translate( window.innerWidth / 2, window.innerHeight / 2 )\n    context.scale(cameraZoom, cameraZoom)\n    context.translate( -window.innerWidth / 2 + cameraOffset.x, -window.innerHeight / 2 + cameraOffset.y )\n\n    // Gets the relevant location from a mouse or single touch event\n    function getEventLocation(e) {\n        if (e.touches && e.touches.length === 1)\n        {\n            return { x:e.touches[0].clientX, y: e.touches[0].clientY }\n        }\n        else if (e.clientX && e.clientY)\n        {\n            return { x: e.clientX, y: e.clientY }        \n        }\n    }\n\n    let isDragging = false\n    let dragStart = { x: 0, y: 0 }\n\n    function onPointerDown(e) {\n        isDragging = true\n        dragStart.x = getEventLocation(e).x/cameraZoom - cameraOffset.x\n        dragStart.y = getEventLocation(e).y/cameraZoom - cameraOffset.y\n    }\n\n    function onPointerUp(e) {\n        isDragging = false\n        initialPinchDistance = null\n        lastZoom = cameraZoom\n    }\n\n    function onPointerMove(e) {\n        if (isDragging)\n        {\n            cameraOffset.x = getEventLocation(e).x/cameraZoom - dragStart.x\n            cameraOffset.y = getEventLocation(e).y/cameraZoom - dragStart.y\n        }\n    }\n\n    function handleTouch(e, singleTouchHandler) {\n        if ( e.touches.length === 1 )\n        {\n            singleTouchHandler(e)\n        }\n        else if (e.type === \"touchmove\" && e.touches.length === 2)\n        {\n            isDragging = false\n            handlePinch(e)\n        }\n    }\n\n    let initialPinchDistance = null\n    let lastZoom = cameraZoom\n\n    function handlePinch(e) {\n        e.preventDefault()\n        \n        let touch1 = { x: e.touches[0].clientX, y: e.touches[0].clientY }\n        let touch2 = { x: e.touches[1].clientX, y: e.touches[1].clientY }\n        \n        // This is distance squared, but no need for an expensive sqrt as it's only used in ratio\n        let currentDistance = (touch1.x - touch2.x)**2 + (touch1.y - touch2.y)**2\n        \n        if (initialPinchDistance == null)\n        {\n            initialPinchDistance = currentDistance\n        }\n        else\n        {\n            adjustZoom( null, currentDistance/initialPinchDistance )\n        }\n    }\n\n    function adjustZoom(zoomAmount, zoomFactor) {\n        if (!isDragging)\n        {\n            if (zoomAmount)\n            {\n                cameraZoom += zoomAmount\n            }\n            else if (zoomFactor)\n            {\n                console.log(zoomFactor)\n                cameraZoom = zoomFactor*lastZoom\n            }\n            \n            cameraZoom = Math.min( cameraZoom, MAX_ZOOM )\n            cameraZoom = Math.max( cameraZoom, MIN_ZOOM )\n            \n            console.log(zoomAmount)\n        }\n    }\n\n    canvas.addEventListener('mousedown', onPointerDown)\n    canvas.addEventListener('touchstart', (e) => handleTouch(e, onPointerDown))\n    canvas.addEventListener('mouseup', onPointerUp)\n    canvas.addEventListener('touchend',  (e) => handleTouch(e, onPointerUp))\n    canvas.addEventListener('mousemove', onPointerMove)\n    canvas.addEventListener('touchmove', (e) => handleTouch(e, onPointerMove))\n    canvas.addEventListener( 'wheel', (e) => adjustZoom(e.deltaY*SCROLL_SENSITIVITY))\n\n    // run d3-force to find the position of nodes on the canvas\n    d3.forceSimulation(nodes)\n\n      // list of forces we apply to get node positions\n      .force(\n        'link',\n        d3.forceLink(links).id((d) => d.id)\n      )\n      .force('collide', d3.forceCollide().radius(RADIUS))\n      .force('charge', d3.forceManyBody())\n      .force('center', d3.forceCenter(window.innerWidth / 2, window.innerHeight / 2))\n\n      // at each iteration of the simulation, draw the network diagram with the new node positions\n      .on('tick', () => {\n        DrawNetwork(context, window.innerWidth, window.innerHeight, nodes, links, RADIUS);\n      });\n  }, [nodes, links]);\n\n    \n    return (\n                <div>\n                <canvas\n                    ref={canvasRef}\n                    style={{\n                    width: window.innerWidth,\n                    height: window.innerHeight,\n                    backgroundColor: \"#F2F1F1\"\n                    }}\n                    width={window.innerWidth}\n                    height={window.innerHeight}\n                />\n                </div>\n        \n    );\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}