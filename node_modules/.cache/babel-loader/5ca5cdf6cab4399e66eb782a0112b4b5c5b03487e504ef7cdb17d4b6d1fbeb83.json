{"ast":null,"code":"!function (t, e) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? module.exports = e() : \"function\" == typeof define && define.amd ? define(e) : (t = \"undefined\" != typeof globalThis ? globalThis : t || self).graphology = e();\n}(this, function () {\n  \"use strict\";\n\n  function t(e) {\n    return t = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n      return typeof t;\n    } : function (t) {\n      return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n    }, t(e);\n  }\n  function e(t, e) {\n    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, r(t, e);\n  }\n  function n(t) {\n    return n = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {\n      return t.__proto__ || Object.getPrototypeOf(t);\n    }, n(t);\n  }\n  function r(t, e) {\n    return r = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {\n      return t.__proto__ = e, t;\n    }, r(t, e);\n  }\n  function i() {\n    if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n    if (Reflect.construct.sham) return !1;\n    if (\"function\" == typeof Proxy) return !0;\n    try {\n      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;\n    } catch (t) {\n      return !1;\n    }\n  }\n  function o(t, e, n) {\n    return o = i() ? Reflect.construct.bind() : function (t, e, n) {\n      var i = [null];\n      i.push.apply(i, e);\n      var o = new (Function.bind.apply(t, i))();\n      return n && r(o, n.prototype), o;\n    }, o.apply(null, arguments);\n  }\n  function a(t) {\n    var e = \"function\" == typeof Map ? new Map() : void 0;\n    return a = function (t) {\n      if (null === t || (i = t, -1 === Function.toString.call(i).indexOf(\"[native code]\"))) return t;\n      var i;\n      if (\"function\" != typeof t) throw new TypeError(\"Super expression must either be null or a function\");\n      if (void 0 !== e) {\n        if (e.has(t)) return e.get(t);\n        e.set(t, a);\n      }\n      function a() {\n        return o(t, arguments, n(this).constructor);\n      }\n      return a.prototype = Object.create(t.prototype, {\n        constructor: {\n          value: a,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), r(a, t);\n    }, a(t);\n  }\n  function c(t) {\n    if (void 0 === t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    return t;\n  }\n  var u = function () {\n    for (var t = arguments[0], e = 1, n = arguments.length; e < n; e++) if (arguments[e]) for (var r in arguments[e]) t[r] = arguments[e][r];\n    return t;\n  };\n  function d(t, e, n, r) {\n    var i = t._nodes.get(e),\n      o = null;\n    return i ? o = \"mixed\" === r ? i.out && i.out[n] || i.undirected && i.undirected[n] : \"directed\" === r ? i.out && i.out[n] : i.undirected && i.undirected[n] : o;\n  }\n  function s(e) {\n    return \"object\" === t(e) && null !== e;\n  }\n  function h(t) {\n    var e;\n    for (e in t) return !1;\n    return !0;\n  }\n  function p(t, e, n) {\n    Object.defineProperty(t, e, {\n      enumerable: !1,\n      configurable: !1,\n      writable: !0,\n      value: n\n    });\n  }\n  function f(t, e, n) {\n    var r = {\n      enumerable: !0,\n      configurable: !0\n    };\n    \"function\" == typeof n ? r.get = n : (r.value = n, r.writable = !1), Object.defineProperty(t, e, r);\n  }\n  function l(t) {\n    return !!s(t) && !(t.attributes && !Array.isArray(t.attributes));\n  }\n  \"function\" == typeof Object.assign && (u = Object.assign);\n  var g,\n    y = {\n      exports: {}\n    },\n    w = \"object\" == typeof Reflect ? Reflect : null,\n    v = w && \"function\" == typeof w.apply ? w.apply : function (t, e, n) {\n      return Function.prototype.apply.call(t, e, n);\n    };\n  g = w && \"function\" == typeof w.ownKeys ? w.ownKeys : Object.getOwnPropertySymbols ? function (t) {\n    return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));\n  } : function (t) {\n    return Object.getOwnPropertyNames(t);\n  };\n  var b = Number.isNaN || function (t) {\n    return t != t;\n  };\n  function m() {\n    m.init.call(this);\n  }\n  y.exports = m, y.exports.once = function (t, e) {\n    return new Promise(function (n, r) {\n      function i(n) {\n        t.removeListener(e, o), r(n);\n      }\n      function o() {\n        \"function\" == typeof t.removeListener && t.removeListener(\"error\", i), n([].slice.call(arguments));\n      }\n      U(t, e, o, {\n        once: !0\n      }), \"error\" !== e && function (t, e, n) {\n        \"function\" == typeof t.on && U(t, \"error\", e, n);\n      }(t, i, {\n        once: !0\n      });\n    });\n  }, m.EventEmitter = m, m.prototype._events = void 0, m.prototype._eventsCount = 0, m.prototype._maxListeners = void 0;\n  var k = 10;\n  function _(t) {\n    if (\"function\" != typeof t) throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof t);\n  }\n  function G(t) {\n    return void 0 === t._maxListeners ? m.defaultMaxListeners : t._maxListeners;\n  }\n  function x(t, e, n, r) {\n    var i, o, a, c;\n    if (_(n), void 0 === (o = t._events) ? (o = t._events = Object.create(null), t._eventsCount = 0) : (void 0 !== o.newListener && (t.emit(\"newListener\", e, n.listener ? n.listener : n), o = t._events), a = o[e]), void 0 === a) a = o[e] = n, ++t._eventsCount;else if (\"function\" == typeof a ? a = o[e] = r ? [n, a] : [a, n] : r ? a.unshift(n) : a.push(n), (i = G(t)) > 0 && a.length > i && !a.warned) {\n      a.warned = !0;\n      var u = new Error(\"Possible EventEmitter memory leak detected. \" + a.length + \" \" + String(e) + \" listeners added. Use emitter.setMaxListeners() to increase limit\");\n      u.name = \"MaxListenersExceededWarning\", u.emitter = t, u.type = e, u.count = a.length, c = u, console && console.warn && console.warn(c);\n    }\n    return t;\n  }\n  function E() {\n    if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);\n  }\n  function A(t, e, n) {\n    var r = {\n        fired: !1,\n        wrapFn: void 0,\n        target: t,\n        type: e,\n        listener: n\n      },\n      i = E.bind(r);\n    return i.listener = n, r.wrapFn = i, i;\n  }\n  function L(t, e, n) {\n    var r = t._events;\n    if (void 0 === r) return [];\n    var i = r[e];\n    return void 0 === i ? [] : \"function\" == typeof i ? n ? [i.listener || i] : [i] : n ? function (t) {\n      for (var e = new Array(t.length), n = 0; n < e.length; ++n) e[n] = t[n].listener || t[n];\n      return e;\n    }(i) : D(i, i.length);\n  }\n  function S(t) {\n    var e = this._events;\n    if (void 0 !== e) {\n      var n = e[t];\n      if (\"function\" == typeof n) return 1;\n      if (void 0 !== n) return n.length;\n    }\n    return 0;\n  }\n  function D(t, e) {\n    for (var n = new Array(e), r = 0; r < e; ++r) n[r] = t[r];\n    return n;\n  }\n  function U(t, e, n, r) {\n    if (\"function\" == typeof t.on) r.once ? t.once(e, n) : t.on(e, n);else {\n      if (\"function\" != typeof t.addEventListener) throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof t);\n      t.addEventListener(e, function i(o) {\n        r.once && t.removeEventListener(e, i), n(o);\n      });\n    }\n  }\n  function N(t) {\n    if (\"function\" != typeof t) throw new Error(\"obliterator/iterator: expecting a function!\");\n    this.next = t;\n  }\n  Object.defineProperty(m, \"defaultMaxListeners\", {\n    enumerable: !0,\n    get: function () {\n      return k;\n    },\n    set: function (t) {\n      if (\"number\" != typeof t || t < 0 || b(t)) throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + t + \".\");\n      k = t;\n    }\n  }), m.init = function () {\n    void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;\n  }, m.prototype.setMaxListeners = function (t) {\n    if (\"number\" != typeof t || t < 0 || b(t)) throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + t + \".\");\n    return this._maxListeners = t, this;\n  }, m.prototype.getMaxListeners = function () {\n    return G(this);\n  }, m.prototype.emit = function (t) {\n    for (var e = [], n = 1; n < arguments.length; n++) e.push(arguments[n]);\n    var r = \"error\" === t,\n      i = this._events;\n    if (void 0 !== i) r = r && void 0 === i.error;else if (!r) return !1;\n    if (r) {\n      var o;\n      if (e.length > 0 && (o = e[0]), o instanceof Error) throw o;\n      var a = new Error(\"Unhandled error.\" + (o ? \" (\" + o.message + \")\" : \"\"));\n      throw a.context = o, a;\n    }\n    var c = i[t];\n    if (void 0 === c) return !1;\n    if (\"function\" == typeof c) v(c, this, e);else {\n      var u = c.length,\n        d = D(c, u);\n      for (n = 0; n < u; ++n) v(d[n], this, e);\n    }\n    return !0;\n  }, m.prototype.addListener = function (t, e) {\n    return x(this, t, e, !1);\n  }, m.prototype.on = m.prototype.addListener, m.prototype.prependListener = function (t, e) {\n    return x(this, t, e, !0);\n  }, m.prototype.once = function (t, e) {\n    return _(e), this.on(t, A(this, t, e)), this;\n  }, m.prototype.prependOnceListener = function (t, e) {\n    return _(e), this.prependListener(t, A(this, t, e)), this;\n  }, m.prototype.removeListener = function (t, e) {\n    var n, r, i, o, a;\n    if (_(e), void 0 === (r = this._events)) return this;\n    if (void 0 === (n = r[t])) return this;\n    if (n === e || n.listener === e) 0 == --this._eventsCount ? this._events = Object.create(null) : (delete r[t], r.removeListener && this.emit(\"removeListener\", t, n.listener || e));else if (\"function\" != typeof n) {\n      for (i = -1, o = n.length - 1; o >= 0; o--) if (n[o] === e || n[o].listener === e) {\n        a = n[o].listener, i = o;\n        break;\n      }\n      if (i < 0) return this;\n      0 === i ? n.shift() : function (t, e) {\n        for (; e + 1 < t.length; e++) t[e] = t[e + 1];\n        t.pop();\n      }(n, i), 1 === n.length && (r[t] = n[0]), void 0 !== r.removeListener && this.emit(\"removeListener\", t, a || e);\n    }\n    return this;\n  }, m.prototype.off = m.prototype.removeListener, m.prototype.removeAllListeners = function (t) {\n    var e, n, r;\n    if (void 0 === (n = this._events)) return this;\n    if (void 0 === n.removeListener) return 0 === arguments.length ? (this._events = Object.create(null), this._eventsCount = 0) : void 0 !== n[t] && (0 == --this._eventsCount ? this._events = Object.create(null) : delete n[t]), this;\n    if (0 === arguments.length) {\n      var i,\n        o = Object.keys(n);\n      for (r = 0; r < o.length; ++r) \"removeListener\" !== (i = o[r]) && this.removeAllListeners(i);\n      return this.removeAllListeners(\"removeListener\"), this._events = Object.create(null), this._eventsCount = 0, this;\n    }\n    if (\"function\" == typeof (e = n[t])) this.removeListener(t, e);else if (void 0 !== e) for (r = e.length - 1; r >= 0; r--) this.removeListener(t, e[r]);\n    return this;\n  }, m.prototype.listeners = function (t) {\n    return L(this, t, !0);\n  }, m.prototype.rawListeners = function (t) {\n    return L(this, t, !1);\n  }, m.listenerCount = function (t, e) {\n    return \"function\" == typeof t.listenerCount ? t.listenerCount(e) : S.call(t, e);\n  }, m.prototype.listenerCount = S, m.prototype.eventNames = function () {\n    return this._eventsCount > 0 ? g(this._events) : [];\n  }, \"undefined\" != typeof Symbol && (N.prototype[Symbol.iterator] = function () {\n    return this;\n  }), N.of = function () {\n    var t = arguments,\n      e = t.length,\n      n = 0;\n    return new N(function () {\n      return n >= e ? {\n        done: !0\n      } : {\n        done: !1,\n        value: t[n++]\n      };\n    });\n  }, N.empty = function () {\n    return new N(function () {\n      return {\n        done: !0\n      };\n    });\n  }, N.fromSequence = function (t) {\n    var e = 0,\n      n = t.length;\n    return new N(function () {\n      return e >= n ? {\n        done: !0\n      } : {\n        done: !1,\n        value: t[e++]\n      };\n    });\n  }, N.is = function (t) {\n    return t instanceof N || \"object\" == typeof t && null !== t && \"function\" == typeof t.next;\n  };\n  var O = N,\n    j = {};\n  j.ARRAY_BUFFER_SUPPORT = \"undefined\" != typeof ArrayBuffer, j.SYMBOL_SUPPORT = \"undefined\" != typeof Symbol;\n  var C = O,\n    M = j,\n    z = M.ARRAY_BUFFER_SUPPORT,\n    W = M.SYMBOL_SUPPORT;\n  var P = function (t) {\n      var e = function (t) {\n        return \"string\" == typeof t || Array.isArray(t) || z && ArrayBuffer.isView(t) ? C.fromSequence(t) : \"object\" != typeof t || null === t ? null : W && \"function\" == typeof t[Symbol.iterator] ? t[Symbol.iterator]() : \"function\" == typeof t.next ? t : null;\n      }(t);\n      if (!e) throw new Error(\"obliterator: target is not iterable nor a valid iterator.\");\n      return e;\n    },\n    R = P,\n    K = function (t, e) {\n      for (var n, r = arguments.length > 1 ? e : 1 / 0, i = r !== 1 / 0 ? new Array(r) : [], o = 0, a = R(t);;) {\n        if (o === r) return i;\n        if ((n = a.next()).done) return o !== e && (i.length = o), i;\n        i[o++] = n.value;\n      }\n    },\n    T = function (t) {\n      function n(e) {\n        var n;\n        return (n = t.call(this) || this).name = \"GraphError\", n.message = e, n;\n      }\n      return e(n, t), n;\n    }(a(Error)),\n    B = function (t) {\n      function n(e) {\n        var r;\n        return (r = t.call(this, e) || this).name = \"InvalidArgumentsGraphError\", \"function\" == typeof Error.captureStackTrace && Error.captureStackTrace(c(r), n.prototype.constructor), r;\n      }\n      return e(n, t), n;\n    }(T),\n    F = function (t) {\n      function n(e) {\n        var r;\n        return (r = t.call(this, e) || this).name = \"NotFoundGraphError\", \"function\" == typeof Error.captureStackTrace && Error.captureStackTrace(c(r), n.prototype.constructor), r;\n      }\n      return e(n, t), n;\n    }(T),\n    I = function (t) {\n      function n(e) {\n        var r;\n        return (r = t.call(this, e) || this).name = \"UsageGraphError\", \"function\" == typeof Error.captureStackTrace && Error.captureStackTrace(c(r), n.prototype.constructor), r;\n      }\n      return e(n, t), n;\n    }(T);\n  function Y(t, e) {\n    this.key = t, this.attributes = e, this.clear();\n  }\n  function q(t, e) {\n    this.key = t, this.attributes = e, this.clear();\n  }\n  function J(t, e) {\n    this.key = t, this.attributes = e, this.clear();\n  }\n  function V(t, e, n, r, i) {\n    this.key = e, this.attributes = i, this.undirected = t, this.source = n, this.target = r;\n  }\n  Y.prototype.clear = function () {\n    this.inDegree = 0, this.outDegree = 0, this.undirectedDegree = 0, this.undirectedLoops = 0, this.directedLoops = 0, this.in = {}, this.out = {}, this.undirected = {};\n  }, q.prototype.clear = function () {\n    this.inDegree = 0, this.outDegree = 0, this.directedLoops = 0, this.in = {}, this.out = {};\n  }, J.prototype.clear = function () {\n    this.undirectedDegree = 0, this.undirectedLoops = 0, this.undirected = {};\n  }, V.prototype.attach = function () {\n    var t = \"out\",\n      e = \"in\";\n    this.undirected && (t = e = \"undirected\");\n    var n = this.source.key,\n      r = this.target.key;\n    this.source[t][r] = this, this.undirected && n === r || (this.target[e][n] = this);\n  }, V.prototype.attachMulti = function () {\n    var t = \"out\",\n      e = \"in\",\n      n = this.source.key,\n      r = this.target.key;\n    this.undirected && (t = e = \"undirected\");\n    var i = this.source[t],\n      o = i[r];\n    if (void 0 === o) return i[r] = this, void (this.undirected && n === r || (this.target[e][n] = this));\n    o.previous = this, this.next = o, i[r] = this, this.target[e][n] = this;\n  }, V.prototype.detach = function () {\n    var t = this.source.key,\n      e = this.target.key,\n      n = \"out\",\n      r = \"in\";\n    this.undirected && (n = r = \"undirected\"), delete this.source[n][e], delete this.target[r][t];\n  }, V.prototype.detachMulti = function () {\n    var t = this.source.key,\n      e = this.target.key,\n      n = \"out\",\n      r = \"in\";\n    this.undirected && (n = r = \"undirected\"), void 0 === this.previous ? void 0 === this.next ? (delete this.source[n][e], delete this.target[r][t]) : (this.next.previous = void 0, this.source[n][e] = this.next, this.target[r][t] = this.next) : (this.previous.next = this.next, void 0 !== this.next && (this.next.previous = this.previous));\n  };\n  function H(t, e, n, r, i, o, a) {\n    var c, u, d, s;\n    if (r = \"\" + r, 0 === n) {\n      if (!(c = t._nodes.get(r))) throw new F(\"Graph.\".concat(e, ': could not find the \"').concat(r, '\" node in the graph.'));\n      d = i, s = o;\n    } else if (3 === n) {\n      if (i = \"\" + i, !(u = t._edges.get(i))) throw new F(\"Graph.\".concat(e, ': could not find the \"').concat(i, '\" edge in the graph.'));\n      var h = u.source.key,\n        p = u.target.key;\n      if (r === h) c = u.target;else {\n        if (r !== p) throw new F(\"Graph.\".concat(e, ': the \"').concat(r, '\" node is not attached to the \"').concat(i, '\" edge (').concat(h, \", \").concat(p, \").\"));\n        c = u.source;\n      }\n      d = o, s = a;\n    } else {\n      if (!(u = t._edges.get(r))) throw new F(\"Graph.\".concat(e, ': could not find the \"').concat(r, '\" edge in the graph.'));\n      c = 1 === n ? u.source : u.target, d = i, s = o;\n    }\n    return [c, d, s];\n  }\n  var Q = [{\n    name: function (t) {\n      return \"get\".concat(t, \"Attribute\");\n    },\n    attacher: function (t, e, n) {\n      t.prototype[e] = function (t, r, i) {\n        var o = H(this, e, n, t, r, i),\n          a = o[0],\n          c = o[1];\n        return a.attributes[c];\n      };\n    }\n  }, {\n    name: function (t) {\n      return \"get\".concat(t, \"Attributes\");\n    },\n    attacher: function (t, e, n) {\n      t.prototype[e] = function (t, r) {\n        return H(this, e, n, t, r)[0].attributes;\n      };\n    }\n  }, {\n    name: function (t) {\n      return \"has\".concat(t, \"Attribute\");\n    },\n    attacher: function (t, e, n) {\n      t.prototype[e] = function (t, r, i) {\n        var o = H(this, e, n, t, r, i),\n          a = o[0],\n          c = o[1];\n        return a.attributes.hasOwnProperty(c);\n      };\n    }\n  }, {\n    name: function (t) {\n      return \"set\".concat(t, \"Attribute\");\n    },\n    attacher: function (t, e, n) {\n      t.prototype[e] = function (t, r, i, o) {\n        var a = H(this, e, n, t, r, i, o),\n          c = a[0],\n          u = a[1],\n          d = a[2];\n        return c.attributes[u] = d, this.emit(\"nodeAttributesUpdated\", {\n          key: c.key,\n          type: \"set\",\n          attributes: c.attributes,\n          name: u\n        }), this;\n      };\n    }\n  }, {\n    name: function (t) {\n      return \"update\".concat(t, \"Attribute\");\n    },\n    attacher: function (t, e, n) {\n      t.prototype[e] = function (t, r, i, o) {\n        var a = H(this, e, n, t, r, i, o),\n          c = a[0],\n          u = a[1],\n          d = a[2];\n        if (\"function\" != typeof d) throw new B(\"Graph.\".concat(e, \": updater should be a function.\"));\n        var s = c.attributes,\n          h = d(s[u]);\n        return s[u] = h, this.emit(\"nodeAttributesUpdated\", {\n          key: c.key,\n          type: \"set\",\n          attributes: c.attributes,\n          name: u\n        }), this;\n      };\n    }\n  }, {\n    name: function (t) {\n      return \"remove\".concat(t, \"Attribute\");\n    },\n    attacher: function (t, e, n) {\n      t.prototype[e] = function (t, r, i) {\n        var o = H(this, e, n, t, r, i),\n          a = o[0],\n          c = o[1];\n        return delete a.attributes[c], this.emit(\"nodeAttributesUpdated\", {\n          key: a.key,\n          type: \"remove\",\n          attributes: a.attributes,\n          name: c\n        }), this;\n      };\n    }\n  }, {\n    name: function (t) {\n      return \"replace\".concat(t, \"Attributes\");\n    },\n    attacher: function (t, e, n) {\n      t.prototype[e] = function (t, r, i) {\n        var o = H(this, e, n, t, r, i),\n          a = o[0],\n          c = o[1];\n        if (!s(c)) throw new B(\"Graph.\".concat(e, \": provided attributes are not a plain object.\"));\n        return a.attributes = c, this.emit(\"nodeAttributesUpdated\", {\n          key: a.key,\n          type: \"replace\",\n          attributes: a.attributes\n        }), this;\n      };\n    }\n  }, {\n    name: function (t) {\n      return \"merge\".concat(t, \"Attributes\");\n    },\n    attacher: function (t, e, n) {\n      t.prototype[e] = function (t, r, i) {\n        var o = H(this, e, n, t, r, i),\n          a = o[0],\n          c = o[1];\n        if (!s(c)) throw new B(\"Graph.\".concat(e, \": provided attributes are not a plain object.\"));\n        return u(a.attributes, c), this.emit(\"nodeAttributesUpdated\", {\n          key: a.key,\n          type: \"merge\",\n          attributes: a.attributes,\n          data: c\n        }), this;\n      };\n    }\n  }, {\n    name: function (t) {\n      return \"update\".concat(t, \"Attributes\");\n    },\n    attacher: function (t, e, n) {\n      t.prototype[e] = function (t, r, i) {\n        var o = H(this, e, n, t, r, i),\n          a = o[0],\n          c = o[1];\n        if (\"function\" != typeof c) throw new B(\"Graph.\".concat(e, \": provided updater is not a function.\"));\n        return a.attributes = c(a.attributes), this.emit(\"nodeAttributesUpdated\", {\n          key: a.key,\n          type: \"update\",\n          attributes: a.attributes\n        }), this;\n      };\n    }\n  }];\n  var X = [{\n    name: function (t) {\n      return \"get\".concat(t, \"Attribute\");\n    },\n    attacher: function (t, e, n) {\n      t.prototype[e] = function (t, r) {\n        var i;\n        if (\"mixed\" !== this.type && \"mixed\" !== n && n !== this.type) throw new I(\"Graph.\".concat(e, \": cannot find this type of edges in your \").concat(this.type, \" graph.\"));\n        if (arguments.length > 2) {\n          if (this.multi) throw new I(\"Graph.\".concat(e, \": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.\"));\n          var o = \"\" + t,\n            a = \"\" + r;\n          if (r = arguments[2], !(i = d(this, o, a, n))) throw new F(\"Graph.\".concat(e, ': could not find an edge for the given path (\"').concat(o, '\" - \"').concat(a, '\").'));\n        } else {\n          if (\"mixed\" !== n) throw new I(\"Graph.\".concat(e, \": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.\"));\n          if (t = \"\" + t, !(i = this._edges.get(t))) throw new F(\"Graph.\".concat(e, ': could not find the \"').concat(t, '\" edge in the graph.'));\n        }\n        return i.attributes[r];\n      };\n    }\n  }, {\n    name: function (t) {\n      return \"get\".concat(t, \"Attributes\");\n    },\n    attacher: function (t, e, n) {\n      t.prototype[e] = function (t) {\n        var r;\n        if (\"mixed\" !== this.type && \"mixed\" !== n && n !== this.type) throw new I(\"Graph.\".concat(e, \": cannot find this type of edges in your \").concat(this.type, \" graph.\"));\n        if (arguments.length > 1) {\n          if (this.multi) throw new I(\"Graph.\".concat(e, \": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.\"));\n          var i = \"\" + t,\n            o = \"\" + arguments[1];\n          if (!(r = d(this, i, o, n))) throw new F(\"Graph.\".concat(e, ': could not find an edge for the given path (\"').concat(i, '\" - \"').concat(o, '\").'));\n        } else {\n          if (\"mixed\" !== n) throw new I(\"Graph.\".concat(e, \": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.\"));\n          if (t = \"\" + t, !(r = this._edges.get(t))) throw new F(\"Graph.\".concat(e, ': could not find the \"').concat(t, '\" edge in the graph.'));\n        }\n        return r.attributes;\n      };\n    }\n  }, {\n    name: function (t) {\n      return \"has\".concat(t, \"Attribute\");\n    },\n    attacher: function (t, e, n) {\n      t.prototype[e] = function (t, r) {\n        var i;\n        if (\"mixed\" !== this.type && \"mixed\" !== n && n !== this.type) throw new I(\"Graph.\".concat(e, \": cannot find this type of edges in your \").concat(this.type, \" graph.\"));\n        if (arguments.length > 2) {\n          if (this.multi) throw new I(\"Graph.\".concat(e, \": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.\"));\n          var o = \"\" + t,\n            a = \"\" + r;\n          if (r = arguments[2], !(i = d(this, o, a, n))) throw new F(\"Graph.\".concat(e, ': could not find an edge for the given path (\"').concat(o, '\" - \"').concat(a, '\").'));\n        } else {\n          if (\"mixed\" !== n) throw new I(\"Graph.\".concat(e, \": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.\"));\n          if (t = \"\" + t, !(i = this._edges.get(t))) throw new F(\"Graph.\".concat(e, ': could not find the \"').concat(t, '\" edge in the graph.'));\n        }\n        return i.attributes.hasOwnProperty(r);\n      };\n    }\n  }, {\n    name: function (t) {\n      return \"set\".concat(t, \"Attribute\");\n    },\n    attacher: function (t, e, n) {\n      t.prototype[e] = function (t, r, i) {\n        var o;\n        if (\"mixed\" !== this.type && \"mixed\" !== n && n !== this.type) throw new I(\"Graph.\".concat(e, \": cannot find this type of edges in your \").concat(this.type, \" graph.\"));\n        if (arguments.length > 3) {\n          if (this.multi) throw new I(\"Graph.\".concat(e, \": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.\"));\n          var a = \"\" + t,\n            c = \"\" + r;\n          if (r = arguments[2], i = arguments[3], !(o = d(this, a, c, n))) throw new F(\"Graph.\".concat(e, ': could not find an edge for the given path (\"').concat(a, '\" - \"').concat(c, '\").'));\n        } else {\n          if (\"mixed\" !== n) throw new I(\"Graph.\".concat(e, \": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.\"));\n          if (t = \"\" + t, !(o = this._edges.get(t))) throw new F(\"Graph.\".concat(e, ': could not find the \"').concat(t, '\" edge in the graph.'));\n        }\n        return o.attributes[r] = i, this.emit(\"edgeAttributesUpdated\", {\n          key: o.key,\n          type: \"set\",\n          attributes: o.attributes,\n          name: r\n        }), this;\n      };\n    }\n  }, {\n    name: function (t) {\n      return \"update\".concat(t, \"Attribute\");\n    },\n    attacher: function (t, e, n) {\n      t.prototype[e] = function (t, r, i) {\n        var o;\n        if (\"mixed\" !== this.type && \"mixed\" !== n && n !== this.type) throw new I(\"Graph.\".concat(e, \": cannot find this type of edges in your \").concat(this.type, \" graph.\"));\n        if (arguments.length > 3) {\n          if (this.multi) throw new I(\"Graph.\".concat(e, \": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.\"));\n          var a = \"\" + t,\n            c = \"\" + r;\n          if (r = arguments[2], i = arguments[3], !(o = d(this, a, c, n))) throw new F(\"Graph.\".concat(e, ': could not find an edge for the given path (\"').concat(a, '\" - \"').concat(c, '\").'));\n        } else {\n          if (\"mixed\" !== n) throw new I(\"Graph.\".concat(e, \": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.\"));\n          if (t = \"\" + t, !(o = this._edges.get(t))) throw new F(\"Graph.\".concat(e, ': could not find the \"').concat(t, '\" edge in the graph.'));\n        }\n        if (\"function\" != typeof i) throw new B(\"Graph.\".concat(e, \": updater should be a function.\"));\n        return o.attributes[r] = i(o.attributes[r]), this.emit(\"edgeAttributesUpdated\", {\n          key: o.key,\n          type: \"set\",\n          attributes: o.attributes,\n          name: r\n        }), this;\n      };\n    }\n  }, {\n    name: function (t) {\n      return \"remove\".concat(t, \"Attribute\");\n    },\n    attacher: function (t, e, n) {\n      t.prototype[e] = function (t, r) {\n        var i;\n        if (\"mixed\" !== this.type && \"mixed\" !== n && n !== this.type) throw new I(\"Graph.\".concat(e, \": cannot find this type of edges in your \").concat(this.type, \" graph.\"));\n        if (arguments.length > 2) {\n          if (this.multi) throw new I(\"Graph.\".concat(e, \": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.\"));\n          var o = \"\" + t,\n            a = \"\" + r;\n          if (r = arguments[2], !(i = d(this, o, a, n))) throw new F(\"Graph.\".concat(e, ': could not find an edge for the given path (\"').concat(o, '\" - \"').concat(a, '\").'));\n        } else {\n          if (\"mixed\" !== n) throw new I(\"Graph.\".concat(e, \": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.\"));\n          if (t = \"\" + t, !(i = this._edges.get(t))) throw new F(\"Graph.\".concat(e, ': could not find the \"').concat(t, '\" edge in the graph.'));\n        }\n        return delete i.attributes[r], this.emit(\"edgeAttributesUpdated\", {\n          key: i.key,\n          type: \"remove\",\n          attributes: i.attributes,\n          name: r\n        }), this;\n      };\n    }\n  }, {\n    name: function (t) {\n      return \"replace\".concat(t, \"Attributes\");\n    },\n    attacher: function (t, e, n) {\n      t.prototype[e] = function (t, r) {\n        var i;\n        if (\"mixed\" !== this.type && \"mixed\" !== n && n !== this.type) throw new I(\"Graph.\".concat(e, \": cannot find this type of edges in your \").concat(this.type, \" graph.\"));\n        if (arguments.length > 2) {\n          if (this.multi) throw new I(\"Graph.\".concat(e, \": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.\"));\n          var o = \"\" + t,\n            a = \"\" + r;\n          if (r = arguments[2], !(i = d(this, o, a, n))) throw new F(\"Graph.\".concat(e, ': could not find an edge for the given path (\"').concat(o, '\" - \"').concat(a, '\").'));\n        } else {\n          if (\"mixed\" !== n) throw new I(\"Graph.\".concat(e, \": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.\"));\n          if (t = \"\" + t, !(i = this._edges.get(t))) throw new F(\"Graph.\".concat(e, ': could not find the \"').concat(t, '\" edge in the graph.'));\n        }\n        if (!s(r)) throw new B(\"Graph.\".concat(e, \": provided attributes are not a plain object.\"));\n        return i.attributes = r, this.emit(\"edgeAttributesUpdated\", {\n          key: i.key,\n          type: \"replace\",\n          attributes: i.attributes\n        }), this;\n      };\n    }\n  }, {\n    name: function (t) {\n      return \"merge\".concat(t, \"Attributes\");\n    },\n    attacher: function (t, e, n) {\n      t.prototype[e] = function (t, r) {\n        var i;\n        if (\"mixed\" !== this.type && \"mixed\" !== n && n !== this.type) throw new I(\"Graph.\".concat(e, \": cannot find this type of edges in your \").concat(this.type, \" graph.\"));\n        if (arguments.length > 2) {\n          if (this.multi) throw new I(\"Graph.\".concat(e, \": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.\"));\n          var o = \"\" + t,\n            a = \"\" + r;\n          if (r = arguments[2], !(i = d(this, o, a, n))) throw new F(\"Graph.\".concat(e, ': could not find an edge for the given path (\"').concat(o, '\" - \"').concat(a, '\").'));\n        } else {\n          if (\"mixed\" !== n) throw new I(\"Graph.\".concat(e, \": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.\"));\n          if (t = \"\" + t, !(i = this._edges.get(t))) throw new F(\"Graph.\".concat(e, ': could not find the \"').concat(t, '\" edge in the graph.'));\n        }\n        if (!s(r)) throw new B(\"Graph.\".concat(e, \": provided attributes are not a plain object.\"));\n        return u(i.attributes, r), this.emit(\"edgeAttributesUpdated\", {\n          key: i.key,\n          type: \"merge\",\n          attributes: i.attributes,\n          data: r\n        }), this;\n      };\n    }\n  }, {\n    name: function (t) {\n      return \"update\".concat(t, \"Attributes\");\n    },\n    attacher: function (t, e, n) {\n      t.prototype[e] = function (t, r) {\n        var i;\n        if (\"mixed\" !== this.type && \"mixed\" !== n && n !== this.type) throw new I(\"Graph.\".concat(e, \": cannot find this type of edges in your \").concat(this.type, \" graph.\"));\n        if (arguments.length > 2) {\n          if (this.multi) throw new I(\"Graph.\".concat(e, \": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.\"));\n          var o = \"\" + t,\n            a = \"\" + r;\n          if (r = arguments[2], !(i = d(this, o, a, n))) throw new F(\"Graph.\".concat(e, ': could not find an edge for the given path (\"').concat(o, '\" - \"').concat(a, '\").'));\n        } else {\n          if (\"mixed\" !== n) throw new I(\"Graph.\".concat(e, \": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.\"));\n          if (t = \"\" + t, !(i = this._edges.get(t))) throw new F(\"Graph.\".concat(e, ': could not find the \"').concat(t, '\" edge in the graph.'));\n        }\n        if (\"function\" != typeof r) throw new B(\"Graph.\".concat(e, \": provided updater is not a function.\"));\n        return i.attributes = r(i.attributes), this.emit(\"edgeAttributesUpdated\", {\n          key: i.key,\n          type: \"update\",\n          attributes: i.attributes\n        }), this;\n      };\n    }\n  }];\n  var Z = O,\n    $ = P,\n    tt = function () {\n      var t = arguments,\n        e = null,\n        n = -1;\n      return new Z(function () {\n        for (var r = null;;) {\n          if (null === e) {\n            if (++n >= t.length) return {\n              done: !0\n            };\n            e = $(t[n]);\n          }\n          if (!0 !== (r = e.next()).done) break;\n          e = null;\n        }\n        return r;\n      });\n    },\n    et = [{\n      name: \"edges\",\n      type: \"mixed\"\n    }, {\n      name: \"inEdges\",\n      type: \"directed\",\n      direction: \"in\"\n    }, {\n      name: \"outEdges\",\n      type: \"directed\",\n      direction: \"out\"\n    }, {\n      name: \"inboundEdges\",\n      type: \"mixed\",\n      direction: \"in\"\n    }, {\n      name: \"outboundEdges\",\n      type: \"mixed\",\n      direction: \"out\"\n    }, {\n      name: \"directedEdges\",\n      type: \"directed\"\n    }, {\n      name: \"undirectedEdges\",\n      type: \"undirected\"\n    }];\n  function nt(t, e, n, r) {\n    var i = !1;\n    for (var o in e) if (o !== r) {\n      var a = e[o];\n      if (i = n(a.key, a.attributes, a.source.key, a.target.key, a.source.attributes, a.target.attributes, a.undirected), t && i) return a.key;\n    }\n  }\n  function rt(t, e, n, r) {\n    var i,\n      o,\n      a,\n      c = !1;\n    for (var u in e) if (u !== r) {\n      i = e[u];\n      do {\n        if (o = i.source, a = i.target, c = n(i.key, i.attributes, o.key, a.key, o.attributes, a.attributes, i.undirected), t && c) return i.key;\n        i = i.next;\n      } while (void 0 !== i);\n    }\n  }\n  function it(t, e) {\n    var n,\n      r = Object.keys(t),\n      i = r.length,\n      o = 0;\n    return new O(function () {\n      do {\n        if (n) n = n.next;else {\n          if (o >= i) return {\n            done: !0\n          };\n          var a = r[o++];\n          if (a === e) {\n            n = void 0;\n            continue;\n          }\n          n = t[a];\n        }\n      } while (!n);\n      return {\n        done: !1,\n        value: {\n          edge: n.key,\n          attributes: n.attributes,\n          source: n.source.key,\n          target: n.target.key,\n          sourceAttributes: n.source.attributes,\n          targetAttributes: n.target.attributes,\n          undirected: n.undirected\n        }\n      };\n    });\n  }\n  function ot(t, e, n, r) {\n    var i = e[n];\n    if (i) {\n      var o = i.source,\n        a = i.target;\n      return r(i.key, i.attributes, o.key, a.key, o.attributes, a.attributes, i.undirected) && t ? i.key : void 0;\n    }\n  }\n  function at(t, e, n, r) {\n    var i = e[n];\n    if (i) {\n      var o = !1;\n      do {\n        if (o = r(i.key, i.attributes, i.source.key, i.target.key, i.source.attributes, i.target.attributes, i.undirected), t && o) return i.key;\n        i = i.next;\n      } while (void 0 !== i);\n    }\n  }\n  function ct(t, e) {\n    var n = t[e];\n    return void 0 !== n.next ? new O(function () {\n      if (!n) return {\n        done: !0\n      };\n      var t = {\n        edge: n.key,\n        attributes: n.attributes,\n        source: n.source.key,\n        target: n.target.key,\n        sourceAttributes: n.source.attributes,\n        targetAttributes: n.target.attributes,\n        undirected: n.undirected\n      };\n      return n = n.next, {\n        done: !1,\n        value: t\n      };\n    }) : O.of({\n      edge: n.key,\n      attributes: n.attributes,\n      source: n.source.key,\n      target: n.target.key,\n      sourceAttributes: n.source.attributes,\n      targetAttributes: n.target.attributes,\n      undirected: n.undirected\n    });\n  }\n  function ut(t, e) {\n    if (0 === t.size) return [];\n    if (\"mixed\" === e || e === t.type) return \"function\" == typeof Array.from ? Array.from(t._edges.keys()) : K(t._edges.keys(), t._edges.size);\n    for (var n, r, i = \"undirected\" === e ? t.undirectedSize : t.directedSize, o = new Array(i), a = \"undirected\" === e, c = t._edges.values(), u = 0; !0 !== (n = c.next()).done;) (r = n.value).undirected === a && (o[u++] = r.key);\n    return o;\n  }\n  function dt(t, e, n, r) {\n    if (0 !== e.size) for (var i, o, a = \"mixed\" !== n && n !== e.type, c = \"undirected\" === n, u = !1, d = e._edges.values(); !0 !== (i = d.next()).done;) if (o = i.value, !a || o.undirected === c) {\n      var s = o,\n        h = s.key,\n        p = s.attributes,\n        f = s.source,\n        l = s.target;\n      if (u = r(h, p, f.key, l.key, f.attributes, l.attributes, o.undirected), t && u) return h;\n    }\n  }\n  function st(t, e) {\n    if (0 === t.size) return O.empty();\n    var n = \"mixed\" !== e && e !== t.type,\n      r = \"undirected\" === e,\n      i = t._edges.values();\n    return new O(function () {\n      for (var t, e;;) {\n        if ((t = i.next()).done) return t;\n        if (e = t.value, !n || e.undirected === r) break;\n      }\n      return {\n        value: {\n          edge: e.key,\n          attributes: e.attributes,\n          source: e.source.key,\n          target: e.target.key,\n          sourceAttributes: e.source.attributes,\n          targetAttributes: e.target.attributes,\n          undirected: e.undirected\n        },\n        done: !1\n      };\n    });\n  }\n  function ht(t, e, n, r, i, o) {\n    var a,\n      c = e ? rt : nt;\n    if (\"undirected\" !== n) {\n      if (\"out\" !== r && (a = c(t, i.in, o), t && a)) return a;\n      if (\"in\" !== r && (a = c(t, i.out, o, r ? void 0 : i.key), t && a)) return a;\n    }\n    if (\"directed\" !== n && (a = c(t, i.undirected, o), t && a)) return a;\n  }\n  function pt(t, e, n, r) {\n    var i = [];\n    return ht(!1, t, e, n, r, function (t) {\n      i.push(t);\n    }), i;\n  }\n  function ft(t, e, n) {\n    var r = O.empty();\n    return \"undirected\" !== t && (\"out\" !== e && void 0 !== n.in && (r = tt(r, it(n.in))), \"in\" !== e && void 0 !== n.out && (r = tt(r, it(n.out, e ? void 0 : n.key)))), \"directed\" !== t && void 0 !== n.undirected && (r = tt(r, it(n.undirected))), r;\n  }\n  function lt(t, e, n, r, i, o, a) {\n    var c,\n      u = n ? at : ot;\n    if (\"undirected\" !== e) {\n      if (void 0 !== i.in && \"out\" !== r && (c = u(t, i.in, o, a), t && c)) return c;\n      if (void 0 !== i.out && \"in\" !== r && (r || i.key !== o) && (c = u(t, i.out, o, a), t && c)) return c;\n    }\n    if (\"directed\" !== e && void 0 !== i.undirected && (c = u(t, i.undirected, o, a), t && c)) return c;\n  }\n  function gt(t, e, n, r, i) {\n    var o = [];\n    return lt(!1, t, e, n, r, i, function (t) {\n      o.push(t);\n    }), o;\n  }\n  function yt(t, e, n, r) {\n    var i = O.empty();\n    return \"undirected\" !== t && (void 0 !== n.in && \"out\" !== e && r in n.in && (i = tt(i, ct(n.in, r))), void 0 !== n.out && \"in\" !== e && r in n.out && (e || n.key !== r) && (i = tt(i, ct(n.out, r)))), \"directed\" !== t && void 0 !== n.undirected && r in n.undirected && (i = tt(i, ct(n.undirected, r))), i;\n  }\n  var wt = [{\n    name: \"neighbors\",\n    type: \"mixed\"\n  }, {\n    name: \"inNeighbors\",\n    type: \"directed\",\n    direction: \"in\"\n  }, {\n    name: \"outNeighbors\",\n    type: \"directed\",\n    direction: \"out\"\n  }, {\n    name: \"inboundNeighbors\",\n    type: \"mixed\",\n    direction: \"in\"\n  }, {\n    name: \"outboundNeighbors\",\n    type: \"mixed\",\n    direction: \"out\"\n  }, {\n    name: \"directedNeighbors\",\n    type: \"directed\"\n  }, {\n    name: \"undirectedNeighbors\",\n    type: \"undirected\"\n  }];\n  function vt() {\n    this.A = null, this.B = null;\n  }\n  function bt(t, e, n, r, i) {\n    for (var o in r) {\n      var a = r[o],\n        c = a.source,\n        u = a.target,\n        d = c === n ? u : c;\n      if (!e || !e.has(d.key)) {\n        var s = i(d.key, d.attributes);\n        if (t && s) return d.key;\n      }\n    }\n  }\n  function mt(t, e, n, r, i) {\n    if (\"mixed\" !== e) {\n      if (\"undirected\" === e) return bt(t, null, r, r.undirected, i);\n      if (\"string\" == typeof n) return bt(t, null, r, r[n], i);\n    }\n    var o,\n      a = new vt();\n    if (\"undirected\" !== e) {\n      if (\"out\" !== n) {\n        if (o = bt(t, null, r, r.in, i), t && o) return o;\n        a.wrap(r.in);\n      }\n      if (\"in\" !== n) {\n        if (o = bt(t, a, r, r.out, i), t && o) return o;\n        a.wrap(r.out);\n      }\n    }\n    if (\"directed\" !== e && (o = bt(t, a, r, r.undirected, i), t && o)) return o;\n  }\n  function kt(t, e, n) {\n    var r = Object.keys(n),\n      i = r.length,\n      o = 0;\n    return new O(function () {\n      var a = null;\n      do {\n        if (o >= i) return t && t.wrap(n), {\n          done: !0\n        };\n        var c = n[r[o++]],\n          u = c.source,\n          d = c.target;\n        a = u === e ? d : u, t && t.has(a.key) && (a = null);\n      } while (null === a);\n      return {\n        done: !1,\n        value: {\n          neighbor: a.key,\n          attributes: a.attributes\n        }\n      };\n    });\n  }\n  function _t(t, e) {\n    var n = e.name,\n      r = e.type,\n      i = e.direction;\n    t.prototype[n] = function (t) {\n      if (\"mixed\" !== r && \"mixed\" !== this.type && r !== this.type) return [];\n      t = \"\" + t;\n      var e = this._nodes.get(t);\n      if (void 0 === e) throw new F(\"Graph.\".concat(n, ': could not find the \"').concat(t, '\" node in the graph.'));\n      return function (t, e, n) {\n        if (\"mixed\" !== t) {\n          if (\"undirected\" === t) return Object.keys(n.undirected);\n          if (\"string\" == typeof e) return Object.keys(n[e]);\n        }\n        var r = [];\n        return mt(!1, t, e, n, function (t) {\n          r.push(t);\n        }), r;\n      }(\"mixed\" === r ? this.type : r, i, e);\n    };\n  }\n  function Gt(t, e) {\n    var n = e.name,\n      r = e.type,\n      i = e.direction,\n      o = n.slice(0, -1) + \"Entries\";\n    t.prototype[o] = function (t) {\n      if (\"mixed\" !== r && \"mixed\" !== this.type && r !== this.type) return O.empty();\n      t = \"\" + t;\n      var e = this._nodes.get(t);\n      if (void 0 === e) throw new F(\"Graph.\".concat(o, ': could not find the \"').concat(t, '\" node in the graph.'));\n      return function (t, e, n) {\n        if (\"mixed\" !== t) {\n          if (\"undirected\" === t) return kt(null, n, n.undirected);\n          if (\"string\" == typeof e) return kt(null, n, n[e]);\n        }\n        var r = O.empty(),\n          i = new vt();\n        return \"undirected\" !== t && (\"out\" !== e && (r = tt(r, kt(i, n, n.in))), \"in\" !== e && (r = tt(r, kt(i, n, n.out)))), \"directed\" !== t && (r = tt(r, kt(i, n, n.undirected))), r;\n      }(\"mixed\" === r ? this.type : r, i, e);\n    };\n  }\n  function xt(t, e, n, r, i) {\n    for (var o, a, c, u, d, s, h, p = r._nodes.values(), f = r.type; !0 !== (o = p.next()).done;) {\n      var l = !1;\n      if (a = o.value, \"undirected\" !== f) for (c in u = a.out) {\n        d = u[c];\n        do {\n          if (s = d.target, l = !0, h = i(a.key, s.key, a.attributes, s.attributes, d.key, d.attributes, d.undirected), t && h) return d;\n          d = d.next;\n        } while (d);\n      }\n      if (\"directed\" !== f) for (c in u = a.undirected) if (!(e && a.key > c)) {\n        d = u[c];\n        do {\n          if ((s = d.target).key !== c && (s = d.source), l = !0, h = i(a.key, s.key, a.attributes, s.attributes, d.key, d.attributes, d.undirected), t && h) return d;\n          d = d.next;\n        } while (d);\n      }\n      if (n && !l && (h = i(a.key, null, a.attributes, null, null, null, null), t && h)) return null;\n    }\n  }\n  function Et(t) {\n    if (!s(t)) throw new B('Graph.import: invalid serialized node. A serialized node should be a plain object with at least a \"key\" property.');\n    if (!(\"key\" in t)) throw new B(\"Graph.import: serialized node is missing its key.\");\n    if (\"attributes\" in t && (!s(t.attributes) || null === t.attributes)) throw new B(\"Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.\");\n  }\n  function At(t) {\n    if (!s(t)) throw new B('Graph.import: invalid serialized edge. A serialized edge should be a plain object with at least a \"source\" & \"target\" property.');\n    if (!(\"source\" in t)) throw new B(\"Graph.import: serialized edge is missing its source.\");\n    if (!(\"target\" in t)) throw new B(\"Graph.import: serialized edge is missing its target.\");\n    if (\"attributes\" in t && (!s(t.attributes) || null === t.attributes)) throw new B(\"Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.\");\n    if (\"undirected\" in t && \"boolean\" != typeof t.undirected) throw new B(\"Graph.import: invalid undirectedness information. Undirected should be boolean or omitted.\");\n  }\n  vt.prototype.wrap = function (t) {\n    null === this.A ? this.A = t : null === this.B && (this.B = t);\n  }, vt.prototype.has = function (t) {\n    return null !== this.A && t in this.A || null !== this.B && t in this.B;\n  };\n  var Lt,\n    St = (Lt = 255 & Math.floor(256 * Math.random()), function () {\n      return Lt++;\n    }),\n    Dt = new Set([\"directed\", \"undirected\", \"mixed\"]),\n    Ut = new Set([\"domain\", \"_events\", \"_eventsCount\", \"_maxListeners\"]),\n    Nt = {\n      allowSelfLoops: !0,\n      multi: !1,\n      type: \"mixed\"\n    };\n  function Ot(t, e, n) {\n    var r = new t.NodeDataClass(e, n);\n    return t._nodes.set(e, r), t.emit(\"nodeAdded\", {\n      key: e,\n      attributes: n\n    }), r;\n  }\n  function jt(t, e, n, r, i, o, a, c) {\n    if (!r && \"undirected\" === t.type) throw new I(\"Graph.\".concat(e, \": you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.\"));\n    if (r && \"directed\" === t.type) throw new I(\"Graph.\".concat(e, \": you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.\"));\n    if (c && !s(c)) throw new B(\"Graph.\".concat(e, ': invalid attributes. Expecting an object but got \"').concat(c, '\"'));\n    if (o = \"\" + o, a = \"\" + a, c = c || {}, !t.allowSelfLoops && o === a) throw new I(\"Graph.\".concat(e, ': source & target are the same (\"').concat(o, \"\\\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.\"));\n    var u = t._nodes.get(o),\n      d = t._nodes.get(a);\n    if (!u) throw new F(\"Graph.\".concat(e, ': source node \"').concat(o, '\" not found.'));\n    if (!d) throw new F(\"Graph.\".concat(e, ': target node \"').concat(a, '\" not found.'));\n    var h = {\n      key: null,\n      undirected: r,\n      source: o,\n      target: a,\n      attributes: c\n    };\n    if (n) i = t._edgeKeyGenerator();else if (i = \"\" + i, t._edges.has(i)) throw new I(\"Graph.\".concat(e, ': the \"').concat(i, '\" edge already exists in the graph.'));\n    if (!t.multi && (r ? void 0 !== u.undirected[a] : void 0 !== u.out[a])) throw new I(\"Graph.\".concat(e, ': an edge linking \"').concat(o, '\" to \"').concat(a, \"\\\" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.\"));\n    var p = new V(r, i, u, d, c);\n    t._edges.set(i, p);\n    var f = o === a;\n    return r ? (u.undirectedDegree++, d.undirectedDegree++, f && (u.undirectedLoops++, t._undirectedSelfLoopCount++)) : (u.outDegree++, d.inDegree++, f && (u.directedLoops++, t._directedSelfLoopCount++)), t.multi ? p.attachMulti() : p.attach(), r ? t._undirectedSize++ : t._directedSize++, h.key = i, t.emit(\"edgeAdded\", h), i;\n  }\n  function Ct(t, e, n, r, i, o, a, c, d) {\n    if (!r && \"undirected\" === t.type) throw new I(\"Graph.\".concat(e, \": you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead.\"));\n    if (r && \"directed\" === t.type) throw new I(\"Graph.\".concat(e, \": you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead.\"));\n    if (c) if (d) {\n      if (\"function\" != typeof c) throw new B(\"Graph.\".concat(e, ': invalid updater function. Expecting a function but got \"').concat(c, '\"'));\n    } else if (!s(c)) throw new B(\"Graph.\".concat(e, ': invalid attributes. Expecting an object but got \"').concat(c, '\"'));\n    var h;\n    if (o = \"\" + o, a = \"\" + a, d && (h = c, c = void 0), !t.allowSelfLoops && o === a) throw new I(\"Graph.\".concat(e, ': source & target are the same (\"').concat(o, \"\\\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.\"));\n    var p,\n      f,\n      l = t._nodes.get(o),\n      g = t._nodes.get(a);\n    if (!n && (p = t._edges.get(i))) {\n      if (!(p.source.key === o && p.target.key === a || r && p.source.key === a && p.target.key === o)) throw new I(\"Graph.\".concat(e, ': inconsistency detected when attempting to merge the \"').concat(i, '\" edge with \"').concat(o, '\" source & \"').concat(a, '\" target vs. (\"').concat(p.source.key, '\", \"').concat(p.target.key, '\").'));\n      f = p;\n    }\n    if (f || t.multi || !l || (f = r ? l.undirected[a] : l.out[a]), f) {\n      var y = [f.key, !1, !1, !1];\n      if (d ? !h : !c) return y;\n      if (d) {\n        var w = f.attributes;\n        f.attributes = h(w), t.emit(\"edgeAttributesUpdated\", {\n          type: \"replace\",\n          key: f.key,\n          attributes: f.attributes\n        });\n      } else u(f.attributes, c), t.emit(\"edgeAttributesUpdated\", {\n        type: \"merge\",\n        key: f.key,\n        attributes: f.attributes,\n        data: c\n      });\n      return y;\n    }\n    c = c || {}, d && h && (c = h(c));\n    var v = {\n      key: null,\n      undirected: r,\n      source: o,\n      target: a,\n      attributes: c\n    };\n    if (n) i = t._edgeKeyGenerator();else if (i = \"\" + i, t._edges.has(i)) throw new I(\"Graph.\".concat(e, ': the \"').concat(i, '\" edge already exists in the graph.'));\n    var b = !1,\n      m = !1;\n    l || (l = Ot(t, o, {}), b = !0, o === a && (g = l, m = !0)), g || (g = Ot(t, a, {}), m = !0), p = new V(r, i, l, g, c), t._edges.set(i, p);\n    var k = o === a;\n    return r ? (l.undirectedDegree++, g.undirectedDegree++, k && (l.undirectedLoops++, t._undirectedSelfLoopCount++)) : (l.outDegree++, g.inDegree++, k && (l.directedLoops++, t._directedSelfLoopCount++)), t.multi ? p.attachMulti() : p.attach(), r ? t._undirectedSize++ : t._directedSize++, v.key = i, t.emit(\"edgeAdded\", v), [i, !0, b, m];\n  }\n  function Mt(t, e) {\n    t._edges.delete(e.key);\n    var n = e.source,\n      r = e.target,\n      i = e.attributes,\n      o = e.undirected,\n      a = n === r;\n    o ? (n.undirectedDegree--, r.undirectedDegree--, a && (n.undirectedLoops--, t._undirectedSelfLoopCount--)) : (n.outDegree--, r.inDegree--, a && (n.directedLoops--, t._directedSelfLoopCount--)), t.multi ? e.detachMulti() : e.detach(), o ? t._undirectedSize-- : t._directedSize--, t.emit(\"edgeDropped\", {\n      key: e.key,\n      attributes: i,\n      source: n.key,\n      target: r.key,\n      undirected: o\n    });\n  }\n  var zt = function (n) {\n    function r(t) {\n      var e;\n      if (e = n.call(this) || this, \"boolean\" != typeof (t = u({}, Nt, t)).multi) throw new B(\"Graph.constructor: invalid 'multi' option. Expecting a boolean but got \\\"\".concat(t.multi, '\".'));\n      if (!Dt.has(t.type)) throw new B('Graph.constructor: invalid \\'type\\' option. Should be one of \"mixed\", \"directed\" or \"undirected\" but got \"'.concat(t.type, '\".'));\n      if (\"boolean\" != typeof t.allowSelfLoops) throw new B(\"Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got \\\"\".concat(t.allowSelfLoops, '\".'));\n      var r = \"mixed\" === t.type ? Y : \"directed\" === t.type ? q : J;\n      p(c(e), \"NodeDataClass\", r);\n      var i = \"geid_\" + St() + \"_\",\n        o = 0;\n      return p(c(e), \"_attributes\", {}), p(c(e), \"_nodes\", new Map()), p(c(e), \"_edges\", new Map()), p(c(e), \"_directedSize\", 0), p(c(e), \"_undirectedSize\", 0), p(c(e), \"_directedSelfLoopCount\", 0), p(c(e), \"_undirectedSelfLoopCount\", 0), p(c(e), \"_edgeKeyGenerator\", function () {\n        var t;\n        do {\n          t = i + o++;\n        } while (e._edges.has(t));\n        return t;\n      }), p(c(e), \"_options\", t), Ut.forEach(function (t) {\n        return p(c(e), t, e[t]);\n      }), f(c(e), \"order\", function () {\n        return e._nodes.size;\n      }), f(c(e), \"size\", function () {\n        return e._edges.size;\n      }), f(c(e), \"directedSize\", function () {\n        return e._directedSize;\n      }), f(c(e), \"undirectedSize\", function () {\n        return e._undirectedSize;\n      }), f(c(e), \"selfLoopCount\", function () {\n        return e._directedSelfLoopCount + e._undirectedSelfLoopCount;\n      }), f(c(e), \"directedSelfLoopCount\", function () {\n        return e._directedSelfLoopCount;\n      }), f(c(e), \"undirectedSelfLoopCount\", function () {\n        return e._undirectedSelfLoopCount;\n      }), f(c(e), \"multi\", e._options.multi), f(c(e), \"type\", e._options.type), f(c(e), \"allowSelfLoops\", e._options.allowSelfLoops), f(c(e), \"implementation\", function () {\n        return \"graphology\";\n      }), e;\n    }\n    e(r, n);\n    var i = r.prototype;\n    return i._resetInstanceCounters = function () {\n      this._directedSize = 0, this._undirectedSize = 0, this._directedSelfLoopCount = 0, this._undirectedSelfLoopCount = 0;\n    }, i.hasNode = function (t) {\n      return this._nodes.has(\"\" + t);\n    }, i.hasDirectedEdge = function (t, e) {\n      if (\"undirected\" === this.type) return !1;\n      if (1 === arguments.length) {\n        var n = \"\" + t,\n          r = this._edges.get(n);\n        return !!r && !r.undirected;\n      }\n      if (2 === arguments.length) {\n        t = \"\" + t, e = \"\" + e;\n        var i = this._nodes.get(t);\n        return !!i && i.out.hasOwnProperty(e);\n      }\n      throw new B(\"Graph.hasDirectedEdge: invalid arity (\".concat(arguments.length, \", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.\"));\n    }, i.hasUndirectedEdge = function (t, e) {\n      if (\"directed\" === this.type) return !1;\n      if (1 === arguments.length) {\n        var n = \"\" + t,\n          r = this._edges.get(n);\n        return !!r && r.undirected;\n      }\n      if (2 === arguments.length) {\n        t = \"\" + t, e = \"\" + e;\n        var i = this._nodes.get(t);\n        return !!i && i.undirected.hasOwnProperty(e);\n      }\n      throw new B(\"Graph.hasDirectedEdge: invalid arity (\".concat(arguments.length, \", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.\"));\n    }, i.hasEdge = function (t, e) {\n      if (1 === arguments.length) {\n        var n = \"\" + t;\n        return this._edges.has(n);\n      }\n      if (2 === arguments.length) {\n        t = \"\" + t, e = \"\" + e;\n        var r = this._nodes.get(t);\n        return !!r && (void 0 !== r.out && r.out.hasOwnProperty(e) || void 0 !== r.undirected && r.undirected.hasOwnProperty(e));\n      }\n      throw new B(\"Graph.hasEdge: invalid arity (\".concat(arguments.length, \", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.\"));\n    }, i.directedEdge = function (t, e) {\n      if (\"undirected\" !== this.type) {\n        if (t = \"\" + t, e = \"\" + e, this.multi) throw new I(\"Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.\");\n        var n = this._nodes.get(t);\n        if (!n) throw new F('Graph.directedEdge: could not find the \"'.concat(t, '\" source node in the graph.'));\n        if (!this._nodes.has(e)) throw new F('Graph.directedEdge: could not find the \"'.concat(e, '\" target node in the graph.'));\n        var r = n.out && n.out[e] || void 0;\n        return r ? r.key : void 0;\n      }\n    }, i.undirectedEdge = function (t, e) {\n      if (\"directed\" !== this.type) {\n        if (t = \"\" + t, e = \"\" + e, this.multi) throw new I(\"Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.\");\n        var n = this._nodes.get(t);\n        if (!n) throw new F('Graph.undirectedEdge: could not find the \"'.concat(t, '\" source node in the graph.'));\n        if (!this._nodes.has(e)) throw new F('Graph.undirectedEdge: could not find the \"'.concat(e, '\" target node in the graph.'));\n        var r = n.undirected && n.undirected[e] || void 0;\n        return r ? r.key : void 0;\n      }\n    }, i.edge = function (t, e) {\n      if (this.multi) throw new I(\"Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.\");\n      t = \"\" + t, e = \"\" + e;\n      var n = this._nodes.get(t);\n      if (!n) throw new F('Graph.edge: could not find the \"'.concat(t, '\" source node in the graph.'));\n      if (!this._nodes.has(e)) throw new F('Graph.edge: could not find the \"'.concat(e, '\" target node in the graph.'));\n      var r = n.out && n.out[e] || n.undirected && n.undirected[e] || void 0;\n      if (r) return r.key;\n    }, i.areDirectedNeighbors = function (t, e) {\n      t = \"\" + t, e = \"\" + e;\n      var n = this._nodes.get(t);\n      if (!n) throw new F('Graph.areDirectedNeighbors: could not find the \"'.concat(t, '\" node in the graph.'));\n      return \"undirected\" !== this.type && (e in n.in || e in n.out);\n    }, i.areOutNeighbors = function (t, e) {\n      t = \"\" + t, e = \"\" + e;\n      var n = this._nodes.get(t);\n      if (!n) throw new F('Graph.areOutNeighbors: could not find the \"'.concat(t, '\" node in the graph.'));\n      return \"undirected\" !== this.type && e in n.out;\n    }, i.areInNeighbors = function (t, e) {\n      t = \"\" + t, e = \"\" + e;\n      var n = this._nodes.get(t);\n      if (!n) throw new F('Graph.areInNeighbors: could not find the \"'.concat(t, '\" node in the graph.'));\n      return \"undirected\" !== this.type && e in n.in;\n    }, i.areUndirectedNeighbors = function (t, e) {\n      t = \"\" + t, e = \"\" + e;\n      var n = this._nodes.get(t);\n      if (!n) throw new F('Graph.areUndirectedNeighbors: could not find the \"'.concat(t, '\" node in the graph.'));\n      return \"directed\" !== this.type && e in n.undirected;\n    }, i.areNeighbors = function (t, e) {\n      t = \"\" + t, e = \"\" + e;\n      var n = this._nodes.get(t);\n      if (!n) throw new F('Graph.areNeighbors: could not find the \"'.concat(t, '\" node in the graph.'));\n      return \"undirected\" !== this.type && (e in n.in || e in n.out) || \"directed\" !== this.type && e in n.undirected;\n    }, i.areInboundNeighbors = function (t, e) {\n      t = \"\" + t, e = \"\" + e;\n      var n = this._nodes.get(t);\n      if (!n) throw new F('Graph.areInboundNeighbors: could not find the \"'.concat(t, '\" node in the graph.'));\n      return \"undirected\" !== this.type && e in n.in || \"directed\" !== this.type && e in n.undirected;\n    }, i.areOutboundNeighbors = function (t, e) {\n      t = \"\" + t, e = \"\" + e;\n      var n = this._nodes.get(t);\n      if (!n) throw new F('Graph.areOutboundNeighbors: could not find the \"'.concat(t, '\" node in the graph.'));\n      return \"undirected\" !== this.type && e in n.out || \"directed\" !== this.type && e in n.undirected;\n    }, i.inDegree = function (t) {\n      t = \"\" + t;\n      var e = this._nodes.get(t);\n      if (!e) throw new F('Graph.inDegree: could not find the \"'.concat(t, '\" node in the graph.'));\n      return \"undirected\" === this.type ? 0 : e.inDegree;\n    }, i.outDegree = function (t) {\n      t = \"\" + t;\n      var e = this._nodes.get(t);\n      if (!e) throw new F('Graph.outDegree: could not find the \"'.concat(t, '\" node in the graph.'));\n      return \"undirected\" === this.type ? 0 : e.outDegree;\n    }, i.directedDegree = function (t) {\n      t = \"\" + t;\n      var e = this._nodes.get(t);\n      if (!e) throw new F('Graph.directedDegree: could not find the \"'.concat(t, '\" node in the graph.'));\n      return \"undirected\" === this.type ? 0 : e.inDegree + e.outDegree;\n    }, i.undirectedDegree = function (t) {\n      t = \"\" + t;\n      var e = this._nodes.get(t);\n      if (!e) throw new F('Graph.undirectedDegree: could not find the \"'.concat(t, '\" node in the graph.'));\n      return \"directed\" === this.type ? 0 : e.undirectedDegree;\n    }, i.inboundDegree = function (t) {\n      t = \"\" + t;\n      var e = this._nodes.get(t);\n      if (!e) throw new F('Graph.inboundDegree: could not find the \"'.concat(t, '\" node in the graph.'));\n      var n = 0;\n      return \"directed\" !== this.type && (n += e.undirectedDegree), \"undirected\" !== this.type && (n += e.inDegree), n;\n    }, i.outboundDegree = function (t) {\n      t = \"\" + t;\n      var e = this._nodes.get(t);\n      if (!e) throw new F('Graph.outboundDegree: could not find the \"'.concat(t, '\" node in the graph.'));\n      var n = 0;\n      return \"directed\" !== this.type && (n += e.undirectedDegree), \"undirected\" !== this.type && (n += e.outDegree), n;\n    }, i.degree = function (t) {\n      t = \"\" + t;\n      var e = this._nodes.get(t);\n      if (!e) throw new F('Graph.degree: could not find the \"'.concat(t, '\" node in the graph.'));\n      var n = 0;\n      return \"directed\" !== this.type && (n += e.undirectedDegree), \"undirected\" !== this.type && (n += e.inDegree + e.outDegree), n;\n    }, i.inDegreeWithoutSelfLoops = function (t) {\n      t = \"\" + t;\n      var e = this._nodes.get(t);\n      if (!e) throw new F('Graph.inDegreeWithoutSelfLoops: could not find the \"'.concat(t, '\" node in the graph.'));\n      return \"undirected\" === this.type ? 0 : e.inDegree - e.directedLoops;\n    }, i.outDegreeWithoutSelfLoops = function (t) {\n      t = \"\" + t;\n      var e = this._nodes.get(t);\n      if (!e) throw new F('Graph.outDegreeWithoutSelfLoops: could not find the \"'.concat(t, '\" node in the graph.'));\n      return \"undirected\" === this.type ? 0 : e.outDegree - e.directedLoops;\n    }, i.directedDegreeWithoutSelfLoops = function (t) {\n      t = \"\" + t;\n      var e = this._nodes.get(t);\n      if (!e) throw new F('Graph.directedDegreeWithoutSelfLoops: could not find the \"'.concat(t, '\" node in the graph.'));\n      return \"undirected\" === this.type ? 0 : e.inDegree + e.outDegree - 2 * e.directedLoops;\n    }, i.undirectedDegreeWithoutSelfLoops = function (t) {\n      t = \"\" + t;\n      var e = this._nodes.get(t);\n      if (!e) throw new F('Graph.undirectedDegreeWithoutSelfLoops: could not find the \"'.concat(t, '\" node in the graph.'));\n      return \"directed\" === this.type ? 0 : e.undirectedDegree - 2 * e.undirectedLoops;\n    }, i.inboundDegreeWithoutSelfLoops = function (t) {\n      t = \"\" + t;\n      var e = this._nodes.get(t);\n      if (!e) throw new F('Graph.inboundDegreeWithoutSelfLoops: could not find the \"'.concat(t, '\" node in the graph.'));\n      var n = 0,\n        r = 0;\n      return \"directed\" !== this.type && (n += e.undirectedDegree, r += 2 * e.undirectedLoops), \"undirected\" !== this.type && (n += e.inDegree, r += e.directedLoops), n - r;\n    }, i.outboundDegreeWithoutSelfLoops = function (t) {\n      t = \"\" + t;\n      var e = this._nodes.get(t);\n      if (!e) throw new F('Graph.outboundDegreeWithoutSelfLoops: could not find the \"'.concat(t, '\" node in the graph.'));\n      var n = 0,\n        r = 0;\n      return \"directed\" !== this.type && (n += e.undirectedDegree, r += 2 * e.undirectedLoops), \"undirected\" !== this.type && (n += e.outDegree, r += e.directedLoops), n - r;\n    }, i.degreeWithoutSelfLoops = function (t) {\n      t = \"\" + t;\n      var e = this._nodes.get(t);\n      if (!e) throw new F('Graph.degreeWithoutSelfLoops: could not find the \"'.concat(t, '\" node in the graph.'));\n      var n = 0,\n        r = 0;\n      return \"directed\" !== this.type && (n += e.undirectedDegree, r += 2 * e.undirectedLoops), \"undirected\" !== this.type && (n += e.inDegree + e.outDegree, r += 2 * e.directedLoops), n - r;\n    }, i.source = function (t) {\n      t = \"\" + t;\n      var e = this._edges.get(t);\n      if (!e) throw new F('Graph.source: could not find the \"'.concat(t, '\" edge in the graph.'));\n      return e.source.key;\n    }, i.target = function (t) {\n      t = \"\" + t;\n      var e = this._edges.get(t);\n      if (!e) throw new F('Graph.target: could not find the \"'.concat(t, '\" edge in the graph.'));\n      return e.target.key;\n    }, i.extremities = function (t) {\n      t = \"\" + t;\n      var e = this._edges.get(t);\n      if (!e) throw new F('Graph.extremities: could not find the \"'.concat(t, '\" edge in the graph.'));\n      return [e.source.key, e.target.key];\n    }, i.opposite = function (t, e) {\n      t = \"\" + t, e = \"\" + e;\n      var n = this._edges.get(e);\n      if (!n) throw new F('Graph.opposite: could not find the \"'.concat(e, '\" edge in the graph.'));\n      var r = n.source.key,\n        i = n.target.key;\n      if (t === r) return i;\n      if (t === i) return r;\n      throw new F('Graph.opposite: the \"'.concat(t, '\" node is not attached to the \"').concat(e, '\" edge (').concat(r, \", \").concat(i, \").\"));\n    }, i.hasExtremity = function (t, e) {\n      t = \"\" + t, e = \"\" + e;\n      var n = this._edges.get(t);\n      if (!n) throw new F('Graph.hasExtremity: could not find the \"'.concat(t, '\" edge in the graph.'));\n      return n.source.key === e || n.target.key === e;\n    }, i.isUndirected = function (t) {\n      t = \"\" + t;\n      var e = this._edges.get(t);\n      if (!e) throw new F('Graph.isUndirected: could not find the \"'.concat(t, '\" edge in the graph.'));\n      return e.undirected;\n    }, i.isDirected = function (t) {\n      t = \"\" + t;\n      var e = this._edges.get(t);\n      if (!e) throw new F('Graph.isDirected: could not find the \"'.concat(t, '\" edge in the graph.'));\n      return !e.undirected;\n    }, i.isSelfLoop = function (t) {\n      t = \"\" + t;\n      var e = this._edges.get(t);\n      if (!e) throw new F('Graph.isSelfLoop: could not find the \"'.concat(t, '\" edge in the graph.'));\n      return e.source === e.target;\n    }, i.addNode = function (t, e) {\n      var n = function (t, e, n) {\n        if (n && !s(n)) throw new B('Graph.addNode: invalid attributes. Expecting an object but got \"'.concat(n, '\"'));\n        if (e = \"\" + e, n = n || {}, t._nodes.has(e)) throw new I('Graph.addNode: the \"'.concat(e, '\" node already exist in the graph.'));\n        var r = new t.NodeDataClass(e, n);\n        return t._nodes.set(e, r), t.emit(\"nodeAdded\", {\n          key: e,\n          attributes: n\n        }), r;\n      }(this, t, e);\n      return n.key;\n    }, i.mergeNode = function (t, e) {\n      if (e && !s(e)) throw new B('Graph.mergeNode: invalid attributes. Expecting an object but got \"'.concat(e, '\"'));\n      t = \"\" + t, e = e || {};\n      var n = this._nodes.get(t);\n      return n ? (e && (u(n.attributes, e), this.emit(\"nodeAttributesUpdated\", {\n        type: \"merge\",\n        key: t,\n        attributes: n.attributes,\n        data: e\n      })), [t, !1]) : (n = new this.NodeDataClass(t, e), this._nodes.set(t, n), this.emit(\"nodeAdded\", {\n        key: t,\n        attributes: e\n      }), [t, !0]);\n    }, i.updateNode = function (t, e) {\n      if (e && \"function\" != typeof e) throw new B('Graph.updateNode: invalid updater function. Expecting a function but got \"'.concat(e, '\"'));\n      t = \"\" + t;\n      var n = this._nodes.get(t);\n      if (n) {\n        if (e) {\n          var r = n.attributes;\n          n.attributes = e(r), this.emit(\"nodeAttributesUpdated\", {\n            type: \"replace\",\n            key: t,\n            attributes: n.attributes\n          });\n        }\n        return [t, !1];\n      }\n      var i = e ? e({}) : {};\n      return n = new this.NodeDataClass(t, i), this._nodes.set(t, n), this.emit(\"nodeAdded\", {\n        key: t,\n        attributes: i\n      }), [t, !0];\n    }, i.dropNode = function (t) {\n      t = \"\" + t;\n      var e,\n        n = this._nodes.get(t);\n      if (!n) throw new F('Graph.dropNode: could not find the \"'.concat(t, '\" node in the graph.'));\n      if (\"undirected\" !== this.type) {\n        for (var r in n.out) {\n          e = n.out[r];\n          do {\n            Mt(this, e), e = e.next;\n          } while (e);\n        }\n        for (var i in n.in) {\n          e = n.in[i];\n          do {\n            Mt(this, e), e = e.next;\n          } while (e);\n        }\n      }\n      if (\"directed\" !== this.type) for (var o in n.undirected) {\n        e = n.undirected[o];\n        do {\n          Mt(this, e), e = e.next;\n        } while (e);\n      }\n      this._nodes.delete(t), this.emit(\"nodeDropped\", {\n        key: t,\n        attributes: n.attributes\n      });\n    }, i.dropEdge = function (t) {\n      var e;\n      if (arguments.length > 1) {\n        var n = \"\" + arguments[0],\n          r = \"\" + arguments[1];\n        if (!(e = d(this, n, r, this.type))) throw new F('Graph.dropEdge: could not find the \"'.concat(n, '\" -> \"').concat(r, '\" edge in the graph.'));\n      } else if (t = \"\" + t, !(e = this._edges.get(t))) throw new F('Graph.dropEdge: could not find the \"'.concat(t, '\" edge in the graph.'));\n      return Mt(this, e), this;\n    }, i.dropDirectedEdge = function (t, e) {\n      if (arguments.length < 2) throw new I(\"Graph.dropDirectedEdge: it does not make sense to try and drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.\");\n      if (this.multi) throw new I(\"Graph.dropDirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.\");\n      var n = d(this, t = \"\" + t, e = \"\" + e, \"directed\");\n      if (!n) throw new F('Graph.dropDirectedEdge: could not find a \"'.concat(t, '\" -> \"').concat(e, '\" edge in the graph.'));\n      return Mt(this, n), this;\n    }, i.dropUndirectedEdge = function (t, e) {\n      if (arguments.length < 2) throw new I(\"Graph.dropUndirectedEdge: it does not make sense to drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.\");\n      if (this.multi) throw new I(\"Graph.dropUndirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.\");\n      var n = d(this, t, e, \"undirected\");\n      if (!n) throw new F('Graph.dropUndirectedEdge: could not find a \"'.concat(t, '\" -> \"').concat(e, '\" edge in the graph.'));\n      return Mt(this, n), this;\n    }, i.clear = function () {\n      this._edges.clear(), this._nodes.clear(), this._resetInstanceCounters(), this.emit(\"cleared\");\n    }, i.clearEdges = function () {\n      for (var t, e = this._nodes.values(); !0 !== (t = e.next()).done;) t.value.clear();\n      this._edges.clear(), this._resetInstanceCounters(), this.emit(\"edgesCleared\");\n    }, i.getAttribute = function (t) {\n      return this._attributes[t];\n    }, i.getAttributes = function () {\n      return this._attributes;\n    }, i.hasAttribute = function (t) {\n      return this._attributes.hasOwnProperty(t);\n    }, i.setAttribute = function (t, e) {\n      return this._attributes[t] = e, this.emit(\"attributesUpdated\", {\n        type: \"set\",\n        attributes: this._attributes,\n        name: t\n      }), this;\n    }, i.updateAttribute = function (t, e) {\n      if (\"function\" != typeof e) throw new B(\"Graph.updateAttribute: updater should be a function.\");\n      var n = this._attributes[t];\n      return this._attributes[t] = e(n), this.emit(\"attributesUpdated\", {\n        type: \"set\",\n        attributes: this._attributes,\n        name: t\n      }), this;\n    }, i.removeAttribute = function (t) {\n      return delete this._attributes[t], this.emit(\"attributesUpdated\", {\n        type: \"remove\",\n        attributes: this._attributes,\n        name: t\n      }), this;\n    }, i.replaceAttributes = function (t) {\n      if (!s(t)) throw new B(\"Graph.replaceAttributes: provided attributes are not a plain object.\");\n      return this._attributes = t, this.emit(\"attributesUpdated\", {\n        type: \"replace\",\n        attributes: this._attributes\n      }), this;\n    }, i.mergeAttributes = function (t) {\n      if (!s(t)) throw new B(\"Graph.mergeAttributes: provided attributes are not a plain object.\");\n      return u(this._attributes, t), this.emit(\"attributesUpdated\", {\n        type: \"merge\",\n        attributes: this._attributes,\n        data: t\n      }), this;\n    }, i.updateAttributes = function (t) {\n      if (\"function\" != typeof t) throw new B(\"Graph.updateAttributes: provided updater is not a function.\");\n      return this._attributes = t(this._attributes), this.emit(\"attributesUpdated\", {\n        type: \"update\",\n        attributes: this._attributes\n      }), this;\n    }, i.updateEachNodeAttributes = function (t, e) {\n      if (\"function\" != typeof t) throw new B(\"Graph.updateEachNodeAttributes: expecting an updater function.\");\n      if (e && !l(e)) throw new B(\"Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}\");\n      for (var n, r, i = this._nodes.values(); !0 !== (n = i.next()).done;) (r = n.value).attributes = t(r.key, r.attributes);\n      this.emit(\"eachNodeAttributesUpdated\", {\n        hints: e || null\n      });\n    }, i.updateEachEdgeAttributes = function (t, e) {\n      if (\"function\" != typeof t) throw new B(\"Graph.updateEachEdgeAttributes: expecting an updater function.\");\n      if (e && !l(e)) throw new B(\"Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}\");\n      for (var n, r, i, o, a = this._edges.values(); !0 !== (n = a.next()).done;) i = (r = n.value).source, o = r.target, r.attributes = t(r.key, r.attributes, i.key, o.key, i.attributes, o.attributes, r.undirected);\n      this.emit(\"eachEdgeAttributesUpdated\", {\n        hints: e || null\n      });\n    }, i.forEachAdjacencyEntry = function (t) {\n      if (\"function\" != typeof t) throw new B(\"Graph.forEachAdjacencyEntry: expecting a callback.\");\n      xt(!1, !1, !1, this, t);\n    }, i.forEachAdjacencyEntryWithOrphans = function (t) {\n      if (\"function\" != typeof t) throw new B(\"Graph.forEachAdjacencyEntryWithOrphans: expecting a callback.\");\n      xt(!1, !1, !0, this, t);\n    }, i.forEachAssymetricAdjacencyEntry = function (t) {\n      if (\"function\" != typeof t) throw new B(\"Graph.forEachAssymetricAdjacencyEntry: expecting a callback.\");\n      xt(!1, !0, !1, this, t);\n    }, i.forEachAssymetricAdjacencyEntryWithOrphans = function (t) {\n      if (\"function\" != typeof t) throw new B(\"Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback.\");\n      xt(!1, !0, !0, this, t);\n    }, i.nodes = function () {\n      return \"function\" == typeof Array.from ? Array.from(this._nodes.keys()) : K(this._nodes.keys(), this._nodes.size);\n    }, i.forEachNode = function (t) {\n      if (\"function\" != typeof t) throw new B(\"Graph.forEachNode: expecting a callback.\");\n      for (var e, n, r = this._nodes.values(); !0 !== (e = r.next()).done;) t((n = e.value).key, n.attributes);\n    }, i.findNode = function (t) {\n      if (\"function\" != typeof t) throw new B(\"Graph.findNode: expecting a callback.\");\n      for (var e, n, r = this._nodes.values(); !0 !== (e = r.next()).done;) if (t((n = e.value).key, n.attributes)) return n.key;\n    }, i.mapNodes = function (t) {\n      if (\"function\" != typeof t) throw new B(\"Graph.mapNode: expecting a callback.\");\n      for (var e, n, r = this._nodes.values(), i = new Array(this.order), o = 0; !0 !== (e = r.next()).done;) n = e.value, i[o++] = t(n.key, n.attributes);\n      return i;\n    }, i.someNode = function (t) {\n      if (\"function\" != typeof t) throw new B(\"Graph.someNode: expecting a callback.\");\n      for (var e, n, r = this._nodes.values(); !0 !== (e = r.next()).done;) if (t((n = e.value).key, n.attributes)) return !0;\n      return !1;\n    }, i.everyNode = function (t) {\n      if (\"function\" != typeof t) throw new B(\"Graph.everyNode: expecting a callback.\");\n      for (var e, n, r = this._nodes.values(); !0 !== (e = r.next()).done;) if (!t((n = e.value).key, n.attributes)) return !1;\n      return !0;\n    }, i.filterNodes = function (t) {\n      if (\"function\" != typeof t) throw new B(\"Graph.filterNodes: expecting a callback.\");\n      for (var e, n, r = this._nodes.values(), i = []; !0 !== (e = r.next()).done;) t((n = e.value).key, n.attributes) && i.push(n.key);\n      return i;\n    }, i.reduceNodes = function (t, e) {\n      if (\"function\" != typeof t) throw new B(\"Graph.reduceNodes: expecting a callback.\");\n      if (arguments.length < 2) throw new B(\"Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.\");\n      for (var n, r, i = e, o = this._nodes.values(); !0 !== (n = o.next()).done;) i = t(i, (r = n.value).key, r.attributes);\n      return i;\n    }, i.nodeEntries = function () {\n      var t = this._nodes.values();\n      return new O(function () {\n        var e = t.next();\n        if (e.done) return e;\n        var n = e.value;\n        return {\n          value: {\n            node: n.key,\n            attributes: n.attributes\n          },\n          done: !1\n        };\n      });\n    }, i.export = function () {\n      var t = this,\n        e = new Array(this._nodes.size),\n        n = 0;\n      this._nodes.forEach(function (t, r) {\n        e[n++] = function (t, e) {\n          var n = {\n            key: t\n          };\n          return h(e.attributes) || (n.attributes = u({}, e.attributes)), n;\n        }(r, t);\n      });\n      var r = new Array(this._edges.size);\n      return n = 0, this._edges.forEach(function (e, i) {\n        r[n++] = function (t, e, n) {\n          var r = {\n            key: e,\n            source: n.source.key,\n            target: n.target.key\n          };\n          return h(n.attributes) || (r.attributes = u({}, n.attributes)), \"mixed\" === t && n.undirected && (r.undirected = !0), r;\n        }(t.type, i, e);\n      }), {\n        options: {\n          type: this.type,\n          multi: this.multi,\n          allowSelfLoops: this.allowSelfLoops\n        },\n        attributes: this.getAttributes(),\n        nodes: e,\n        edges: r\n      };\n    }, i.import = function (t) {\n      var e,\n        n,\n        i,\n        o,\n        a,\n        c = this,\n        u = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];\n      if (t instanceof r) return t.forEachNode(function (t, e) {\n        u ? c.mergeNode(t, e) : c.addNode(t, e);\n      }), t.forEachEdge(function (t, e, n, r, i, o, a) {\n        u ? a ? c.mergeUndirectedEdgeWithKey(t, n, r, e) : c.mergeDirectedEdgeWithKey(t, n, r, e) : a ? c.addUndirectedEdgeWithKey(t, n, r, e) : c.addDirectedEdgeWithKey(t, n, r, e);\n      }), this;\n      if (!s(t)) throw new B(\"Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.\");\n      if (t.attributes) {\n        if (!s(t.attributes)) throw new B(\"Graph.import: invalid attributes. Expecting a plain object.\");\n        u ? this.mergeAttributes(t.attributes) : this.replaceAttributes(t.attributes);\n      }\n      if (t.nodes) {\n        if (i = t.nodes, !Array.isArray(i)) throw new B(\"Graph.import: invalid nodes. Expecting an array.\");\n        for (e = 0, n = i.length; e < n; e++) {\n          Et(o = i[e]);\n          var d = o,\n            h = d.key,\n            p = d.attributes;\n          u ? this.mergeNode(h, p) : this.addNode(h, p);\n        }\n      }\n      if (t.edges) {\n        var f = !1;\n        if (\"undirected\" === this.type && (f = !0), i = t.edges, !Array.isArray(i)) throw new B(\"Graph.import: invalid edges. Expecting an array.\");\n        for (e = 0, n = i.length; e < n; e++) {\n          At(a = i[e]);\n          var l = a,\n            g = l.source,\n            y = l.target,\n            w = l.attributes,\n            v = l.undirected,\n            b = void 0 === v ? f : v;\n          \"key\" in a ? (u ? b ? this.mergeUndirectedEdgeWithKey : this.mergeDirectedEdgeWithKey : b ? this.addUndirectedEdgeWithKey : this.addDirectedEdgeWithKey).call(this, a.key, g, y, w) : (u ? b ? this.mergeUndirectedEdge : this.mergeDirectedEdge : b ? this.addUndirectedEdge : this.addDirectedEdge).call(this, g, y, w);\n        }\n      }\n      return this;\n    }, i.nullCopy = function (t) {\n      var e = new r(u({}, this._options, t));\n      return e.replaceAttributes(u({}, this.getAttributes())), e;\n    }, i.emptyCopy = function (t) {\n      var e = this.nullCopy(t);\n      return this._nodes.forEach(function (t, n) {\n        var r = u({}, t.attributes);\n        t = new e.NodeDataClass(n, r), e._nodes.set(n, t);\n      }), e;\n    }, i.copy = function (t) {\n      if (\"string\" == typeof (t = t || {}).type && t.type !== this.type && \"mixed\" !== t.type) throw new I('Graph.copy: cannot create an incompatible copy from \"'.concat(this.type, '\" type to \"').concat(t.type, '\" because this would mean losing information about the current graph.'));\n      if (\"boolean\" == typeof t.multi && t.multi !== this.multi && !0 !== t.multi) throw new I(\"Graph.copy: cannot create an incompatible copy by downgrading a multi graph to a simple one because this would mean losing information about the current graph.\");\n      if (\"boolean\" == typeof t.allowSelfLoops && t.allowSelfLoops !== this.allowSelfLoops && !0 !== t.allowSelfLoops) throw new I(\"Graph.copy: cannot create an incompatible copy from a graph allowing self loops to one that does not because this would mean losing information about the current graph.\");\n      for (var e, n, r = this.emptyCopy(t), i = this._edges.values(); !0 !== (e = i.next()).done;) jt(r, \"copy\", !1, (n = e.value).undirected, n.key, n.source.key, n.target.key, u({}, n.attributes));\n      return r;\n    }, i.toJSON = function () {\n      return this.export();\n    }, i.toString = function () {\n      return \"[object Graph]\";\n    }, i.inspect = function () {\n      var e = this,\n        n = {};\n      this._nodes.forEach(function (t, e) {\n        n[e] = t.attributes;\n      });\n      var r = {},\n        i = {};\n      this._edges.forEach(function (t, n) {\n        var o,\n          a = t.undirected ? \"--\" : \"->\",\n          c = \"\",\n          u = t.source.key,\n          d = t.target.key;\n        t.undirected && u > d && (o = u, u = d, d = o);\n        var s = \"(\".concat(u, \")\").concat(a, \"(\").concat(d, \")\");\n        n.startsWith(\"geid_\") ? e.multi && (void 0 === i[s] ? i[s] = 0 : i[s]++, c += \"\".concat(i[s], \". \")) : c += \"[\".concat(n, \"]: \"), r[c += s] = t.attributes;\n      });\n      var o = {};\n      for (var a in this) this.hasOwnProperty(a) && !Ut.has(a) && \"function\" != typeof this[a] && \"symbol\" !== t(a) && (o[a] = this[a]);\n      return o.attributes = this._attributes, o.nodes = n, o.edges = r, p(o, \"constructor\", this.constructor), o;\n    }, r;\n  }(y.exports.EventEmitter);\n  \"undefined\" != typeof Symbol && (zt.prototype[Symbol.for(\"nodejs.util.inspect.custom\")] = zt.prototype.inspect), [{\n    name: function (t) {\n      return \"\".concat(t, \"Edge\");\n    },\n    generateKey: !0\n  }, {\n    name: function (t) {\n      return \"\".concat(t, \"DirectedEdge\");\n    },\n    generateKey: !0,\n    type: \"directed\"\n  }, {\n    name: function (t) {\n      return \"\".concat(t, \"UndirectedEdge\");\n    },\n    generateKey: !0,\n    type: \"undirected\"\n  }, {\n    name: function (t) {\n      return \"\".concat(t, \"EdgeWithKey\");\n    }\n  }, {\n    name: function (t) {\n      return \"\".concat(t, \"DirectedEdgeWithKey\");\n    },\n    type: \"directed\"\n  }, {\n    name: function (t) {\n      return \"\".concat(t, \"UndirectedEdgeWithKey\");\n    },\n    type: \"undirected\"\n  }].forEach(function (t) {\n    [\"add\", \"merge\", \"update\"].forEach(function (e) {\n      var n = t.name(e),\n        r = \"add\" === e ? jt : Ct;\n      t.generateKey ? zt.prototype[n] = function (i, o, a) {\n        return r(this, n, !0, \"undirected\" === (t.type || this.type), null, i, o, a, \"update\" === e);\n      } : zt.prototype[n] = function (i, o, a, c) {\n        return r(this, n, !1, \"undirected\" === (t.type || this.type), i, o, a, c, \"update\" === e);\n      };\n    });\n  }), function (t) {\n    Q.forEach(function (e) {\n      var n = e.name,\n        r = e.attacher;\n      r(t, n(\"Node\"), 0), r(t, n(\"Source\"), 1), r(t, n(\"Target\"), 2), r(t, n(\"Opposite\"), 3);\n    });\n  }(zt), function (t) {\n    X.forEach(function (e) {\n      var n = e.name,\n        r = e.attacher;\n      r(t, n(\"Edge\"), \"mixed\"), r(t, n(\"DirectedEdge\"), \"directed\"), r(t, n(\"UndirectedEdge\"), \"undirected\");\n    });\n  }(zt), function (t) {\n    et.forEach(function (e) {\n      !function (t, e) {\n        var n = e.name,\n          r = e.type,\n          i = e.direction;\n        t.prototype[n] = function (t, e) {\n          if (\"mixed\" !== r && \"mixed\" !== this.type && r !== this.type) return [];\n          if (!arguments.length) return ut(this, r);\n          if (1 === arguments.length) {\n            t = \"\" + t;\n            var o = this._nodes.get(t);\n            if (void 0 === o) throw new F(\"Graph.\".concat(n, ': could not find the \"').concat(t, '\" node in the graph.'));\n            return pt(this.multi, \"mixed\" === r ? this.type : r, i, o);\n          }\n          if (2 === arguments.length) {\n            t = \"\" + t, e = \"\" + e;\n            var a = this._nodes.get(t);\n            if (!a) throw new F(\"Graph.\".concat(n, ':  could not find the \"').concat(t, '\" source node in the graph.'));\n            if (!this._nodes.has(e)) throw new F(\"Graph.\".concat(n, ':  could not find the \"').concat(e, '\" target node in the graph.'));\n            return gt(r, this.multi, i, a, e);\n          }\n          throw new B(\"Graph.\".concat(n, \": too many arguments (expecting 0, 1 or 2 and got \").concat(arguments.length, \").\"));\n        };\n      }(t, e), function (t, e) {\n        var n = e.name,\n          r = e.type,\n          i = e.direction,\n          o = \"forEach\" + n[0].toUpperCase() + n.slice(1, -1);\n        t.prototype[o] = function (t, e, n) {\n          if (\"mixed\" === r || \"mixed\" === this.type || r === this.type) {\n            if (1 === arguments.length) return dt(!1, this, r, n = t);\n            if (2 === arguments.length) {\n              t = \"\" + t, n = e;\n              var a = this._nodes.get(t);\n              if (void 0 === a) throw new F(\"Graph.\".concat(o, ': could not find the \"').concat(t, '\" node in the graph.'));\n              return ht(!1, this.multi, \"mixed\" === r ? this.type : r, i, a, n);\n            }\n            if (3 === arguments.length) {\n              t = \"\" + t, e = \"\" + e;\n              var c = this._nodes.get(t);\n              if (!c) throw new F(\"Graph.\".concat(o, ':  could not find the \"').concat(t, '\" source node in the graph.'));\n              if (!this._nodes.has(e)) throw new F(\"Graph.\".concat(o, ':  could not find the \"').concat(e, '\" target node in the graph.'));\n              return lt(!1, r, this.multi, i, c, e, n);\n            }\n            throw new B(\"Graph.\".concat(o, \": too many arguments (expecting 1, 2 or 3 and got \").concat(arguments.length, \").\"));\n          }\n        };\n        var a = \"map\" + n[0].toUpperCase() + n.slice(1);\n        t.prototype[a] = function () {\n          var t,\n            e = Array.prototype.slice.call(arguments),\n            n = e.pop();\n          if (0 === e.length) {\n            var i = 0;\n            \"directed\" !== r && (i += this.undirectedSize), \"undirected\" !== r && (i += this.directedSize), t = new Array(i);\n            var a = 0;\n            e.push(function (e, r, i, o, c, u, d) {\n              t[a++] = n(e, r, i, o, c, u, d);\n            });\n          } else t = [], e.push(function (e, r, i, o, a, c, u) {\n            t.push(n(e, r, i, o, a, c, u));\n          });\n          return this[o].apply(this, e), t;\n        };\n        var c = \"filter\" + n[0].toUpperCase() + n.slice(1);\n        t.prototype[c] = function () {\n          var t = Array.prototype.slice.call(arguments),\n            e = t.pop(),\n            n = [];\n          return t.push(function (t, r, i, o, a, c, u) {\n            e(t, r, i, o, a, c, u) && n.push(t);\n          }), this[o].apply(this, t), n;\n        };\n        var u = \"reduce\" + n[0].toUpperCase() + n.slice(1);\n        t.prototype[u] = function () {\n          var t,\n            e,\n            n = Array.prototype.slice.call(arguments);\n          if (n.length < 2 || n.length > 4) throw new B(\"Graph.\".concat(u, \": invalid number of arguments (expecting 2, 3 or 4 and got \").concat(n.length, \").\"));\n          if (\"function\" == typeof n[n.length - 1] && \"function\" != typeof n[n.length - 2]) throw new B(\"Graph.\".concat(u, \": missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.\"));\n          2 === n.length ? (t = n[0], e = n[1], n = []) : 3 === n.length ? (t = n[1], e = n[2], n = [n[0]]) : 4 === n.length && (t = n[2], e = n[3], n = [n[0], n[1]]);\n          var r = e;\n          return n.push(function (e, n, i, o, a, c, u) {\n            r = t(r, e, n, i, o, a, c, u);\n          }), this[o].apply(this, n), r;\n        };\n      }(t, e), function (t, e) {\n        var n = e.name,\n          r = e.type,\n          i = e.direction,\n          o = \"find\" + n[0].toUpperCase() + n.slice(1, -1);\n        t.prototype[o] = function (t, e, n) {\n          if (\"mixed\" !== r && \"mixed\" !== this.type && r !== this.type) return !1;\n          if (1 === arguments.length) return dt(!0, this, r, n = t);\n          if (2 === arguments.length) {\n            t = \"\" + t, n = e;\n            var a = this._nodes.get(t);\n            if (void 0 === a) throw new F(\"Graph.\".concat(o, ': could not find the \"').concat(t, '\" node in the graph.'));\n            return ht(!0, this.multi, \"mixed\" === r ? this.type : r, i, a, n);\n          }\n          if (3 === arguments.length) {\n            t = \"\" + t, e = \"\" + e;\n            var c = this._nodes.get(t);\n            if (!c) throw new F(\"Graph.\".concat(o, ':  could not find the \"').concat(t, '\" source node in the graph.'));\n            if (!this._nodes.has(e)) throw new F(\"Graph.\".concat(o, ':  could not find the \"').concat(e, '\" target node in the graph.'));\n            return lt(!0, r, this.multi, i, c, e, n);\n          }\n          throw new B(\"Graph.\".concat(o, \": too many arguments (expecting 1, 2 or 3 and got \").concat(arguments.length, \").\"));\n        };\n        var a = \"some\" + n[0].toUpperCase() + n.slice(1, -1);\n        t.prototype[a] = function () {\n          var t = Array.prototype.slice.call(arguments),\n            e = t.pop();\n          return t.push(function (t, n, r, i, o, a, c) {\n            return e(t, n, r, i, o, a, c);\n          }), !!this[o].apply(this, t);\n        };\n        var c = \"every\" + n[0].toUpperCase() + n.slice(1, -1);\n        t.prototype[c] = function () {\n          var t = Array.prototype.slice.call(arguments),\n            e = t.pop();\n          return t.push(function (t, n, r, i, o, a, c) {\n            return !e(t, n, r, i, o, a, c);\n          }), !this[o].apply(this, t);\n        };\n      }(t, e), function (t, e) {\n        var n = e.name,\n          r = e.type,\n          i = e.direction,\n          o = n.slice(0, -1) + \"Entries\";\n        t.prototype[o] = function (t, e) {\n          if (\"mixed\" !== r && \"mixed\" !== this.type && r !== this.type) return O.empty();\n          if (!arguments.length) return st(this, r);\n          if (1 === arguments.length) {\n            t = \"\" + t;\n            var n = this._nodes.get(t);\n            if (!n) throw new F(\"Graph.\".concat(o, ': could not find the \"').concat(t, '\" node in the graph.'));\n            return ft(r, i, n);\n          }\n          if (2 === arguments.length) {\n            t = \"\" + t, e = \"\" + e;\n            var a = this._nodes.get(t);\n            if (!a) throw new F(\"Graph.\".concat(o, ':  could not find the \"').concat(t, '\" source node in the graph.'));\n            if (!this._nodes.has(e)) throw new F(\"Graph.\".concat(o, ':  could not find the \"').concat(e, '\" target node in the graph.'));\n            return yt(r, i, a, e);\n          }\n          throw new B(\"Graph.\".concat(o, \": too many arguments (expecting 0, 1 or 2 and got \").concat(arguments.length, \").\"));\n        };\n      }(t, e);\n    });\n  }(zt), function (t) {\n    wt.forEach(function (e) {\n      _t(t, e), function (t, e) {\n        var n = e.name,\n          r = e.type,\n          i = e.direction,\n          o = \"forEach\" + n[0].toUpperCase() + n.slice(1, -1);\n        t.prototype[o] = function (t, e) {\n          if (\"mixed\" === r || \"mixed\" === this.type || r === this.type) {\n            t = \"\" + t;\n            var n = this._nodes.get(t);\n            if (void 0 === n) throw new F(\"Graph.\".concat(o, ': could not find the \"').concat(t, '\" node in the graph.'));\n            mt(!1, \"mixed\" === r ? this.type : r, i, n, e);\n          }\n        };\n        var a = \"map\" + n[0].toUpperCase() + n.slice(1);\n        t.prototype[a] = function (t, e) {\n          var n = [];\n          return this[o](t, function (t, r) {\n            n.push(e(t, r));\n          }), n;\n        };\n        var c = \"filter\" + n[0].toUpperCase() + n.slice(1);\n        t.prototype[c] = function (t, e) {\n          var n = [];\n          return this[o](t, function (t, r) {\n            e(t, r) && n.push(t);\n          }), n;\n        };\n        var u = \"reduce\" + n[0].toUpperCase() + n.slice(1);\n        t.prototype[u] = function (t, e, n) {\n          if (arguments.length < 3) throw new B(\"Graph.\".concat(u, \": missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.\"));\n          var r = n;\n          return this[o](t, function (t, n) {\n            r = e(r, t, n);\n          }), r;\n        };\n      }(t, e), function (t, e) {\n        var n = e.name,\n          r = e.type,\n          i = e.direction,\n          o = n[0].toUpperCase() + n.slice(1, -1),\n          a = \"find\" + o;\n        t.prototype[a] = function (t, e) {\n          if (\"mixed\" === r || \"mixed\" === this.type || r === this.type) {\n            t = \"\" + t;\n            var n = this._nodes.get(t);\n            if (void 0 === n) throw new F(\"Graph.\".concat(a, ': could not find the \"').concat(t, '\" node in the graph.'));\n            return mt(!0, \"mixed\" === r ? this.type : r, i, n, e);\n          }\n        };\n        var c = \"some\" + o;\n        t.prototype[c] = function (t, e) {\n          return !!this[a](t, e);\n        };\n        var u = \"every\" + o;\n        t.prototype[u] = function (t, e) {\n          return !this[a](t, function (t, n) {\n            return !e(t, n);\n          });\n        };\n      }(t, e), Gt(t, e);\n    });\n  }(zt);\n  var Wt = function (t) {\n      function n(e) {\n        var n = u({\n          type: \"directed\"\n        }, e);\n        if (\"multi\" in n && !1 !== n.multi) throw new B(\"DirectedGraph.from: inconsistent indication that the graph should be multi in given options!\");\n        if (\"directed\" !== n.type) throw new B('DirectedGraph.from: inconsistent \"' + n.type + '\" type in given options!');\n        return t.call(this, n) || this;\n      }\n      return e(n, t), n;\n    }(zt),\n    Pt = function (t) {\n      function n(e) {\n        var n = u({\n          type: \"undirected\"\n        }, e);\n        if (\"multi\" in n && !1 !== n.multi) throw new B(\"UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!\");\n        if (\"undirected\" !== n.type) throw new B('UndirectedGraph.from: inconsistent \"' + n.type + '\" type in given options!');\n        return t.call(this, n) || this;\n      }\n      return e(n, t), n;\n    }(zt),\n    Rt = function (t) {\n      function n(e) {\n        var n = u({\n          multi: !0\n        }, e);\n        if (\"multi\" in n && !0 !== n.multi) throw new B(\"MultiGraph.from: inconsistent indication that the graph should be simple in given options!\");\n        return t.call(this, n) || this;\n      }\n      return e(n, t), n;\n    }(zt),\n    Kt = function (t) {\n      function n(e) {\n        var n = u({\n          type: \"directed\",\n          multi: !0\n        }, e);\n        if (\"multi\" in n && !0 !== n.multi) throw new B(\"MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!\");\n        if (\"directed\" !== n.type) throw new B('MultiDirectedGraph.from: inconsistent \"' + n.type + '\" type in given options!');\n        return t.call(this, n) || this;\n      }\n      return e(n, t), n;\n    }(zt),\n    Tt = function (t) {\n      function n(e) {\n        var n = u({\n          type: \"undirected\",\n          multi: !0\n        }, e);\n        if (\"multi\" in n && !0 !== n.multi) throw new B(\"MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!\");\n        if (\"undirected\" !== n.type) throw new B('MultiUndirectedGraph.from: inconsistent \"' + n.type + '\" type in given options!');\n        return t.call(this, n) || this;\n      }\n      return e(n, t), n;\n    }(zt);\n  function Bt(t) {\n    t.from = function (e, n) {\n      var r = u({}, e.options, n),\n        i = new t(r);\n      return i.import(e), i;\n    };\n  }\n  return Bt(zt), Bt(Wt), Bt(Pt), Bt(Rt), Bt(Kt), Bt(Tt), zt.Graph = zt, zt.DirectedGraph = Wt, zt.UndirectedGraph = Pt, zt.MultiGraph = Rt, zt.MultiDirectedGraph = Kt, zt.MultiUndirectedGraph = Tt, zt.InvalidArgumentsGraphError = B, zt.NotFoundGraphError = F, zt.UsageGraphError = I, zt;\n});","map":{"version":3,"names":["u","assign","t","arguments","e","n","length","r","d","i","_nodes","get","o","out","undirected","s","h","p","Object","defineProperty","enumerable","configurable","writable","value","f","l","attributes","Array","isArray","g","y","exports","w","Reflect","v","apply","Function","prototype","call","ownKeys","getOwnPropertySymbols","getOwnPropertyNames","concat","b","Number","isNaN","m","init","once","Promise","removeListener","slice","U","on","EventEmitter","_events","_eventsCount","_maxListeners","k","_","TypeError","G","defaultMaxListeners","x","a","c","create","newListener","emit","listener","unshift","push","warned","Error","String","name","emitter","type","count","console","warn","E","fired","target","wrapFn","A","bind","L","D","S","addEventListener","removeEventListener","N","next","set","RangeError","getPrototypeOf","setMaxListeners","getMaxListeners","error","message","context","addListener","prependListener","prependOnceListener","shift","pop","off","removeAllListeners","keys","listeners","rawListeners","listenerCount","eventNames","Symbol","iterator","of","done","empty","fromSequence","is","O","j","ARRAY_BUFFER_SUPPORT","ArrayBuffer","SYMBOL_SUPPORT","C","M","z","W","P","iter","isView","R","K","take","T","B","captureStackTrace","constructor","F","I","Y","key","clear","q","J","V","source","inDegree","outDegree","undirectedDegree","undirectedLoops","directedLoops","in","attach","attachMulti","previous","detach","detachMulti","H","_edges","Q","attacher","hasOwnProperty","data","X","multi","Z","$","tt","chain","et","direction","nt","rt","it","edge","sourceAttributes","targetAttributes","ot","at","ct","ut","size","from","undirectedSize","directedSize","values","dt","st","ht","pt","ft","lt","gt","yt","wt","vt","bt","has","mt","wrap","kt","neighbor","_t","Gt","xt","Et","At","Lt","St","Math","floor","random","Dt","Set","Ut","Nt","allowSelfLoops","Ot","NodeDataClass","jt","_edgeKeyGenerator","_undirectedSelfLoopCount","_directedSelfLoopCount","_undirectedSize","_directedSize","Ct","Mt","delete","zt","Map","forEach","_options","_resetInstanceCounters","hasNode","hasDirectedEdge","hasUndirectedEdge","hasEdge","directedEdge","undirectedEdge","areDirectedNeighbors","areOutNeighbors","areInNeighbors","areUndirectedNeighbors","areNeighbors","areInboundNeighbors","areOutboundNeighbors","directedDegree","inboundDegree","outboundDegree","degree","inDegreeWithoutSelfLoops","outDegreeWithoutSelfLoops","directedDegreeWithoutSelfLoops","undirectedDegreeWithoutSelfLoops","inboundDegreeWithoutSelfLoops","outboundDegreeWithoutSelfLoops","degreeWithoutSelfLoops","extremities","opposite","hasExtremity","isUndirected","isDirected","isSelfLoop","addNode","mergeNode","updateNode","dropNode","dropEdge","dropDirectedEdge","dropUndirectedEdge","clearEdges","getAttribute","_attributes","getAttributes","hasAttribute","setAttribute","updateAttribute","removeAttribute","replaceAttributes","mergeAttributes","updateAttributes","updateEachNodeAttributes","hints","updateEachEdgeAttributes","forEachAdjacencyEntry","forEachAdjacencyEntryWithOrphans","forEachAssymetricAdjacencyEntry","forEachAssymetricAdjacencyEntryWithOrphans","nodes","forEachNode","findNode","mapNodes","order","someNode","everyNode","filterNodes","reduceNodes","nodeEntries","node","export","options","edges","import","forEachEdge","mergeUndirectedEdgeWithKey","mergeDirectedEdgeWithKey","addUndirectedEdgeWithKey","addDirectedEdgeWithKey","mergeUndirectedEdge","mergeDirectedEdge","addUndirectedEdge","addDirectedEdge","nullCopy","emptyCopy","copy","toJSON","toString","inspect","startsWith","for","generateKey","toUpperCase","Wt","Pt","Rt","Kt","Tt","Bt","Graph","DirectedGraph","UndirectedGraph","MultiGraph","MultiDirectedGraph","MultiUndirectedGraph","InvalidArgumentsGraphError","NotFoundGraphError","UsageGraphError"],"sources":["/Users/radhika.bajaj/Documents/GitHub/Knowledge-Graph-Frontend/node_modules/graphology/src/utils.js","/Users/radhika.bajaj/Documents/GitHub/Knowledge-Graph-Frontend/node_modules/events/events.js","/Users/radhika.bajaj/Documents/GitHub/Knowledge-Graph-Frontend/node_modules/obliterator/iterator.js","/Users/radhika.bajaj/Documents/GitHub/Knowledge-Graph-Frontend/node_modules/obliterator/support.js","/Users/radhika.bajaj/Documents/GitHub/Knowledge-Graph-Frontend/node_modules/obliterator/iter.js","/Users/radhika.bajaj/Documents/GitHub/Knowledge-Graph-Frontend/node_modules/obliterator/take.js","/Users/radhika.bajaj/Documents/GitHub/Knowledge-Graph-Frontend/node_modules/graphology/src/errors.js","/Users/radhika.bajaj/Documents/GitHub/Knowledge-Graph-Frontend/node_modules/graphology/src/data.js","/Users/radhika.bajaj/Documents/GitHub/Knowledge-Graph-Frontend/node_modules/graphology/src/attributes/nodes.js","/Users/radhika.bajaj/Documents/GitHub/Knowledge-Graph-Frontend/node_modules/graphology/src/attributes/edges.js","/Users/radhika.bajaj/Documents/GitHub/Knowledge-Graph-Frontend/node_modules/obliterator/chain.js","/Users/radhika.bajaj/Documents/GitHub/Knowledge-Graph-Frontend/node_modules/graphology/src/iteration/edges.js","/Users/radhika.bajaj/Documents/GitHub/Knowledge-Graph-Frontend/node_modules/graphology/src/iteration/neighbors.js","/Users/radhika.bajaj/Documents/GitHub/Knowledge-Graph-Frontend/node_modules/graphology/src/iteration/adjacency.js","/Users/radhika.bajaj/Documents/GitHub/Knowledge-Graph-Frontend/node_modules/graphology/src/serialization.js","/Users/radhika.bajaj/Documents/GitHub/Knowledge-Graph-Frontend/node_modules/graphology/src/graph.js","/Users/radhika.bajaj/Documents/GitHub/Knowledge-Graph-Frontend/node_modules/graphology/src/classes.js"],"sourcesContent":["/**\n * Graphology Utilities\n * =====================\n *\n * Collection of helpful functions used by the implementation.\n */\n\n/**\n * Object.assign-like polyfill.\n *\n * @param  {object} target       - First object.\n * @param  {object} [...objects] - Objects to merge.\n * @return {object}\n */\nfunction assignPolyfill() {\n  const target = arguments[0];\n\n  for (let i = 1, l = arguments.length; i < l; i++) {\n    if (!arguments[i]) continue;\n\n    for (const k in arguments[i]) target[k] = arguments[i][k];\n  }\n\n  return target;\n}\n\nlet assign = assignPolyfill;\n\nif (typeof Object.assign === 'function') assign = Object.assign;\n\nexport {assign};\n\n/**\n * Function returning the first matching edge for given path.\n * Note: this function does not check the existence of source & target. This\n * must be performed by the caller.\n *\n * @param  {Graph}  graph  - Target graph.\n * @param  {any}    source - Source node.\n * @param  {any}    target - Target node.\n * @param  {string} type   - Type of the edge (mixed, directed or undirected).\n * @return {string|null}\n */\nexport function getMatchingEdge(graph, source, target, type) {\n  const sourceData = graph._nodes.get(source);\n\n  let edge = null;\n\n  if (!sourceData) return edge;\n\n  if (type === 'mixed') {\n    edge =\n      (sourceData.out && sourceData.out[target]) ||\n      (sourceData.undirected && sourceData.undirected[target]);\n  } else if (type === 'directed') {\n    edge = sourceData.out && sourceData.out[target];\n  } else {\n    edge = sourceData.undirected && sourceData.undirected[target];\n  }\n\n  return edge;\n}\n\n/**\n * Checks whether the given value is a plain object.\n *\n * @param  {mixed}   value - Target value.\n * @return {boolean}\n */\nexport function isPlainObject(value) {\n  // NOTE: as per https://github.com/graphology/graphology/issues/149\n  // this function has been loosened not to reject object instances\n  // coming from other JavaScript contexts. It has also been chosen\n  // not to improve it to avoid obvious false positives and avoid\n  // taking a performance hit. People should really use TypeScript\n  // if they want to avoid feeding subtly irrelvant attribute objects.\n  return typeof value === 'object' && value !== null;\n}\n\n/**\n * Checks whether the given object is empty.\n *\n * @param  {object}  o - Target Object.\n * @return {boolean}\n */\nexport function isEmpty(o) {\n  let k;\n\n  for (k in o) return false;\n\n  return true;\n}\n\n/**\n * Creates a \"private\" property for the given member name by concealing it\n * using the `enumerable` option.\n *\n * @param {object} target - Target object.\n * @param {string} name   - Member name.\n */\nexport function privateProperty(target, name, value) {\n  Object.defineProperty(target, name, {\n    enumerable: false,\n    configurable: false,\n    writable: true,\n    value\n  });\n}\n\n/**\n * Creates a read-only property for the given member name & the given getter.\n *\n * @param {object}   target - Target object.\n * @param {string}   name   - Member name.\n * @param {mixed}    value  - The attached getter or fixed value.\n */\nexport function readOnlyProperty(target, name, value) {\n  const descriptor = {\n    enumerable: true,\n    configurable: true\n  };\n\n  if (typeof value === 'function') {\n    descriptor.get = value;\n  } else {\n    descriptor.value = value;\n    descriptor.writable = false;\n  }\n\n  Object.defineProperty(target, name, descriptor);\n}\n\n/**\n * Returns whether the given object constitute valid hints.\n *\n * @param {object} hints - Target object.\n */\nexport function validateHints(hints) {\n  if (!isPlainObject(hints)) return false;\n\n  if (hints.attributes && !Array.isArray(hints.attributes)) return false;\n\n  return true;\n}\n\n/**\n * Creates a function generating incremental ids for edges.\n *\n * @return {function}\n */\nexport function incrementalIdStartingFromRandomByte() {\n  let i = Math.floor(Math.random() * 256) & 0xff;\n\n  return () => {\n    return i++;\n  };\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","/**\n * Obliterator Iterator Class\n * ===========================\n *\n * Simple class representing the library's iterators.\n */\n\n/**\n * Iterator class.\n *\n * @constructor\n * @param {function} next - Next function.\n */\nfunction Iterator(next) {\n  if (typeof next !== 'function')\n    throw new Error('obliterator/iterator: expecting a function!');\n\n  this.next = next;\n}\n\n/**\n * If symbols are supported, we add `next` to `Symbol.iterator`.\n */\nif (typeof Symbol !== 'undefined')\n  Iterator.prototype[Symbol.iterator] = function () {\n    return this;\n  };\n\n/**\n * Returning an iterator of the given values.\n *\n * @param  {any...} values - Values.\n * @return {Iterator}\n */\nIterator.of = function () {\n  var args = arguments,\n    l = args.length,\n    i = 0;\n\n  return new Iterator(function () {\n    if (i >= l) return {done: true};\n\n    return {done: false, value: args[i++]};\n  });\n};\n\n/**\n * Returning an empty iterator.\n *\n * @return {Iterator}\n */\nIterator.empty = function () {\n  var iterator = new Iterator(function () {\n    return {done: true};\n  });\n\n  return iterator;\n};\n\n/**\n * Returning an iterator over the given indexed sequence.\n *\n * @param  {string|Array} sequence - Target sequence.\n * @return {Iterator}\n */\nIterator.fromSequence = function (sequence) {\n  var i = 0,\n    l = sequence.length;\n\n  return new Iterator(function () {\n    if (i >= l) return {done: true};\n\n    return {done: false, value: sequence[i++]};\n  });\n};\n\n/**\n * Returning whether the given value is an iterator.\n *\n * @param  {any} value - Value.\n * @return {boolean}\n */\nIterator.is = function (value) {\n  if (value instanceof Iterator) return true;\n\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    typeof value.next === 'function'\n  );\n};\n\n/**\n * Exporting.\n */\nmodule.exports = Iterator;\n","exports.ARRAY_BUFFER_SUPPORT = typeof ArrayBuffer !== 'undefined';\nexports.SYMBOL_SUPPORT = typeof Symbol !== 'undefined';\n","/**\n * Obliterator Iter Function\n * ==========================\n *\n * Function coercing values to an iterator. It can be quite useful when needing\n * to handle iterables and iterators the same way.\n */\nvar Iterator = require('./iterator.js');\nvar support = require('./support.js');\n\nvar ARRAY_BUFFER_SUPPORT = support.ARRAY_BUFFER_SUPPORT;\nvar SYMBOL_SUPPORT = support.SYMBOL_SUPPORT;\n\nfunction iterOrNull(target) {\n  // Indexed sequence\n  if (\n    typeof target === 'string' ||\n    Array.isArray(target) ||\n    (ARRAY_BUFFER_SUPPORT && ArrayBuffer.isView(target))\n  )\n    return Iterator.fromSequence(target);\n\n  // Invalid value\n  if (typeof target !== 'object' || target === null) return null;\n\n  // Iterable\n  if (SYMBOL_SUPPORT && typeof target[Symbol.iterator] === 'function')\n    return target[Symbol.iterator]();\n\n  // Iterator duck-typing\n  if (typeof target.next === 'function') return target;\n\n  // Invalid object\n  return null;\n}\n\nmodule.exports = function iter(target) {\n  var iterator = iterOrNull(target);\n\n  if (!iterator)\n    throw new Error(\n      'obliterator: target is not iterable nor a valid iterator.'\n    );\n\n  return iterator;\n};\n","/* eslint no-constant-condition: 0 */\n/**\n * Obliterator Take Function\n * ==========================\n *\n * Function taking n or every value of the given iterator and returns them\n * into an array.\n */\nvar iter = require('./iter.js');\n\n/**\n * Take.\n *\n * @param  {Iterable} iterable - Target iterable.\n * @param  {number}   [n]      - Optional number of items to take.\n * @return {array}\n */\nmodule.exports = function take(iterable, n) {\n  var l = arguments.length > 1 ? n : Infinity,\n    array = l !== Infinity ? new Array(l) : [],\n    step,\n    i = 0;\n\n  var iterator = iter(iterable);\n\n  while (true) {\n    if (i === l) return array;\n\n    step = iterator.next();\n\n    if (step.done) {\n      if (i !== n) array.length = i;\n\n      return array;\n    }\n\n    array[i++] = step.value;\n  }\n};\n","/**\n * Graphology Custom Errors\n * =========================\n *\n * Defining custom errors for ease of use & easy unit tests across\n * implementations (normalized typology rather than relying on error\n * messages to check whether the correct error was found).\n */\nexport class GraphError extends Error {\n  constructor(message) {\n    super();\n    this.name = 'GraphError';\n    this.message = message;\n  }\n}\n\nexport class InvalidArgumentsGraphError extends GraphError {\n  constructor(message) {\n    super(message);\n    this.name = 'InvalidArgumentsGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(\n        this,\n        InvalidArgumentsGraphError.prototype.constructor\n      );\n  }\n}\n\nexport class NotFoundGraphError extends GraphError {\n  constructor(message) {\n    super(message);\n    this.name = 'NotFoundGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(this, NotFoundGraphError.prototype.constructor);\n  }\n}\n\nexport class UsageGraphError extends GraphError {\n  constructor(message) {\n    super(message);\n    this.name = 'UsageGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(this, UsageGraphError.prototype.constructor);\n  }\n}\n","/**\n * Graphology Internal Data Classes\n * =================================\n *\n * Internal classes hopefully reduced to structs by engines & storing\n * necessary information for nodes & edges.\n *\n * Note that those classes don't rely on the `class` keyword to avoid some\n * cruft introduced by most of ES2015 transpilers.\n */\n\n/**\n * MixedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function MixedNodeData(key, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  this.clear();\n}\n\nMixedNodeData.prototype.clear = function () {\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.undirectedDegree = 0;\n  this.undirectedLoops = 0;\n  this.directedLoops = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n  this.undirected = {};\n};\n\n/**\n * DirectedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function DirectedNodeData(key, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  this.clear();\n}\n\nDirectedNodeData.prototype.clear = function () {\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.directedLoops = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n};\n\n/**\n * UndirectedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function UndirectedNodeData(key, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  this.clear();\n}\n\nUndirectedNodeData.prototype.clear = function () {\n  // Degrees\n  this.undirectedDegree = 0;\n  this.undirectedLoops = 0;\n\n  // Indices\n  this.undirected = {};\n};\n\n/**\n * EdgeData class.\n *\n * @constructor\n * @param {boolean} undirected   - Whether the edge is undirected.\n * @param {string}  string       - The edge's key.\n * @param {string}  source       - Source of the edge.\n * @param {string}  target       - Target of the edge.\n * @param {object}  attributes   - Edge's attributes.\n */\nexport function EdgeData(undirected, key, source, target, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n  this.undirected = undirected;\n\n  // Extremities\n  this.source = source;\n  this.target = target;\n}\n\nEdgeData.prototype.attach = function () {\n  let outKey = 'out';\n  let inKey = 'in';\n\n  if (this.undirected) outKey = inKey = 'undirected';\n\n  const source = this.source.key;\n  const target = this.target.key;\n\n  // Handling source\n  this.source[outKey][target] = this;\n\n  if (this.undirected && source === target) return;\n\n  // Handling target\n  this.target[inKey][source] = this;\n};\n\nEdgeData.prototype.attachMulti = function () {\n  let outKey = 'out';\n  let inKey = 'in';\n\n  const source = this.source.key;\n  const target = this.target.key;\n\n  if (this.undirected) outKey = inKey = 'undirected';\n\n  // Handling source\n  const adj = this.source[outKey];\n  const head = adj[target];\n\n  if (typeof head === 'undefined') {\n    adj[target] = this;\n\n    // Self-loop optimization\n    if (!(this.undirected && source === target)) {\n      // Handling target\n      this.target[inKey][source] = this;\n    }\n\n    return;\n  }\n\n  // Prepending to doubly-linked list\n  head.previous = this;\n  this.next = head;\n\n  // Pointing to new head\n  // NOTE: use mutating swap later to avoid lookup?\n  adj[target] = this;\n  this.target[inKey][source] = this;\n};\n\nEdgeData.prototype.detach = function () {\n  const source = this.source.key;\n  const target = this.target.key;\n\n  let outKey = 'out';\n  let inKey = 'in';\n\n  if (this.undirected) outKey = inKey = 'undirected';\n\n  delete this.source[outKey][target];\n\n  // No-op delete in case of undirected self-loop\n  delete this.target[inKey][source];\n};\n\nEdgeData.prototype.detachMulti = function () {\n  const source = this.source.key;\n  const target = this.target.key;\n\n  let outKey = 'out';\n  let inKey = 'in';\n\n  if (this.undirected) outKey = inKey = 'undirected';\n\n  // Deleting from doubly-linked list\n  if (this.previous === undefined) {\n    // We are dealing with the head\n\n    // Should we delete the adjacency entry because it is now empty?\n    if (this.next === undefined) {\n      delete this.source[outKey][target];\n\n      // No-op delete in case of undirected self-loop\n      delete this.target[inKey][source];\n    } else {\n      // Detaching\n      this.next.previous = undefined;\n\n      // NOTE: could avoid the lookups by creating a #.become mutating method\n      this.source[outKey][target] = this.next;\n\n      // No-op delete in case of undirected self-loop\n      this.target[inKey][source] = this.next;\n    }\n  } else {\n    // We are dealing with another list node\n    this.previous.next = this.next;\n\n    // If not last\n    if (this.next !== undefined) {\n      this.next.previous = this.previous;\n    }\n  }\n};\n","/**\n * Graphology Node Attributes methods\n * ===================================\n */\nimport {assign, isPlainObject} from '../utils';\n\nimport {InvalidArgumentsGraphError, NotFoundGraphError} from '../errors';\n\nconst NODE = 0;\nconst SOURCE = 1;\nconst TARGET = 2;\nconst OPPOSITE = 3;\n\nfunction findRelevantNodeData(\n  graph,\n  method,\n  mode,\n  nodeOrEdge,\n  nameOrEdge,\n  add1,\n  add2\n) {\n  let nodeData, edgeData, arg1, arg2;\n\n  nodeOrEdge = '' + nodeOrEdge;\n\n  if (mode === NODE) {\n    nodeData = graph._nodes.get(nodeOrEdge);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${nodeOrEdge}\" node in the graph.`\n      );\n\n    arg1 = nameOrEdge;\n    arg2 = add1;\n  } else if (mode === OPPOSITE) {\n    nameOrEdge = '' + nameOrEdge;\n\n    edgeData = graph._edges.get(nameOrEdge);\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${nameOrEdge}\" edge in the graph.`\n      );\n\n    const source = edgeData.source.key;\n    const target = edgeData.target.key;\n\n    if (nodeOrEdge === source) {\n      nodeData = edgeData.target;\n    } else if (nodeOrEdge === target) {\n      nodeData = edgeData.source;\n    } else {\n      throw new NotFoundGraphError(\n        `Graph.${method}: the \"${nodeOrEdge}\" node is not attached to the \"${nameOrEdge}\" edge (${source}, ${target}).`\n      );\n    }\n\n    arg1 = add1;\n    arg2 = add2;\n  } else {\n    edgeData = graph._edges.get(nodeOrEdge);\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${nodeOrEdge}\" edge in the graph.`\n      );\n\n    if (mode === SOURCE) {\n      nodeData = edgeData.source;\n    } else {\n      nodeData = edgeData.target;\n    }\n\n    arg1 = nameOrEdge;\n    arg2 = add1;\n  }\n\n  return [nodeData, arg1, arg2];\n}\n\nfunction attachNodeAttributeGetter(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, name] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    return data.attributes[name];\n  };\n}\n\nfunction attachNodeAttributesGetter(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge) {\n    const [data] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge\n    );\n\n    return data.attributes;\n  };\n}\n\nfunction attachNodeAttributeChecker(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, name] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    return data.attributes.hasOwnProperty(name);\n  };\n}\n\nfunction attachNodeAttributeSetter(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1, add2) {\n    const [data, name, value] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1,\n      add2\n    );\n\n    data.attributes[name] = value;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributeUpdater(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1, add2) {\n    const [data, name, updater] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1,\n      add2\n    );\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: updater should be a function.`\n      );\n\n    const attributes = data.attributes;\n    const value = updater(attributes[name]);\n\n    attributes[name] = value;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributeRemover(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, name] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    delete data.attributes[name];\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'remove',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributesReplacer(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, attributes] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    data.attributes = attributes;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'replace',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributesMerger(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, attributes] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    assign(data.attributes, attributes);\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'merge',\n      attributes: data.attributes,\n      data: attributes\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributesUpdater(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, updater] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided updater is not a function.`\n      );\n\n    data.attributes = updater(data.attributes);\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'update',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * List of methods to attach.\n */\nconst NODE_ATTRIBUTES_METHODS = [\n  {\n    name: element => `get${element}Attribute`,\n    attacher: attachNodeAttributeGetter\n  },\n  {\n    name: element => `get${element}Attributes`,\n    attacher: attachNodeAttributesGetter\n  },\n  {\n    name: element => `has${element}Attribute`,\n    attacher: attachNodeAttributeChecker\n  },\n  {\n    name: element => `set${element}Attribute`,\n    attacher: attachNodeAttributeSetter\n  },\n  {\n    name: element => `update${element}Attribute`,\n    attacher: attachNodeAttributeUpdater\n  },\n  {\n    name: element => `remove${element}Attribute`,\n    attacher: attachNodeAttributeRemover\n  },\n  {\n    name: element => `replace${element}Attributes`,\n    attacher: attachNodeAttributesReplacer\n  },\n  {\n    name: element => `merge${element}Attributes`,\n    attacher: attachNodeAttributesMerger\n  },\n  {\n    name: element => `update${element}Attributes`,\n    attacher: attachNodeAttributesUpdater\n  }\n];\n\n/**\n * Attach every attributes-related methods to a Graph class.\n *\n * @param {function} Graph - Target class.\n */\nexport default function attachNodeAttributesMethods(Graph) {\n  NODE_ATTRIBUTES_METHODS.forEach(function ({name, attacher}) {\n    // For nodes\n    attacher(Graph, name('Node'), NODE);\n\n    // For sources\n    attacher(Graph, name('Source'), SOURCE);\n\n    // For targets\n    attacher(Graph, name('Target'), TARGET);\n\n    // For opposites\n    attacher(Graph, name('Opposite'), OPPOSITE);\n  });\n}\n","/**\n * Graphology Edge Attributes methods\n * ===================================\n */\nimport {assign, isPlainObject, getMatchingEdge} from '../utils';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from '../errors';\n\n/**\n * Attach an attribute getter method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeGetter(Class, method, type) {\n  /**\n   * Get the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {mixed}          - The attribute's value.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element;\n      const target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    return data.attributes[name];\n  };\n}\n\n/**\n * Attach an attributes getter method onto the provided class.\n *\n * @param {function} Class       - Target class.\n * @param {string}   method      - Method name.\n * @param {string}   type        - Type of the edge to find.\n */\nfunction attachEdgeAttributesGetter(Class, method, type) {\n  /**\n   * Retrieves all the target element's attributes.\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   *\n   * @return {object}          - The element's attributes.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 1) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + arguments[1];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    return data.attributes;\n  };\n}\n\n/**\n * Attach an attribute checker method onto the provided class.\n *\n * @param {function} Class       - Target class.\n * @param {string}   method      - Method name.\n * @param {string}   type        - Type of the edge to find.\n */\nfunction attachEdgeAttributeChecker(Class, method, type) {\n  /**\n   * Checks whether the desired attribute is set for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element;\n      const target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    return data.attributes.hasOwnProperty(name);\n  };\n}\n\n/**\n * Attach an attribute setter method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeSetter(Class, method, type) {\n  /**\n   * Set the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   * @param  {mixed}  value   - New attribute value.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   * @param  {mixed}  value   - New attribute value.\n   *\n   * @return {Graph}          - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name, value) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 3) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element;\n      const target = '' + name;\n\n      name = arguments[2];\n      value = arguments[3];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    data.attributes[name] = value;\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute updater method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeUpdater(Class, method, type) {\n  /**\n   * Update the desired attribute for the given element (node or edge) using\n   * the provided function.\n   *\n   * Arity 2:\n   * @param  {any}      element - Target element.\n   * @param  {string}   name    - Attribute's name.\n   * @param  {function} updater - Updater function.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}      source  - Source element.\n   * @param  {any}      target  - Target element.\n   * @param  {string}   name    - Attribute's name.\n   * @param  {function} updater - Updater function.\n   *\n   * @return {Graph}            - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name, updater) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 3) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element;\n      const target = '' + name;\n\n      name = arguments[2];\n      updater = arguments[3];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: updater should be a function.`\n      );\n\n    data.attributes[name] = updater(data.attributes[name]);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute remover method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeRemover(Class, method, type) {\n  /**\n   * Remove the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {Graph}          - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element;\n      const target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    delete data.attributes[name];\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'remove',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute replacer method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributesReplacer(Class, method, type) {\n  /**\n   * Replace the attributes for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element    - Target element.\n   * @param  {object} attributes - New attributes.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source     - Source element.\n   * @param  {any}     target     - Target element.\n   * @param  {object}  attributes - New attributes.\n   *\n   * @return {Graph}              - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, attributes) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + attributes;\n\n      attributes = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    data.attributes = attributes;\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'replace',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute merger method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributesMerger(Class, method, type) {\n  /**\n   * Merge the attributes for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element    - Target element.\n   * @param  {object} attributes - Attributes to merge.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source     - Source element.\n   * @param  {any}     target     - Target element.\n   * @param  {object}  attributes - Attributes to merge.\n   *\n   * @return {Graph}              - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, attributes) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + attributes;\n\n      attributes = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    assign(data.attributes, attributes);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'merge',\n      attributes: data.attributes,\n      data: attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute updater method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributesUpdater(Class, method, type) {\n  /**\n   * Update the attributes of the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}      element - Target element.\n   * @param  {function} updater - Updater function.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}      source  - Source element.\n   * @param  {any}      target  - Target element.\n   * @param  {function} updater - Updater function.\n   *\n   * @return {Graph}            - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, updater) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + updater;\n\n      updater = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided updater is not a function.`\n      );\n\n    data.attributes = updater(data.attributes);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'update',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * List of methods to attach.\n */\nconst EDGE_ATTRIBUTES_METHODS = [\n  {\n    name: element => `get${element}Attribute`,\n    attacher: attachEdgeAttributeGetter\n  },\n  {\n    name: element => `get${element}Attributes`,\n    attacher: attachEdgeAttributesGetter\n  },\n  {\n    name: element => `has${element}Attribute`,\n    attacher: attachEdgeAttributeChecker\n  },\n  {\n    name: element => `set${element}Attribute`,\n    attacher: attachEdgeAttributeSetter\n  },\n  {\n    name: element => `update${element}Attribute`,\n    attacher: attachEdgeAttributeUpdater\n  },\n  {\n    name: element => `remove${element}Attribute`,\n    attacher: attachEdgeAttributeRemover\n  },\n  {\n    name: element => `replace${element}Attributes`,\n    attacher: attachEdgeAttributesReplacer\n  },\n  {\n    name: element => `merge${element}Attributes`,\n    attacher: attachEdgeAttributesMerger\n  },\n  {\n    name: element => `update${element}Attributes`,\n    attacher: attachEdgeAttributesUpdater\n  }\n];\n\n/**\n * Attach every attributes-related methods to a Graph class.\n *\n * @param {function} Graph - Target class.\n */\nexport default function attachEdgeAttributesMethods(Graph) {\n  EDGE_ATTRIBUTES_METHODS.forEach(function ({name, attacher}) {\n    // For edges\n    attacher(Graph, name('Edge'), 'mixed');\n\n    // For directed edges\n    attacher(Graph, name('DirectedEdge'), 'directed');\n\n    // For undirected edges\n    attacher(Graph, name('UndirectedEdge'), 'undirected');\n  });\n}\n","/**\n * Obliterator Chain Function\n * ===========================\n *\n * Variadic function combining the given iterables.\n */\nvar Iterator = require('./iterator.js');\nvar iter = require('./iter.js');\n\n/**\n * Chain.\n *\n * @param  {...Iterator} iterables - Target iterables.\n * @return {Iterator}\n */\nmodule.exports = function chain() {\n  var iterables = arguments;\n  var current = null;\n  var i = -1;\n\n  /* eslint-disable no-constant-condition */\n  return new Iterator(function next() {\n    var step = null;\n\n    do {\n      if (current === null) {\n        i++;\n\n        if (i >= iterables.length) return {done: true};\n\n        current = iter(iterables[i]);\n      }\n\n      step = current.next();\n\n      if (step.done === true) {\n        current = null;\n        continue;\n      }\n\n      break;\n    } while (true);\n\n    return step;\n  });\n};\n","/**\n * Graphology Edge Iteration\n * ==========================\n *\n * Attaching some methods to the Graph class to be able to iterate over a\n * graph's edges.\n */\nimport Iterator from 'obliterator/iterator';\nimport chain from 'obliterator/chain';\nimport take from 'obliterator/take';\n\nimport {InvalidArgumentsGraphError, NotFoundGraphError} from '../errors';\n\n/**\n * Definitions.\n */\nconst EDGES_ITERATION = [\n  {\n    name: 'edges',\n    type: 'mixed'\n  },\n  {\n    name: 'inEdges',\n    type: 'directed',\n    direction: 'in'\n  },\n  {\n    name: 'outEdges',\n    type: 'directed',\n    direction: 'out'\n  },\n  {\n    name: 'inboundEdges',\n    type: 'mixed',\n    direction: 'in'\n  },\n  {\n    name: 'outboundEdges',\n    type: 'mixed',\n    direction: 'out'\n  },\n  {\n    name: 'directedEdges',\n    type: 'directed'\n  },\n  {\n    name: 'undirectedEdges',\n    type: 'undirected'\n  }\n];\n\n/**\n * Function iterating over edges from the given object to match one of them.\n *\n * @param {object}   object   - Target object.\n * @param {function} callback - Function to call.\n */\nfunction forEachSimple(breakable, object, callback, avoid) {\n  let shouldBreak = false;\n\n  for (const k in object) {\n    if (k === avoid) continue;\n\n    const edgeData = object[k];\n\n    shouldBreak = callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected\n    );\n\n    if (breakable && shouldBreak) return edgeData.key;\n  }\n\n  return;\n}\n\nfunction forEachMulti(breakable, object, callback, avoid) {\n  let edgeData, source, target;\n\n  let shouldBreak = false;\n\n  for (const k in object) {\n    if (k === avoid) continue;\n\n    edgeData = object[k];\n\n    do {\n      source = edgeData.source;\n      target = edgeData.target;\n\n      shouldBreak = callback(\n        edgeData.key,\n        edgeData.attributes,\n        source.key,\n        target.key,\n        source.attributes,\n        target.attributes,\n        edgeData.undirected\n      );\n\n      if (breakable && shouldBreak) return edgeData.key;\n\n      edgeData = edgeData.next;\n    } while (edgeData !== undefined);\n  }\n\n  return;\n}\n\n/**\n * Function returning an iterator over edges from the given object.\n *\n * @param  {object}   object - Target object.\n * @return {Iterator}\n */\nfunction createIterator(object, avoid) {\n  const keys = Object.keys(object);\n  const l = keys.length;\n\n  let edgeData;\n  let i = 0;\n\n  return new Iterator(function next() {\n    do {\n      if (!edgeData) {\n        if (i >= l) return {done: true};\n\n        const k = keys[i++];\n\n        if (k === avoid) {\n          edgeData = undefined;\n          continue;\n        }\n\n        edgeData = object[k];\n      } else {\n        edgeData = edgeData.next;\n      }\n    } while (!edgeData);\n\n    return {\n      done: false,\n      value: {\n        edge: edgeData.key,\n        attributes: edgeData.attributes,\n        source: edgeData.source.key,\n        target: edgeData.target.key,\n        sourceAttributes: edgeData.source.attributes,\n        targetAttributes: edgeData.target.attributes,\n        undirected: edgeData.undirected\n      }\n    };\n  });\n}\n\n/**\n * Function iterating over the egdes from the object at given key to match\n * one of them.\n *\n * @param {object}   object   - Target object.\n * @param {mixed}    k        - Neighbor key.\n * @param {function} callback - Callback to use.\n */\nfunction forEachForKeySimple(breakable, object, k, callback) {\n  const edgeData = object[k];\n\n  if (!edgeData) return;\n\n  const sourceData = edgeData.source;\n  const targetData = edgeData.target;\n\n  if (\n    callback(\n      edgeData.key,\n      edgeData.attributes,\n      sourceData.key,\n      targetData.key,\n      sourceData.attributes,\n      targetData.attributes,\n      edgeData.undirected\n    ) &&\n    breakable\n  )\n    return edgeData.key;\n}\n\nfunction forEachForKeyMulti(breakable, object, k, callback) {\n  let edgeData = object[k];\n\n  if (!edgeData) return;\n\n  let shouldBreak = false;\n\n  do {\n    shouldBreak = callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected\n    );\n\n    if (breakable && shouldBreak) return edgeData.key;\n\n    edgeData = edgeData.next;\n  } while (edgeData !== undefined);\n\n  return;\n}\n\n/**\n * Function returning an iterator over the egdes from the object at given key.\n *\n * @param  {object}   object   - Target object.\n * @param  {mixed}    k        - Neighbor key.\n * @return {Iterator}\n */\nfunction createIteratorForKey(object, k) {\n  let edgeData = object[k];\n\n  if (edgeData.next !== undefined) {\n    return new Iterator(function () {\n      if (!edgeData) return {done: true};\n\n      const value = {\n        edge: edgeData.key,\n        attributes: edgeData.attributes,\n        source: edgeData.source.key,\n        target: edgeData.target.key,\n        sourceAttributes: edgeData.source.attributes,\n        targetAttributes: edgeData.target.attributes,\n        undirected: edgeData.undirected\n      };\n\n      edgeData = edgeData.next;\n\n      return {\n        done: false,\n        value\n      };\n    });\n  }\n\n  return Iterator.of({\n    edge: edgeData.key,\n    attributes: edgeData.attributes,\n    source: edgeData.source.key,\n    target: edgeData.target.key,\n    sourceAttributes: edgeData.source.attributes,\n    targetAttributes: edgeData.target.attributes,\n    undirected: edgeData.undirected\n  });\n}\n\n/**\n * Function creating an array of edges for the given type.\n *\n * @param  {Graph}   graph - Target Graph instance.\n * @param  {string}  type  - Type of edges to retrieve.\n * @return {array}         - Array of edges.\n */\nfunction createEdgeArray(graph, type) {\n  if (graph.size === 0) return [];\n\n  if (type === 'mixed' || type === graph.type) {\n    if (typeof Array.from === 'function')\n      return Array.from(graph._edges.keys());\n\n    return take(graph._edges.keys(), graph._edges.size);\n  }\n\n  const size =\n    type === 'undirected' ? graph.undirectedSize : graph.directedSize;\n\n  const list = new Array(size),\n    mask = type === 'undirected';\n\n  const iterator = graph._edges.values();\n\n  let i = 0;\n  let step, data;\n\n  while (((step = iterator.next()), step.done !== true)) {\n    data = step.value;\n\n    if (data.undirected === mask) list[i++] = data.key;\n  }\n\n  return list;\n}\n\n/**\n * Function iterating over a graph's edges using a callback to match one of\n * them.\n *\n * @param  {Graph}    graph    - Target Graph instance.\n * @param  {string}   type     - Type of edges to retrieve.\n * @param  {function} callback - Function to call.\n */\nfunction forEachEdge(breakable, graph, type, callback) {\n  if (graph.size === 0) return;\n\n  const shouldFilter = type !== 'mixed' && type !== graph.type;\n  const mask = type === 'undirected';\n\n  let step, data;\n  let shouldBreak = false;\n  const iterator = graph._edges.values();\n\n  while (((step = iterator.next()), step.done !== true)) {\n    data = step.value;\n\n    if (shouldFilter && data.undirected !== mask) continue;\n\n    const {key, attributes, source, target} = data;\n\n    shouldBreak = callback(\n      key,\n      attributes,\n      source.key,\n      target.key,\n      source.attributes,\n      target.attributes,\n      data.undirected\n    );\n\n    if (breakable && shouldBreak) return key;\n  }\n\n  return;\n}\n\n/**\n * Function creating an iterator of edges for the given type.\n *\n * @param  {Graph}    graph - Target Graph instance.\n * @param  {string}   type  - Type of edges to retrieve.\n * @return {Iterator}\n */\nfunction createEdgeIterator(graph, type) {\n  if (graph.size === 0) return Iterator.empty();\n\n  const shouldFilter = type !== 'mixed' && type !== graph.type;\n  const mask = type === 'undirected';\n\n  const iterator = graph._edges.values();\n\n  return new Iterator(function next() {\n    let step, data;\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      step = iterator.next();\n\n      if (step.done) return step;\n\n      data = step.value;\n\n      if (shouldFilter && data.undirected !== mask) continue;\n\n      break;\n    }\n\n    const value = {\n      edge: data.key,\n      attributes: data.attributes,\n      source: data.source.key,\n      target: data.target.key,\n      sourceAttributes: data.source.attributes,\n      targetAttributes: data.target.attributes,\n      undirected: data.undirected\n    };\n\n    return {value, done: false};\n  });\n}\n\n/**\n * Function iterating over a node's edges using a callback to match one of them.\n *\n * @param  {boolean}  multi     - Whether the graph is multi or not.\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Function to call.\n */\nfunction forEachEdgeForNode(\n  breakable,\n  multi,\n  type,\n  direction,\n  nodeData,\n  callback\n) {\n  const fn = multi ? forEachMulti : forEachSimple;\n\n  let found;\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      found = fn(breakable, nodeData.in, callback);\n\n      if (breakable && found) return found;\n    }\n    if (direction !== 'in') {\n      found = fn(\n        breakable,\n        nodeData.out,\n        callback,\n        !direction ? nodeData.key : undefined\n      );\n\n      if (breakable && found) return found;\n    }\n  }\n\n  if (type !== 'directed') {\n    found = fn(breakable, nodeData.undirected, callback);\n\n    if (breakable && found) return found;\n  }\n\n  return;\n}\n\n/**\n * Function creating an array of edges for the given type & the given node.\n *\n * @param  {boolean} multi     - Whether the graph is multi or not.\n * @param  {string}  type      - Type of edges to retrieve.\n * @param  {string}  direction - In or out?\n * @param  {any}     nodeData  - Target node's data.\n * @return {array}             - Array of edges.\n */\nfunction createEdgeArrayForNode(multi, type, direction, nodeData) {\n  const edges = []; // TODO: possibility to know size beforehand or factorize with map\n\n  forEachEdgeForNode(false, multi, type, direction, nodeData, function (key) {\n    edges.push(key);\n  });\n\n  return edges;\n}\n\n/**\n * Function iterating over a node's edges using a callback.\n *\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @return {Iterator}\n */\nfunction createEdgeIteratorForNode(type, direction, nodeData) {\n  let iterator = Iterator.empty();\n\n  if (type !== 'undirected') {\n    if (direction !== 'out' && typeof nodeData.in !== 'undefined')\n      iterator = chain(iterator, createIterator(nodeData.in));\n    if (direction !== 'in' && typeof nodeData.out !== 'undefined')\n      iterator = chain(\n        iterator,\n        createIterator(nodeData.out, !direction ? nodeData.key : undefined)\n      );\n  }\n\n  if (type !== 'directed' && typeof nodeData.undirected !== 'undefined') {\n    iterator = chain(iterator, createIterator(nodeData.undirected));\n  }\n\n  return iterator;\n}\n\n/**\n * Function iterating over edges for the given path using a callback to match\n * one of them.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {boolean}  multi      - Whether the graph is multi.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\nfunction forEachEdgeForPath(\n  breakable,\n  type,\n  multi,\n  direction,\n  sourceData,\n  target,\n  callback\n) {\n  const fn = multi ? forEachForKeyMulti : forEachForKeySimple;\n\n  let found;\n\n  if (type !== 'undirected') {\n    if (typeof sourceData.in !== 'undefined' && direction !== 'out') {\n      found = fn(breakable, sourceData.in, target, callback);\n\n      if (breakable && found) return found;\n    }\n\n    if (\n      typeof sourceData.out !== 'undefined' &&\n      direction !== 'in' &&\n      (direction || sourceData.key !== target)\n    ) {\n      found = fn(breakable, sourceData.out, target, callback);\n\n      if (breakable && found) return found;\n    }\n  }\n\n  if (type !== 'directed') {\n    if (typeof sourceData.undirected !== 'undefined') {\n      found = fn(breakable, sourceData.undirected, target, callback);\n\n      if (breakable && found) return found;\n    }\n  }\n\n  return;\n}\n\n/**\n * Function creating an array of edges for the given path.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {boolean}  multi      - Whether the graph is multi.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {any}      target     - Target node.\n * @return {array}               - Array of edges.\n */\nfunction createEdgeArrayForPath(type, multi, direction, sourceData, target) {\n  const edges = []; // TODO: possibility to know size beforehand or factorize with map\n\n  forEachEdgeForPath(\n    false,\n    type,\n    multi,\n    direction,\n    sourceData,\n    target,\n    function (key) {\n      edges.push(key);\n    }\n  );\n\n  return edges;\n}\n\n/**\n * Function returning an iterator over edges for the given path.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\nfunction createEdgeIteratorForPath(type, direction, sourceData, target) {\n  let iterator = Iterator.empty();\n\n  if (type !== 'undirected') {\n    if (\n      typeof sourceData.in !== 'undefined' &&\n      direction !== 'out' &&\n      target in sourceData.in\n    )\n      iterator = chain(iterator, createIteratorForKey(sourceData.in, target));\n\n    if (\n      typeof sourceData.out !== 'undefined' &&\n      direction !== 'in' &&\n      target in sourceData.out &&\n      (direction || sourceData.key !== target)\n    )\n      iterator = chain(iterator, createIteratorForKey(sourceData.out, target));\n  }\n\n  if (type !== 'directed') {\n    if (\n      typeof sourceData.undirected !== 'undefined' &&\n      target in sourceData.undirected\n    )\n      iterator = chain(\n        iterator,\n        createIteratorForKey(sourceData.undirected, target)\n      );\n  }\n\n  return iterator;\n}\n\n/**\n * Function attaching an edge array creator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachEdgeArrayCreator(Class, description) {\n  const {name, type, direction} = description;\n\n  /**\n   * Function returning an array of certain edges.\n   *\n   * Arity 0: Return all the relevant edges.\n   *\n   * Arity 1: Return all of a node's relevant edges.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Return the relevant edges across the given path.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The edges or the number of edges.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[name] = function (source, target) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return [];\n\n    if (!arguments.length) return createEdgeArray(this, type);\n\n    if (arguments.length === 1) {\n      source = '' + source;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(\n          `Graph.${name}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      return createEdgeArrayForNode(\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData\n      );\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return createEdgeArrayForPath(\n        type,\n        this.multi,\n        direction,\n        sourceData,\n        target\n      );\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`\n    );\n  };\n}\n\n/**\n * Function attaching a edge callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachForEachEdge(Class, description) {\n  const {name, type, direction} = description;\n\n  const forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over the graph's relevant edges by applying the given\n   * callback.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[forEachName] = function (source, target, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;\n\n    if (arguments.length === 1) {\n      callback = source;\n      return forEachEdge(false, this, type, callback);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      callback = target;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(\n          `Graph.${forEachName}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      // TODO: maybe attach the sub method to the instance dynamically?\n      return forEachEdgeForNode(\n        false,\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData,\n        callback\n      );\n    }\n\n    if (arguments.length === 3) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${forEachName}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${forEachName}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return forEachEdgeForPath(\n        false,\n        type,\n        this.multi,\n        direction,\n        sourceData,\n        target,\n        callback\n      );\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${forEachName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`\n    );\n  };\n\n  /**\n   * Function mapping the graph's relevant edges by applying the given\n   * callback.\n   *\n   * Arity 1: Map all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Map all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Map the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const mapName = 'map' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[mapName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    let result;\n\n    // We know the result length beforehand\n    if (args.length === 0) {\n      let length = 0;\n\n      if (type !== 'directed') length += this.undirectedSize;\n      if (type !== 'undirected') length += this.directedSize;\n\n      result = new Array(length);\n\n      let i = 0;\n\n      args.push((e, ea, s, t, sa, ta, u) => {\n        result[i++] = callback(e, ea, s, t, sa, ta, u);\n      });\n    }\n\n    // We don't know the result length beforehand\n    // TODO: we can in some instances of simple graphs, knowing degree\n    else {\n      result = [];\n\n      args.push((e, ea, s, t, sa, ta, u) => {\n        result.push(callback(e, ea, s, t, sa, ta, u));\n      });\n    }\n\n    this[forEachName].apply(this, args);\n\n    return result;\n  };\n\n  /**\n   * Function filtering the graph's relevant edges using the provided predicate\n   * function.\n   *\n   * Arity 1: Filter all the relevant edges.\n   * @param  {function} predicate - Predicate to use.\n   *\n   * Arity 2: Filter all of a node's relevant edges.\n   * @param  {any}      node      - Target node.\n   * @param  {function} predicate - Predicate to use.\n   *\n   * Arity 3: Filter the relevant edges across the given path.\n   * @param  {any}      source    - Source node.\n   * @param  {any}      target    - Target node.\n   * @param  {function} predicate - Predicate to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const filterName = 'filter' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[filterName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    const result = [];\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      if (callback(e, ea, s, t, sa, ta, u)) result.push(e);\n    });\n\n    this[forEachName].apply(this, args);\n\n    return result;\n  };\n\n  /**\n   * Function reducing the graph's relevant edges using the provided accumulator\n   * function.\n   *\n   * Arity 1: Reduce all the relevant edges.\n   * @param  {function} accumulator  - Accumulator to use.\n   * @param  {any}      initialValue - Initial value.\n   *\n   * Arity 2: Reduce all of a node's relevant edges.\n   * @param  {any}      node         - Target node.\n   * @param  {function} accumulator  - Accumulator to use.\n   * @param  {any}      initialValue - Initial value.\n   *\n   * Arity 3: Reduce the relevant edges across the given path.\n   * @param  {any}      source       - Source node.\n   * @param  {any}      target       - Target node.\n   * @param  {function} accumulator  - Accumulator to use.\n   * @param  {any}      initialValue - Initial value.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const reduceName = 'reduce' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[reduceName] = function () {\n    let args = Array.prototype.slice.call(arguments);\n\n    if (args.length < 2 || args.length > 4) {\n      throw new InvalidArgumentsGraphError(\n        `Graph.${reduceName}: invalid number of arguments (expecting 2, 3 or 4 and got ${args.length}).`\n      );\n    }\n\n    if (\n      typeof args[args.length - 1] === 'function' &&\n      typeof args[args.length - 2] !== 'function'\n    ) {\n      throw new InvalidArgumentsGraphError(\n        `Graph.${reduceName}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`\n      );\n    }\n\n    let callback;\n    let initialValue;\n\n    if (args.length === 2) {\n      callback = args[0];\n      initialValue = args[1];\n      args = [];\n    } else if (args.length === 3) {\n      callback = args[1];\n      initialValue = args[2];\n      args = [args[0]];\n    } else if (args.length === 4) {\n      callback = args[2];\n      initialValue = args[3];\n      args = [args[0], args[1]];\n    }\n\n    let accumulator = initialValue;\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      accumulator = callback(accumulator, e, ea, s, t, sa, ta, u);\n    });\n\n    this[forEachName].apply(this, args);\n\n    return accumulator;\n  };\n}\n\n/**\n * Function attaching a breakable edge callback iterator method to the Graph\n * prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachFindEdge(Class, description) {\n  const {name, type, direction} = description;\n\n  const findEdgeName = 'find' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over the graph's relevant edges in order to match\n   * one of them using the provided predicate function.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[findEdgeName] = function (source, target, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return false;\n\n    if (arguments.length === 1) {\n      callback = source;\n      return forEachEdge(true, this, type, callback);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      callback = target;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(\n          `Graph.${findEdgeName}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      // TODO: maybe attach the sub method to the instance dynamically?\n      return forEachEdgeForNode(\n        true,\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData,\n        callback\n      );\n    }\n\n    if (arguments.length === 3) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${findEdgeName}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${findEdgeName}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return forEachEdgeForPath(\n        true,\n        type,\n        this.multi,\n        direction,\n        sourceData,\n        target,\n        callback\n      );\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${findEdgeName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`\n    );\n  };\n\n  /**\n   * Function iterating over the graph's relevant edges in order to assert\n   * whether any one of them matches the provided predicate function.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const someName = 'some' + name[0].toUpperCase() + name.slice(1, -1);\n\n  Class.prototype[someName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      return callback(e, ea, s, t, sa, ta, u);\n    });\n\n    const found = this[findEdgeName].apply(this, args);\n\n    if (found) return true;\n\n    return false;\n  };\n\n  /**\n   * Function iterating over the graph's relevant edges in order to assert\n   * whether all of them matche the provided predicate function.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const everyName = 'every' + name[0].toUpperCase() + name.slice(1, -1);\n\n  Class.prototype[everyName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      return !callback(e, ea, s, t, sa, ta, u);\n    });\n\n    const found = this[findEdgeName].apply(this, args);\n\n    if (found) return false;\n\n    return true;\n  };\n}\n\n/**\n * Function attaching an edge iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachEdgeIteratorCreator(Class, description) {\n  const {name: originalName, type, direction} = description;\n\n  const name = originalName.slice(0, -1) + 'Entries';\n\n  /**\n   * Function returning an iterator over the graph's edges.\n   *\n   * Arity 0: Iterate over all the relevant edges.\n   *\n   * Arity 1: Iterate over all of a node's relevant edges.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Iterate over the relevant edges across the given path.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The edges or the number of edges.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[name] = function (source, target) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return Iterator.empty();\n\n    if (!arguments.length) return createEdgeIterator(this, type);\n\n    if (arguments.length === 1) {\n      source = '' + source;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${name}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      return createEdgeIteratorForNode(type, direction, sourceData);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return createEdgeIteratorForPath(type, direction, sourceData, target);\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`\n    );\n  };\n}\n\n/**\n * Function attaching every edge iteration method to the Graph class.\n *\n * @param {function} Graph - Graph class.\n */\nexport default function attachEdgeIterationMethods(Graph) {\n  EDGES_ITERATION.forEach(description => {\n    attachEdgeArrayCreator(Graph, description);\n    attachForEachEdge(Graph, description);\n    attachFindEdge(Graph, description);\n    attachEdgeIteratorCreator(Graph, description);\n  });\n}\n","/**\n * Graphology Neighbor Iteration\n * ==============================\n *\n * Attaching some methods to the Graph class to be able to iterate over\n * neighbors.\n */\nimport Iterator from 'obliterator/iterator';\nimport chain from 'obliterator/chain';\n\nimport {NotFoundGraphError, InvalidArgumentsGraphError} from '../errors';\n\n/**\n * Definitions.\n */\nconst NEIGHBORS_ITERATION = [\n  {\n    name: 'neighbors',\n    type: 'mixed'\n  },\n  {\n    name: 'inNeighbors',\n    type: 'directed',\n    direction: 'in'\n  },\n  {\n    name: 'outNeighbors',\n    type: 'directed',\n    direction: 'out'\n  },\n  {\n    name: 'inboundNeighbors',\n    type: 'mixed',\n    direction: 'in'\n  },\n  {\n    name: 'outboundNeighbors',\n    type: 'mixed',\n    direction: 'out'\n  },\n  {\n    name: 'directedNeighbors',\n    type: 'directed'\n  },\n  {\n    name: 'undirectedNeighbors',\n    type: 'undirected'\n  }\n];\n\n/**\n * Helpers.\n */\nfunction CompositeSetWrapper() {\n  this.A = null;\n  this.B = null;\n}\n\nCompositeSetWrapper.prototype.wrap = function (set) {\n  if (this.A === null) this.A = set;\n  else if (this.B === null) this.B = set;\n};\n\nCompositeSetWrapper.prototype.has = function (key) {\n  if (this.A !== null && key in this.A) return true;\n  if (this.B !== null && key in this.B) return true;\n  return false;\n};\n\n/**\n * Function iterating over the given node's relevant neighbors to match\n * one of them using a predicated function.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Callback to use.\n */\nfunction forEachInObjectOnce(breakable, visited, nodeData, object, callback) {\n  for (const k in object) {\n    const edgeData = object[k];\n\n    const sourceData = edgeData.source;\n    const targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    if (visited && visited.has(neighborData.key)) continue;\n\n    const shouldBreak = callback(neighborData.key, neighborData.attributes);\n\n    if (breakable && shouldBreak) return neighborData.key;\n  }\n\n  return;\n}\n\nfunction forEachNeighbor(breakable, type, direction, nodeData, callback) {\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return forEachInObjectOnce(\n        breakable,\n        null,\n        nodeData,\n        nodeData.undirected,\n        callback\n      );\n\n    if (typeof direction === 'string')\n      return forEachInObjectOnce(\n        breakable,\n        null,\n        nodeData,\n        nodeData[direction],\n        callback\n      );\n  }\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  // We cheat by querying the other adjacencies\n  const visited = new CompositeSetWrapper();\n\n  let found;\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      found = forEachInObjectOnce(\n        breakable,\n        null,\n        nodeData,\n        nodeData.in,\n        callback\n      );\n\n      if (breakable && found) return found;\n\n      visited.wrap(nodeData.in);\n    }\n    if (direction !== 'in') {\n      found = forEachInObjectOnce(\n        breakable,\n        visited,\n        nodeData,\n        nodeData.out,\n        callback\n      );\n\n      if (breakable && found) return found;\n\n      visited.wrap(nodeData.out);\n    }\n  }\n\n  if (type !== 'directed') {\n    found = forEachInObjectOnce(\n      breakable,\n      visited,\n      nodeData,\n      nodeData.undirected,\n      callback\n    );\n\n    if (breakable && found) return found;\n  }\n\n  return;\n}\n\n/**\n * Function creating an array of relevant neighbors for the given node.\n *\n * @param  {string}       type      - Type of neighbors.\n * @param  {string}       direction - Direction.\n * @param  {any}          nodeData  - Target node's data.\n * @return {Array}                  - The list of neighbors.\n */\nfunction createNeighborArrayForNode(type, direction, nodeData) {\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected') return Object.keys(nodeData.undirected);\n\n    if (typeof direction === 'string') return Object.keys(nodeData[direction]);\n  }\n\n  const neighbors = [];\n\n  forEachNeighbor(false, type, direction, nodeData, function (key) {\n    neighbors.push(key);\n  });\n\n  return neighbors;\n}\n\n/**\n * Function returning an iterator over the given node's relevant neighbors.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @return {Iterator}\n */\nfunction createDedupedObjectIterator(visited, nodeData, object) {\n  const keys = Object.keys(object);\n  const l = keys.length;\n\n  let i = 0;\n\n  return new Iterator(function next() {\n    let neighborData = null;\n\n    do {\n      if (i >= l) {\n        if (visited) visited.wrap(object);\n        return {done: true};\n      }\n\n      const edgeData = object[keys[i++]];\n\n      const sourceData = edgeData.source;\n      const targetData = edgeData.target;\n\n      neighborData = sourceData === nodeData ? targetData : sourceData;\n\n      if (visited && visited.has(neighborData.key)) {\n        neighborData = null;\n        continue;\n      }\n    } while (neighborData === null);\n\n    return {\n      done: false,\n      value: {neighbor: neighborData.key, attributes: neighborData.attributes}\n    };\n  });\n}\n\nfunction createNeighborIterator(type, direction, nodeData) {\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return createDedupedObjectIterator(null, nodeData, nodeData.undirected);\n\n    if (typeof direction === 'string')\n      return createDedupedObjectIterator(null, nodeData, nodeData[direction]);\n  }\n\n  let iterator = Iterator.empty();\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  // We cheat by querying the other adjacencies\n  const visited = new CompositeSetWrapper();\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      iterator = chain(\n        iterator,\n        createDedupedObjectIterator(visited, nodeData, nodeData.in)\n      );\n    }\n    if (direction !== 'in') {\n      iterator = chain(\n        iterator,\n        createDedupedObjectIterator(visited, nodeData, nodeData.out)\n      );\n    }\n  }\n\n  if (type !== 'directed') {\n    iterator = chain(\n      iterator,\n      createDedupedObjectIterator(visited, nodeData, nodeData.undirected)\n    );\n  }\n\n  return iterator;\n}\n\n/**\n * Function attaching a neighbors array creator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachNeighborArrayCreator(Class, description) {\n  const {name, type, direction} = description;\n\n  /**\n   * Function returning an array of certain neighbors.\n   *\n   * @param  {any}   node   - Target node.\n   * @return {array} - The neighbors of neighbors.\n   *\n   * @throws {Error} - Will throw if node is not found in the graph.\n   */\n  Class.prototype[name] = function (node) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return [];\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${name}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    return createNeighborArrayForNode(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData\n    );\n  };\n}\n\n/**\n * Function attaching a neighbors callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachForEachNeighbor(Class, description) {\n  const {name, type, direction} = description;\n\n  const forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over all the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[forEachName] = function (node, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${forEachName}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    forEachNeighbor(\n      false,\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData,\n      callback\n    );\n  };\n\n  /**\n   * Function mapping the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const mapName = 'map' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[mapName] = function (node, callback) {\n    // TODO: optimize when size is known beforehand\n    const result = [];\n\n    this[forEachName](node, (n, a) => {\n      result.push(callback(n, a));\n    });\n\n    return result;\n  };\n\n  /**\n   * Function filtering the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const filterName = 'filter' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[filterName] = function (node, callback) {\n    const result = [];\n\n    this[forEachName](node, (n, a) => {\n      if (callback(n, a)) result.push(n);\n    });\n\n    return result;\n  };\n\n  /**\n   * Function reducing the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const reduceName = 'reduce' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[reduceName] = function (node, callback, initialValue) {\n    if (arguments.length < 3)\n      throw new InvalidArgumentsGraphError(\n        `Graph.${reduceName}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`\n      );\n\n    let accumulator = initialValue;\n\n    this[forEachName](node, (n, a) => {\n      accumulator = callback(accumulator, n, a);\n    });\n\n    return accumulator;\n  };\n}\n\n/**\n * Function attaching a breakable neighbors callback iterator method to the\n * Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachFindNeighbor(Class, description) {\n  const {name, type, direction} = description;\n\n  const capitalizedSingular = name[0].toUpperCase() + name.slice(1, -1);\n\n  const findName = 'find' + capitalizedSingular;\n\n  /**\n   * Function iterating over all the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[findName] = function (node, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${findName}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    return forEachNeighbor(\n      true,\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData,\n      callback\n    );\n  };\n\n  /**\n   * Function iterating over all the relevant neighbors to find if any of them\n   * matches the given predicate.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const someName = 'some' + capitalizedSingular;\n\n  Class.prototype[someName] = function (node, callback) {\n    const found = this[findName](node, callback);\n\n    if (found) return true;\n\n    return false;\n  };\n\n  /**\n   * Function iterating over all the relevant neighbors to find if all of them\n   * matche the given predicate.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const everyName = 'every' + capitalizedSingular;\n\n  Class.prototype[everyName] = function (node, callback) {\n    const found = this[findName](node, (n, a) => {\n      return !callback(n, a);\n    });\n\n    if (found) return false;\n\n    return true;\n  };\n}\n\n/**\n * Function attaching a neighbors callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachNeighborIteratorCreator(Class, description) {\n  const {name, type, direction} = description;\n\n  const iteratorName = name.slice(0, -1) + 'Entries';\n\n  /**\n   * Function returning an iterator over all the relevant neighbors.\n   *\n   * @param  {any}      node     - Target node.\n   * @return {Iterator}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[iteratorName] = function (node) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return Iterator.empty();\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${iteratorName}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    return createNeighborIterator(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData\n    );\n  };\n}\n\n/**\n * Function attaching every neighbor iteration method to the Graph class.\n *\n * @param {function} Graph - Graph class.\n */\nexport default function attachNeighborIterationMethods(Graph) {\n  NEIGHBORS_ITERATION.forEach(description => {\n    attachNeighborArrayCreator(Graph, description);\n    attachForEachNeighbor(Graph, description);\n    attachFindNeighbor(Graph, description);\n    attachNeighborIteratorCreator(Graph, description);\n  });\n}\n","/**\n * Graphology Adjacency Iteration\n * ===============================\n *\n * Attaching some methods to the Graph class to be able to iterate over a\n * graph's adjacency.\n */\n\n/**\n * Function iterating over a simple graph's adjacency using a callback.\n *\n * @param {boolean}  breakable         - Can we break?\n * @param {boolean}  assymetric        - Whether to emit undirected edges only once.\n * @param {boolean}  disconnectedNodes - Whether to emit disconnected nodes.\n * @param {Graph}    graph             - Target Graph instance.\n * @param {callback} function          - Iteration callback.\n */\nexport function forEachAdjacency(\n  breakable,\n  assymetric,\n  disconnectedNodes,\n  graph,\n  callback\n) {\n  const iterator = graph._nodes.values();\n\n  const type = graph.type;\n\n  let step, sourceData, neighbor, adj, edgeData, targetData, shouldBreak;\n\n  while (((step = iterator.next()), step.done !== true)) {\n    let hasEdges = false;\n\n    sourceData = step.value;\n\n    if (type !== 'undirected') {\n      adj = sourceData.out;\n\n      for (neighbor in adj) {\n        edgeData = adj[neighbor];\n\n        do {\n          targetData = edgeData.target;\n\n          hasEdges = true;\n          shouldBreak = callback(\n            sourceData.key,\n            targetData.key,\n            sourceData.attributes,\n            targetData.attributes,\n            edgeData.key,\n            edgeData.attributes,\n            edgeData.undirected\n          );\n\n          if (breakable && shouldBreak) return edgeData;\n\n          edgeData = edgeData.next;\n        } while (edgeData);\n      }\n    }\n\n    if (type !== 'directed') {\n      adj = sourceData.undirected;\n\n      for (neighbor in adj) {\n        if (assymetric && sourceData.key > neighbor) continue;\n\n        edgeData = adj[neighbor];\n\n        do {\n          targetData = edgeData.target;\n\n          if (targetData.key !== neighbor) targetData = edgeData.source;\n\n          hasEdges = true;\n          shouldBreak = callback(\n            sourceData.key,\n            targetData.key,\n            sourceData.attributes,\n            targetData.attributes,\n            edgeData.key,\n            edgeData.attributes,\n            edgeData.undirected\n          );\n\n          if (breakable && shouldBreak) return edgeData;\n\n          edgeData = edgeData.next;\n        } while (edgeData);\n      }\n    }\n\n    if (disconnectedNodes && !hasEdges) {\n      shouldBreak = callback(\n        sourceData.key,\n        null,\n        sourceData.attributes,\n        null,\n        null,\n        null,\n        null\n      );\n\n      if (breakable && shouldBreak) return null;\n    }\n  }\n\n  return;\n}\n","/**\n * Graphology Serialization Utilities\n * ===================================\n *\n * Collection of functions used by the graph serialization schemes.\n */\nimport {InvalidArgumentsGraphError} from './errors';\nimport {assign, isPlainObject, isEmpty} from './utils';\n\n/**\n * Formats internal node data into a serialized node.\n *\n * @param  {any}    key  - The node's key.\n * @param  {object} data - Internal node's data.\n * @return {array}       - The serialized node.\n */\nexport function serializeNode(key, data) {\n  const serialized = {key};\n\n  if (!isEmpty(data.attributes))\n    serialized.attributes = assign({}, data.attributes);\n\n  return serialized;\n}\n\n/**\n * Formats internal edge data into a serialized edge.\n *\n * @param  {string} type - The graph's type.\n * @param  {any}    key  - The edge's key.\n * @param  {object} data - Internal edge's data.\n * @return {array}       - The serialized edge.\n */\nexport function serializeEdge(type, key, data) {\n  const serialized = {\n    key,\n    source: data.source.key,\n    target: data.target.key\n  };\n\n  if (!isEmpty(data.attributes))\n    serialized.attributes = assign({}, data.attributes);\n\n  if (type === 'mixed' && data.undirected) serialized.undirected = true;\n\n  return serialized;\n}\n\n/**\n * Checks whether the given value is a serialized node.\n *\n * @param  {mixed} value - Target value.\n * @return {string|null}\n */\nexport function validateSerializedNode(value) {\n  if (!isPlainObject(value))\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: invalid serialized node. A serialized node should be a plain object with at least a \"key\" property.'\n    );\n\n  if (!('key' in value))\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: serialized node is missing its key.'\n    );\n\n  if (\n    'attributes' in value &&\n    (!isPlainObject(value.attributes) || value.attributes === null)\n  )\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.'\n    );\n}\n\n/**\n * Checks whether the given value is a serialized edge.\n *\n * @param  {mixed} value - Target value.\n * @return {string|null}\n */\nexport function validateSerializedEdge(value) {\n  if (!isPlainObject(value))\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: invalid serialized edge. A serialized edge should be a plain object with at least a \"source\" & \"target\" property.'\n    );\n\n  if (!('source' in value))\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: serialized edge is missing its source.'\n    );\n\n  if (!('target' in value))\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: serialized edge is missing its target.'\n    );\n\n  if (\n    'attributes' in value &&\n    (!isPlainObject(value.attributes) || value.attributes === null)\n  )\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.'\n    );\n\n  if ('undirected' in value && typeof value.undirected !== 'boolean')\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: invalid undirectedness information. Undirected should be boolean or omitted.'\n    );\n}\n","/* eslint no-nested-ternary: 0 */\n/**\n * Graphology Reference Implementation\n * ====================================\n *\n * Reference implementation of the graphology specs.\n */\nimport {EventEmitter} from 'events';\nimport Iterator from 'obliterator/iterator';\nimport take from 'obliterator/take';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from './errors';\n\nimport {\n  MixedNodeData,\n  DirectedNodeData,\n  UndirectedNodeData,\n  EdgeData\n} from './data';\n\nimport attachNodeAttributesMethods from './attributes/nodes';\nimport attachEdgeAttributesMethods from './attributes/edges';\nimport attachEdgeIterationMethods from './iteration/edges';\nimport attachNeighborIterationMethods from './iteration/neighbors';\nimport {forEachAdjacency} from './iteration/adjacency';\n\nimport {\n  serializeNode,\n  serializeEdge,\n  validateSerializedNode,\n  validateSerializedEdge\n} from './serialization';\n\nimport {\n  assign,\n  getMatchingEdge,\n  isPlainObject,\n  privateProperty,\n  readOnlyProperty,\n  incrementalIdStartingFromRandomByte,\n  validateHints\n} from './utils';\n\n/**\n * Constants.\n */\nconst INSTANCE_ID = incrementalIdStartingFromRandomByte();\n\n/**\n * Enums.\n */\nconst TYPES = new Set(['directed', 'undirected', 'mixed']);\n\nconst EMITTER_PROPS = new Set([\n  'domain',\n  '_events',\n  '_eventsCount',\n  '_maxListeners'\n]);\n\nconst EDGE_ADD_METHODS = [\n  {\n    name: verb => `${verb}Edge`,\n    generateKey: true\n  },\n  {\n    name: verb => `${verb}DirectedEdge`,\n    generateKey: true,\n    type: 'directed'\n  },\n  {\n    name: verb => `${verb}UndirectedEdge`,\n    generateKey: true,\n    type: 'undirected'\n  },\n  {\n    name: verb => `${verb}EdgeWithKey`\n  },\n  {\n    name: verb => `${verb}DirectedEdgeWithKey`,\n    type: 'directed'\n  },\n  {\n    name: verb => `${verb}UndirectedEdgeWithKey`,\n    type: 'undirected'\n  }\n];\n\n/**\n * Default options.\n */\nconst DEFAULTS = {\n  allowSelfLoops: true,\n  multi: false,\n  type: 'mixed'\n};\n\n/**\n * Abstract functions used by the Graph class for various methods.\n */\n\n/**\n * Internal method used to add a node to the given graph\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {any}     node            - The node's key.\n * @param  {object}  [attributes]    - Optional attributes.\n * @return {NodeData}                - Created node data.\n */\nfunction addNode(graph, node, attributes) {\n  if (attributes && !isPlainObject(attributes))\n    throw new InvalidArgumentsGraphError(\n      `Graph.addNode: invalid attributes. Expecting an object but got \"${attributes}\"`\n    );\n\n  // String coercion\n  node = '' + node;\n  attributes = attributes || {};\n\n  if (graph._nodes.has(node))\n    throw new UsageGraphError(\n      `Graph.addNode: the \"${node}\" node already exist in the graph.`\n    );\n\n  const data = new graph.NodeDataClass(node, attributes);\n\n  // Adding the node to internal register\n  graph._nodes.set(node, data);\n\n  // Emitting\n  graph.emit('nodeAdded', {\n    key: node,\n    attributes\n  });\n\n  return data;\n}\n\n/**\n * Same as the above but without sanity checks because we call this in contexts\n * where necessary checks were already done.\n */\nfunction unsafeAddNode(graph, node, attributes) {\n  const data = new graph.NodeDataClass(node, attributes);\n\n  graph._nodes.set(node, data);\n\n  graph.emit('nodeAdded', {\n    key: node,\n    attributes\n  });\n\n  return data;\n}\n\n/**\n * Internal method used to add an arbitrary edge to the given graph.\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {string}  name            - Name of the child method for errors.\n * @param  {boolean} mustGenerateKey - Should the graph generate an id?\n * @param  {boolean} undirected      - Whether the edge is undirected.\n * @param  {any}     edge            - The edge's key.\n * @param  {any}     source          - The source node.\n * @param  {any}     target          - The target node.\n * @param  {object}  [attributes]    - Optional attributes.\n * @return {any}                     - The edge.\n *\n * @throws {Error} - Will throw if the graph is of the wrong type.\n * @throws {Error} - Will throw if the given attributes are not an object.\n * @throws {Error} - Will throw if source or target doesn't exist.\n * @throws {Error} - Will throw if the edge already exist.\n */\nfunction addEdge(\n  graph,\n  name,\n  mustGenerateKey,\n  undirected,\n  edge,\n  source,\n  target,\n  attributes\n) {\n  // Checking validity of operation\n  if (!undirected && graph.type === 'undirected')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`\n    );\n\n  if (undirected && graph.type === 'directed')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`\n    );\n\n  if (attributes && !isPlainObject(attributes))\n    throw new InvalidArgumentsGraphError(\n      `Graph.${name}: invalid attributes. Expecting an object but got \"${attributes}\"`\n    );\n\n  // Coercion of source & target:\n  source = '' + source;\n  target = '' + target;\n  attributes = attributes || {};\n\n  if (!graph.allowSelfLoops && source === target)\n    throw new UsageGraphError(\n      `Graph.${name}: source & target are the same (\"${source}\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`\n    );\n\n  const sourceData = graph._nodes.get(source),\n    targetData = graph._nodes.get(target);\n\n  if (!sourceData)\n    throw new NotFoundGraphError(\n      `Graph.${name}: source node \"${source}\" not found.`\n    );\n\n  if (!targetData)\n    throw new NotFoundGraphError(\n      `Graph.${name}: target node \"${target}\" not found.`\n    );\n\n  // Must the graph generate an id for this edge?\n  const eventData = {\n    key: null,\n    undirected,\n    source,\n    target,\n    attributes\n  };\n\n  if (mustGenerateKey) {\n    // NOTE: in this case we can guarantee that the key does not already\n    // exist and is already correctly casted as a string\n    edge = graph._edgeKeyGenerator();\n  } else {\n    // Coercion of edge key\n    edge = '' + edge;\n\n    // Here, we have a key collision\n    if (graph._edges.has(edge))\n      throw new UsageGraphError(\n        `Graph.${name}: the \"${edge}\" edge already exists in the graph.`\n      );\n  }\n\n  // Here, we might have a source / target collision\n  if (\n    !graph.multi &&\n    (undirected\n      ? typeof sourceData.undirected[target] !== 'undefined'\n      : typeof sourceData.out[target] !== 'undefined')\n  ) {\n    throw new UsageGraphError(\n      `Graph.${name}: an edge linking \"${source}\" to \"${target}\" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`\n    );\n  }\n\n  // Storing some data\n  const edgeData = new EdgeData(\n    undirected,\n    edge,\n    sourceData,\n    targetData,\n    attributes\n  );\n\n  // Adding the edge to the internal register\n  graph._edges.set(edge, edgeData);\n\n  // Incrementing node degree counters\n  const isSelfLoop = source === target;\n\n  if (undirected) {\n    sourceData.undirectedDegree++;\n    targetData.undirectedDegree++;\n\n    if (isSelfLoop) {\n      sourceData.undirectedLoops++;\n      graph._undirectedSelfLoopCount++;\n    }\n  } else {\n    sourceData.outDegree++;\n    targetData.inDegree++;\n\n    if (isSelfLoop) {\n      sourceData.directedLoops++;\n      graph._directedSelfLoopCount++;\n    }\n  }\n\n  // Updating relevant index\n  if (graph.multi) edgeData.attachMulti();\n  else edgeData.attach();\n\n  if (undirected) graph._undirectedSize++;\n  else graph._directedSize++;\n\n  // Emitting\n  eventData.key = edge;\n\n  graph.emit('edgeAdded', eventData);\n\n  return edge;\n}\n\n/**\n * Internal method used to add an arbitrary edge to the given graph.\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {string}  name            - Name of the child method for errors.\n * @param  {boolean} mustGenerateKey - Should the graph generate an id?\n * @param  {boolean} undirected      - Whether the edge is undirected.\n * @param  {any}     edge            - The edge's key.\n * @param  {any}     source          - The source node.\n * @param  {any}     target          - The target node.\n * @param  {object}  [attributes]    - Optional attributes.\n * @param  {boolean} [asUpdater]       - Are we updating or merging?\n * @return {any}                     - The edge.\n *\n * @throws {Error} - Will throw if the graph is of the wrong type.\n * @throws {Error} - Will throw if the given attributes are not an object.\n * @throws {Error} - Will throw if source or target doesn't exist.\n * @throws {Error} - Will throw if the edge already exist.\n */\nfunction mergeEdge(\n  graph,\n  name,\n  mustGenerateKey,\n  undirected,\n  edge,\n  source,\n  target,\n  attributes,\n  asUpdater\n) {\n  // Checking validity of operation\n  if (!undirected && graph.type === 'undirected')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead.`\n    );\n\n  if (undirected && graph.type === 'directed')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead.`\n    );\n\n  if (attributes) {\n    if (asUpdater) {\n      if (typeof attributes !== 'function')\n        throw new InvalidArgumentsGraphError(\n          `Graph.${name}: invalid updater function. Expecting a function but got \"${attributes}\"`\n        );\n    } else {\n      if (!isPlainObject(attributes))\n        throw new InvalidArgumentsGraphError(\n          `Graph.${name}: invalid attributes. Expecting an object but got \"${attributes}\"`\n        );\n    }\n  }\n\n  // Coercion of source & target:\n  source = '' + source;\n  target = '' + target;\n\n  let updater;\n\n  if (asUpdater) {\n    updater = attributes;\n    attributes = undefined;\n  }\n\n  if (!graph.allowSelfLoops && source === target)\n    throw new UsageGraphError(\n      `Graph.${name}: source & target are the same (\"${source}\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`\n    );\n\n  let sourceData = graph._nodes.get(source);\n  let targetData = graph._nodes.get(target);\n  let edgeData;\n\n  // Do we need to handle duplicate?\n  let alreadyExistingEdgeData;\n\n  if (!mustGenerateKey) {\n    edgeData = graph._edges.get(edge);\n\n    if (edgeData) {\n      // Here, we need to ensure, if the user gave a key, that source & target\n      // are consistent\n      if (edgeData.source.key !== source || edgeData.target.key !== target) {\n        // If source or target inconsistent\n        if (\n          !undirected ||\n          edgeData.source.key !== target ||\n          edgeData.target.key !== source\n        ) {\n          // If directed, or source/target aren't flipped\n          throw new UsageGraphError(\n            `Graph.${name}: inconsistency detected when attempting to merge the \"${edge}\" edge with \"${source}\" source & \"${target}\" target vs. (\"${edgeData.source.key}\", \"${edgeData.target.key}\").`\n          );\n        }\n      }\n\n      alreadyExistingEdgeData = edgeData;\n    }\n  }\n\n  // Here, we might have a source / target collision\n  if (!alreadyExistingEdgeData && !graph.multi && sourceData) {\n    alreadyExistingEdgeData = undirected\n      ? sourceData.undirected[target]\n      : sourceData.out[target];\n  }\n\n  // Handling duplicates\n  if (alreadyExistingEdgeData) {\n    const info = [alreadyExistingEdgeData.key, false, false, false];\n\n    // We can skip the attribute merging part if the user did not provide them\n    if (asUpdater ? !updater : !attributes) return info;\n\n    // Updating the attributes\n    if (asUpdater) {\n      const oldAttributes = alreadyExistingEdgeData.attributes;\n      alreadyExistingEdgeData.attributes = updater(oldAttributes);\n\n      graph.emit('edgeAttributesUpdated', {\n        type: 'replace',\n        key: alreadyExistingEdgeData.key,\n        attributes: alreadyExistingEdgeData.attributes\n      });\n    }\n\n    // Merging the attributes\n    else {\n      assign(alreadyExistingEdgeData.attributes, attributes);\n\n      graph.emit('edgeAttributesUpdated', {\n        type: 'merge',\n        key: alreadyExistingEdgeData.key,\n        attributes: alreadyExistingEdgeData.attributes,\n        data: attributes\n      });\n    }\n\n    return info;\n  }\n\n  attributes = attributes || {};\n\n  if (asUpdater && updater) attributes = updater(attributes);\n\n  // Must the graph generate an id for this edge?\n  const eventData = {\n    key: null,\n    undirected,\n    source,\n    target,\n    attributes\n  };\n\n  if (mustGenerateKey) {\n    // NOTE: in this case we can guarantee that the key does not already\n    // exist and is already correctly casted as a string\n    edge = graph._edgeKeyGenerator();\n  } else {\n    // Coercion of edge key\n    edge = '' + edge;\n\n    // Here, we have a key collision\n    if (graph._edges.has(edge))\n      throw new UsageGraphError(\n        `Graph.${name}: the \"${edge}\" edge already exists in the graph.`\n      );\n  }\n\n  let sourceWasAdded = false;\n  let targetWasAdded = false;\n\n  if (!sourceData) {\n    sourceData = unsafeAddNode(graph, source, {});\n    sourceWasAdded = true;\n\n    if (source === target) {\n      targetData = sourceData;\n      targetWasAdded = true;\n    }\n  }\n  if (!targetData) {\n    targetData = unsafeAddNode(graph, target, {});\n    targetWasAdded = true;\n  }\n\n  // Storing some data\n  edgeData = new EdgeData(undirected, edge, sourceData, targetData, attributes);\n\n  // Adding the edge to the internal register\n  graph._edges.set(edge, edgeData);\n\n  // Incrementing node degree counters\n  const isSelfLoop = source === target;\n\n  if (undirected) {\n    sourceData.undirectedDegree++;\n    targetData.undirectedDegree++;\n\n    if (isSelfLoop) {\n      sourceData.undirectedLoops++;\n      graph._undirectedSelfLoopCount++;\n    }\n  } else {\n    sourceData.outDegree++;\n    targetData.inDegree++;\n\n    if (isSelfLoop) {\n      sourceData.directedLoops++;\n      graph._directedSelfLoopCount++;\n    }\n  }\n\n  // Updating relevant index\n  if (graph.multi) edgeData.attachMulti();\n  else edgeData.attach();\n\n  if (undirected) graph._undirectedSize++;\n  else graph._directedSize++;\n\n  // Emitting\n  eventData.key = edge;\n\n  graph.emit('edgeAdded', eventData);\n\n  return [edge, true, sourceWasAdded, targetWasAdded];\n}\n\n/**\n * Internal method used to drop an edge.\n *\n * @param  {Graph}    graph    - Target graph.\n * @param  {EdgeData} edgeData - Data of the edge to drop.\n */\nfunction dropEdgeFromData(graph, edgeData) {\n  // Dropping the edge from the register\n  graph._edges.delete(edgeData.key);\n\n  // Updating related degrees\n  const {source: sourceData, target: targetData, attributes} = edgeData;\n\n  const undirected = edgeData.undirected;\n\n  const isSelfLoop = sourceData === targetData;\n\n  if (undirected) {\n    sourceData.undirectedDegree--;\n    targetData.undirectedDegree--;\n\n    if (isSelfLoop) {\n      sourceData.undirectedLoops--;\n      graph._undirectedSelfLoopCount--;\n    }\n  } else {\n    sourceData.outDegree--;\n    targetData.inDegree--;\n\n    if (isSelfLoop) {\n      sourceData.directedLoops--;\n      graph._directedSelfLoopCount--;\n    }\n  }\n\n  // Clearing index\n  if (graph.multi) edgeData.detachMulti();\n  else edgeData.detach();\n\n  if (undirected) graph._undirectedSize--;\n  else graph._directedSize--;\n\n  // Emitting\n  graph.emit('edgeDropped', {\n    key: edgeData.key,\n    attributes,\n    source: sourceData.key,\n    target: targetData.key,\n    undirected\n  });\n}\n\n/**\n * Graph class\n *\n * @constructor\n * @param  {object}  [options] - Options:\n * @param  {boolean}   [allowSelfLoops] - Allow self loops?\n * @param  {string}    [type]           - Type of the graph.\n * @param  {boolean}   [map]            - Allow references as keys?\n * @param  {boolean}   [multi]          - Allow parallel edges?\n *\n * @throws {Error} - Will throw if the arguments are not valid.\n */\nexport default class Graph extends EventEmitter {\n  constructor(options) {\n    super();\n\n    //-- Solving options\n    options = assign({}, DEFAULTS, options);\n\n    // Enforcing options validity\n    if (typeof options.multi !== 'boolean')\n      throw new InvalidArgumentsGraphError(\n        `Graph.constructor: invalid 'multi' option. Expecting a boolean but got \"${options.multi}\".`\n      );\n\n    if (!TYPES.has(options.type))\n      throw new InvalidArgumentsGraphError(\n        `Graph.constructor: invalid 'type' option. Should be one of \"mixed\", \"directed\" or \"undirected\" but got \"${options.type}\".`\n      );\n\n    if (typeof options.allowSelfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(\n        `Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got \"${options.allowSelfLoops}\".`\n      );\n\n    //-- Private properties\n\n    // Utilities\n    const NodeDataClass =\n      options.type === 'mixed'\n        ? MixedNodeData\n        : options.type === 'directed'\n        ? DirectedNodeData\n        : UndirectedNodeData;\n\n    privateProperty(this, 'NodeDataClass', NodeDataClass);\n\n    // Internal edge key generator\n\n    // NOTE: this internal generator produce keys that are strings\n    // composed of a weird prefix, an incremental instance id starting from\n    // a random byte and finally an internal instance incremental id.\n    // All this to avoid intra-frame and cross-frame adversarial inputs\n    // that can force a single #.addEdge call to degenerate into a O(n)\n    // available key search loop.\n\n    // It also ensures that automatically generated edge keys are unlikely\n    // to produce collisions with arbitrary keys given by users.\n    const instancePrefix = 'geid_' + INSTANCE_ID() + '_';\n    let edgeId = 0;\n\n    const edgeKeyGenerator = () => {\n      let availableEdgeKey;\n\n      do {\n        availableEdgeKey = instancePrefix + edgeId++;\n      } while (this._edges.has(availableEdgeKey));\n\n      return availableEdgeKey;\n    };\n\n    // Indexes\n    privateProperty(this, '_attributes', {});\n    privateProperty(this, '_nodes', new Map());\n    privateProperty(this, '_edges', new Map());\n    privateProperty(this, '_directedSize', 0);\n    privateProperty(this, '_undirectedSize', 0);\n    privateProperty(this, '_directedSelfLoopCount', 0);\n    privateProperty(this, '_undirectedSelfLoopCount', 0);\n    privateProperty(this, '_edgeKeyGenerator', edgeKeyGenerator);\n\n    // Options\n    privateProperty(this, '_options', options);\n\n    // Emitter properties\n    EMITTER_PROPS.forEach(prop => privateProperty(this, prop, this[prop]));\n\n    //-- Properties readers\n    readOnlyProperty(this, 'order', () => this._nodes.size);\n    readOnlyProperty(this, 'size', () => this._edges.size);\n    readOnlyProperty(this, 'directedSize', () => this._directedSize);\n    readOnlyProperty(this, 'undirectedSize', () => this._undirectedSize);\n    readOnlyProperty(\n      this,\n      'selfLoopCount',\n      () => this._directedSelfLoopCount + this._undirectedSelfLoopCount\n    );\n    readOnlyProperty(\n      this,\n      'directedSelfLoopCount',\n      () => this._directedSelfLoopCount\n    );\n    readOnlyProperty(\n      this,\n      'undirectedSelfLoopCount',\n      () => this._undirectedSelfLoopCount\n    );\n    readOnlyProperty(this, 'multi', this._options.multi);\n    readOnlyProperty(this, 'type', this._options.type);\n    readOnlyProperty(this, 'allowSelfLoops', this._options.allowSelfLoops);\n    readOnlyProperty(this, 'implementation', () => 'graphology');\n  }\n\n  _resetInstanceCounters() {\n    this._directedSize = 0;\n    this._undirectedSize = 0;\n    this._directedSelfLoopCount = 0;\n    this._undirectedSelfLoopCount = 0;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Read\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning whether the given node is found in the graph.\n   *\n   * @param  {any}     node - The node.\n   * @return {boolean}\n   */\n  hasNode(node) {\n    return this._nodes.has('' + node);\n  }\n\n  /**\n   * Method returning whether the given directed edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasDirectedEdge(source, target) {\n    // Early termination\n    if (this.type === 'undirected') return false;\n\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      const edgeData = this._edges.get(edge);\n\n      return !!edgeData && !edgeData.undirected;\n    } else if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData) return false;\n\n      // Is there a directed edge pointing toward target?\n      return nodeData.out.hasOwnProperty(target);\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`\n    );\n  }\n\n  /**\n   * Method returning whether the given undirected edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasUndirectedEdge(source, target) {\n    // Early termination\n    if (this.type === 'directed') return false;\n\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      const edgeData = this._edges.get(edge);\n\n      return !!edgeData && edgeData.undirected;\n    } else if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData) return false;\n\n      // Is there a directed edge pointing toward target?\n      return nodeData.undirected.hasOwnProperty(target);\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`\n    );\n  }\n\n  /**\n   * Method returning whether the given edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasEdge(source, target) {\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      return this._edges.has(edge);\n    } else if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData) return false;\n\n      // Is there a directed edge pointing toward target?\n      return (\n        (typeof nodeData.out !== 'undefined' &&\n          nodeData.out.hasOwnProperty(target)) ||\n        (typeof nodeData.undirected !== 'undefined' &&\n          nodeData.undirected.hasOwnProperty(target))\n      );\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.hasEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`\n    );\n  }\n\n  /**\n   * Method returning the edge matching source & target in a directed fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  directedEdge(source, target) {\n    if (this.type === 'undirected') return;\n\n    source = '' + source;\n    target = '' + target;\n\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.'\n      );\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(\n        `Graph.directedEdge: could not find the \"${source}\" source node in the graph.`\n      );\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(\n        `Graph.directedEdge: could not find the \"${target}\" target node in the graph.`\n      );\n\n    const edgeData = (sourceData.out && sourceData.out[target]) || undefined;\n\n    if (edgeData) return edgeData.key;\n  }\n\n  /**\n   * Method returning the edge matching source & target in a undirected fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  undirectedEdge(source, target) {\n    if (this.type === 'directed') return;\n\n    source = '' + source;\n    target = '' + target;\n\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.'\n      );\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(\n        `Graph.undirectedEdge: could not find the \"${source}\" source node in the graph.`\n      );\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(\n        `Graph.undirectedEdge: could not find the \"${target}\" target node in the graph.`\n      );\n\n    const edgeData =\n      (sourceData.undirected && sourceData.undirected[target]) || undefined;\n\n    if (edgeData) return edgeData.key;\n  }\n\n  /**\n   * Method returning the edge matching source & target in a mixed fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  edge(source, target) {\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.'\n      );\n\n    source = '' + source;\n    target = '' + target;\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(\n        `Graph.edge: could not find the \"${source}\" source node in the graph.`\n      );\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(\n        `Graph.edge: could not find the \"${target}\" target node in the graph.`\n      );\n\n    const edgeData =\n      (sourceData.out && sourceData.out[target]) ||\n      (sourceData.undirected && sourceData.undirected[target]) ||\n      undefined;\n\n    if (edgeData) return edgeData.key;\n  }\n\n  /**\n   * Method returning whether two nodes are directed neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areDirectedNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areDirectedNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return false;\n\n    return neighbor in nodeData.in || neighbor in nodeData.out;\n  }\n\n  /**\n   * Method returning whether two nodes are out neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areOutNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areOutNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return false;\n\n    return neighbor in nodeData.out;\n  }\n\n  /**\n   * Method returning whether two nodes are in neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areInNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areInNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return false;\n\n    return neighbor in nodeData.in;\n  }\n\n  /**\n   * Method returning whether two nodes are undirected neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areUndirectedNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areUndirectedNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'directed') return false;\n\n    return neighbor in nodeData.undirected;\n  }\n\n  /**\n   * Method returning whether two nodes are neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type !== 'undirected') {\n      if (neighbor in nodeData.in || neighbor in nodeData.out) return true;\n    }\n\n    if (this.type !== 'directed') {\n      if (neighbor in nodeData.undirected) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning whether two nodes are inbound neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areInboundNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areInboundNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type !== 'undirected') {\n      if (neighbor in nodeData.in) return true;\n    }\n\n    if (this.type !== 'directed') {\n      if (neighbor in nodeData.undirected) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning whether two nodes are outbound neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areOutboundNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areOutboundNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type !== 'undirected') {\n      if (neighbor in nodeData.out) return true;\n    }\n\n    if (this.type !== 'directed') {\n      if (neighbor in nodeData.undirected) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning the given node's in degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.inDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.inDegree;\n  }\n\n  /**\n   * Method returning the given node's out degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.outDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.outDegree;\n  }\n\n  /**\n   * Method returning the given node's directed degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  directedDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.directedDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.inDegree + nodeData.outDegree;\n  }\n\n  /**\n   * Method returning the given node's undirected degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  undirectedDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.undirectedDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'directed') return 0;\n\n    return nodeData.undirectedDegree;\n  }\n\n  /**\n   * Method returning the given node's inbound degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's inbound degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inboundDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.inboundDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.inDegree;\n    }\n\n    return degree;\n  }\n\n  /**\n   * Method returning the given node's outbound degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's outbound degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outboundDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.outboundDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.outDegree;\n    }\n\n    return degree;\n  }\n\n  /**\n   * Method returning the given node's directed degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  degree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.degree: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.inDegree + nodeData.outDegree;\n    }\n\n    return degree;\n  }\n\n  /**\n   * Method returning the given node's in degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.inDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.inDegree - nodeData.directedLoops;\n  }\n\n  /**\n   * Method returning the given node's out degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.outDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.outDegree - nodeData.directedLoops;\n  }\n\n  /**\n   * Method returning the given node's directed degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  directedDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.directedDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.inDegree + nodeData.outDegree - nodeData.directedLoops * 2;\n  }\n\n  /**\n   * Method returning the given node's undirected degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  undirectedDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.undirectedDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'directed') return 0;\n\n    return nodeData.undirectedDegree - nodeData.undirectedLoops * 2;\n  }\n\n  /**\n   * Method returning the given node's inbound degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's inbound degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inboundDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.inboundDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n    let loops = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n      loops += nodeData.undirectedLoops * 2;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.inDegree;\n      loops += nodeData.directedLoops;\n    }\n\n    return degree - loops;\n  }\n\n  /**\n   * Method returning the given node's outbound degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's outbound degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outboundDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.outboundDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n    let loops = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n      loops += nodeData.undirectedLoops * 2;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.outDegree;\n      loops += nodeData.directedLoops;\n    }\n\n    return degree - loops;\n  }\n\n  /**\n   * Method returning the given node's directed degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  degreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.degreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n    let loops = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n      loops += nodeData.undirectedLoops * 2;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.inDegree + nodeData.outDegree;\n      loops += nodeData.directedLoops * 2;\n    }\n\n    return degree - loops;\n  }\n\n  /**\n   * Method returning the given edge's source.\n   *\n   * @param  {any} edge - The edge's key.\n   * @return {any}      - The edge's source.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  source(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.source: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.source.key;\n  }\n\n  /**\n   * Method returning the given edge's target.\n   *\n   * @param  {any} edge - The edge's key.\n   * @return {any}      - The edge's target.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  target(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.target: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.target.key;\n  }\n\n  /**\n   * Method returning the given edge's extremities.\n   *\n   * @param  {any}   edge - The edge's key.\n   * @return {array}      - The edge's extremities.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  extremities(edge) {\n    edge = '' + edge;\n\n    const edgeData = this._edges.get(edge);\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.extremities: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return [edgeData.source.key, edgeData.target.key];\n  }\n\n  /**\n   * Given a node & an edge, returns the other extremity of the edge.\n   *\n   * @param  {any}   node - The node's key.\n   * @param  {any}   edge - The edge's key.\n   * @return {any}        - The related node.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph or if the\n   *                   edge & node are not related.\n   */\n  opposite(node, edge) {\n    node = '' + node;\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.opposite: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    const source = data.source.key;\n    const target = data.target.key;\n\n    if (node === source) return target;\n    if (node === target) return source;\n\n    throw new NotFoundGraphError(\n      `Graph.opposite: the \"${node}\" node is not attached to the \"${edge}\" edge (${source}, ${target}).`\n    );\n  }\n\n  /**\n   * Returns whether the given edge has the given node as extremity.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @param  {any}     node - The node's key.\n   * @return {boolean}      - The related node.\n   *\n   * @throws {Error} - Will throw if either the node or the edge isn't in the graph.\n   */\n  hasExtremity(edge, node) {\n    edge = '' + edge;\n    node = '' + node;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.hasExtremity: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.source.key === node || data.target.key === node;\n  }\n\n  /**\n   * Method returning whether the given edge is undirected.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isUndirected(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.isUndirected: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.undirected;\n  }\n\n  /**\n   * Method returning whether the given edge is directed.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isDirected(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.isDirected: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return !data.undirected;\n  }\n\n  /**\n   * Method returning whether the given edge is a self loop.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isSelfLoop(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.isSelfLoop: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.source === data.target;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Mutation\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used to add a node to the graph.\n   *\n   * @param  {any}    node         - The node.\n   * @param  {object} [attributes] - Optional attributes.\n   * @return {any}                 - The node.\n   *\n   * @throws {Error} - Will throw if the given node already exist.\n   * @throws {Error} - Will throw if the given attributes are not an object.\n   */\n  addNode(node, attributes) {\n    const nodeData = addNode(this, node, attributes);\n\n    return nodeData.key;\n  }\n\n  /**\n   * Method used to merge a node into the graph.\n   *\n   * @param  {any}    node         - The node.\n   * @param  {object} [attributes] - Optional attributes.\n   * @return {any}                 - The node.\n   */\n  mergeNode(node, attributes) {\n    if (attributes && !isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.mergeNode: invalid attributes. Expecting an object but got \"${attributes}\"`\n      );\n\n    // String coercion\n    node = '' + node;\n    attributes = attributes || {};\n\n    // If the node already exists, we merge the attributes\n    let data = this._nodes.get(node);\n\n    if (data) {\n      if (attributes) {\n        assign(data.attributes, attributes);\n\n        this.emit('nodeAttributesUpdated', {\n          type: 'merge',\n          key: node,\n          attributes: data.attributes,\n          data: attributes\n        });\n      }\n      return [node, false];\n    }\n\n    data = new this.NodeDataClass(node, attributes);\n\n    // Adding the node to internal register\n    this._nodes.set(node, data);\n\n    // Emitting\n    this.emit('nodeAdded', {\n      key: node,\n      attributes\n    });\n\n    return [node, true];\n  }\n\n  /**\n   * Method used to add a node if it does not exist in the graph or else to\n   * update its attributes using a function.\n   *\n   * @param  {any}      node      - The node.\n   * @param  {function} [updater] - Optional updater function.\n   * @return {any}                - The node.\n   */\n  updateNode(node, updater) {\n    if (updater && typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.updateNode: invalid updater function. Expecting a function but got \"${updater}\"`\n      );\n\n    // String coercion\n    node = '' + node;\n\n    // If the node already exists, we update the attributes\n    let data = this._nodes.get(node);\n\n    if (data) {\n      if (updater) {\n        const oldAttributes = data.attributes;\n        data.attributes = updater(oldAttributes);\n\n        this.emit('nodeAttributesUpdated', {\n          type: 'replace',\n          key: node,\n          attributes: data.attributes\n        });\n      }\n      return [node, false];\n    }\n\n    const attributes = updater ? updater({}) : {};\n\n    data = new this.NodeDataClass(node, attributes);\n\n    // Adding the node to internal register\n    this._nodes.set(node, data);\n\n    // Emitting\n    this.emit('nodeAdded', {\n      key: node,\n      attributes\n    });\n\n    return [node, true];\n  }\n\n  /**\n   * Method used to drop a single node & all its attached edges from the graph.\n   *\n   * @param  {any}    node - The node.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the node doesn't exist.\n   */\n  dropNode(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.dropNode: could not find the \"${node}\" node in the graph.`\n      );\n\n    let edgeData;\n\n    // Removing attached edges\n    // NOTE: we could be faster here, but this is such a pain to maintain\n    if (this.type !== 'undirected') {\n      for (const neighbor in nodeData.out) {\n        edgeData = nodeData.out[neighbor];\n\n        do {\n          dropEdgeFromData(this, edgeData);\n          edgeData = edgeData.next;\n        } while (edgeData);\n      }\n\n      for (const neighbor in nodeData.in) {\n        edgeData = nodeData.in[neighbor];\n\n        do {\n          dropEdgeFromData(this, edgeData);\n          edgeData = edgeData.next;\n        } while (edgeData);\n      }\n    }\n\n    if (this.type !== 'directed') {\n      for (const neighbor in nodeData.undirected) {\n        edgeData = nodeData.undirected[neighbor];\n\n        do {\n          dropEdgeFromData(this, edgeData);\n          edgeData = edgeData.next;\n        } while (edgeData);\n      }\n    }\n\n    // Dropping the node from the register\n    this._nodes.delete(node);\n\n    // Emitting\n    this.emit('nodeDropped', {\n      key: node,\n      attributes: nodeData.attributes\n    });\n  }\n\n  /**\n   * Method used to drop a single edge from the graph.\n   *\n   * Arity 1:\n   * @param  {any}    edge - The edge.\n   *\n   * Arity 2:\n   * @param  {any}    source - Source node.\n   * @param  {any}    target - Target node.\n   *\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the edge doesn't exist.\n   */\n  dropEdge(edge) {\n    let edgeData;\n\n    if (arguments.length > 1) {\n      const source = '' + arguments[0];\n      const target = '' + arguments[1];\n\n      edgeData = getMatchingEdge(this, source, target, this.type);\n\n      if (!edgeData)\n        throw new NotFoundGraphError(\n          `Graph.dropEdge: could not find the \"${source}\" -> \"${target}\" edge in the graph.`\n        );\n    } else {\n      edge = '' + edge;\n\n      edgeData = this._edges.get(edge);\n\n      if (!edgeData)\n        throw new NotFoundGraphError(\n          `Graph.dropEdge: could not find the \"${edge}\" edge in the graph.`\n        );\n    }\n\n    dropEdgeFromData(this, edgeData);\n\n    return this;\n  }\n\n  /**\n   * Method used to drop a single directed edge from the graph.\n   *\n   * @param  {any}    source - Source node.\n   * @param  {any}    target - Target node.\n   *\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the edge doesn't exist.\n   */\n  dropDirectedEdge(source, target) {\n    if (arguments.length < 2)\n      throw new UsageGraphError(\n        'Graph.dropDirectedEdge: it does not make sense to try and drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.'\n      );\n\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.dropDirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.'\n      );\n\n    source = '' + source;\n    target = '' + target;\n\n    const edgeData = getMatchingEdge(this, source, target, 'directed');\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.dropDirectedEdge: could not find a \"${source}\" -> \"${target}\" edge in the graph.`\n      );\n\n    dropEdgeFromData(this, edgeData);\n\n    return this;\n  }\n\n  /**\n   * Method used to drop a single undirected edge from the graph.\n   *\n   * @param  {any}    source - Source node.\n   * @param  {any}    target - Target node.\n   *\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the edge doesn't exist.\n   */\n  dropUndirectedEdge(source, target) {\n    if (arguments.length < 2)\n      throw new UsageGraphError(\n        'Graph.dropUndirectedEdge: it does not make sense to drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.'\n      );\n\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.dropUndirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.'\n      );\n\n    const edgeData = getMatchingEdge(this, source, target, 'undirected');\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.dropUndirectedEdge: could not find a \"${source}\" -> \"${target}\" edge in the graph.`\n      );\n\n    dropEdgeFromData(this, edgeData);\n\n    return this;\n  }\n\n  /**\n   * Method used to remove every edge & every node from the graph.\n   *\n   * @return {Graph}\n   */\n  clear() {\n    // Clearing edges\n    this._edges.clear();\n\n    // Clearing nodes\n    this._nodes.clear();\n\n    // Reset counters\n    this._resetInstanceCounters();\n\n    // Emitting\n    this.emit('cleared');\n  }\n\n  /**\n   * Method used to remove every edge from the graph.\n   *\n   * @return {Graph}\n   */\n  clearEdges() {\n    // Clearing structure index\n    const iterator = this._nodes.values();\n\n    let step;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      step.value.clear();\n    }\n\n    // Clearing edges\n    this._edges.clear();\n\n    // Reset counters\n    this._resetInstanceCounters();\n\n    // Emitting\n    this.emit('edgesCleared');\n  }\n\n  /**---------------------------------------------------------------------------\n   * Attributes-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning the desired graph's attribute.\n   *\n   * @param  {string} name - Name of the attribute.\n   * @return {any}\n   */\n  getAttribute(name) {\n    return this._attributes[name];\n  }\n\n  /**\n   * Method returning the graph's attributes.\n   *\n   * @return {object}\n   */\n  getAttributes() {\n    return this._attributes;\n  }\n\n  /**\n   * Method returning whether the graph has the desired attribute.\n   *\n   * @param  {string}  name - Name of the attribute.\n   * @return {boolean}\n   */\n  hasAttribute(name) {\n    return this._attributes.hasOwnProperty(name);\n  }\n\n  /**\n   * Method setting a value for the desired graph's attribute.\n   *\n   * @param  {string}  name  - Name of the attribute.\n   * @param  {any}     value - Value for the attribute.\n   * @return {Graph}\n   */\n  setAttribute(name, value) {\n    this._attributes[name] = value;\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'set',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method using a function to update the desired graph's attribute's value.\n   *\n   * @param  {string}   name    - Name of the attribute.\n   * @param  {function} updater - Function use to update the attribute's value.\n   * @return {Graph}\n   */\n  updateAttribute(name, updater) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateAttribute: updater should be a function.'\n      );\n\n    const value = this._attributes[name];\n\n    this._attributes[name] = updater(value);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'set',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method removing the desired graph's attribute.\n   *\n   * @param  {string} name  - Name of the attribute.\n   * @return {Graph}\n   */\n  removeAttribute(name) {\n    delete this._attributes[name];\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'remove',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method replacing the graph's attributes.\n   *\n   * @param  {object} attributes - New attributes.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given attributes are not a plain object.\n   */\n  replaceAttributes(attributes) {\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        'Graph.replaceAttributes: provided attributes are not a plain object.'\n      );\n\n    this._attributes = attributes;\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'replace',\n      attributes: this._attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method merging the graph's attributes.\n   *\n   * @param  {object} attributes - Attributes to merge.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given attributes are not a plain object.\n   */\n  mergeAttributes(attributes) {\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        'Graph.mergeAttributes: provided attributes are not a plain object.'\n      );\n\n    assign(this._attributes, attributes);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'merge',\n      attributes: this._attributes,\n      data: attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method updating the graph's attributes.\n   *\n   * @param  {function} updater - Function used to update the attributes.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given updater is not a function.\n   */\n  updateAttributes(updater) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateAttributes: provided updater is not a function.'\n      );\n\n    this._attributes = updater(this._attributes);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'update',\n      attributes: this._attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method used to update each node's attributes using the given function.\n   *\n   * @param {function}  updater - Updater function to use.\n   * @param {object}    [hints] - Optional hints.\n   */\n  updateEachNodeAttributes(updater, hints) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachNodeAttributes: expecting an updater function.'\n      );\n\n    if (hints && !validateHints(hints))\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      nodeData.attributes = updater(nodeData.key, nodeData.attributes);\n    }\n\n    this.emit('eachNodeAttributesUpdated', {\n      hints: hints ? hints : null\n    });\n  }\n\n  /**\n   * Method used to update each edge's attributes using the given function.\n   *\n   * @param {function}  updater - Updater function to use.\n   * @param {object}    [hints] - Optional hints.\n   */\n  updateEachEdgeAttributes(updater, hints) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachEdgeAttributes: expecting an updater function.'\n      );\n\n    if (hints && !validateHints(hints))\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}'\n      );\n\n    const iterator = this._edges.values();\n\n    let step, edgeData, sourceData, targetData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      edgeData = step.value;\n      sourceData = edgeData.source;\n      targetData = edgeData.target;\n\n      edgeData.attributes = updater(\n        edgeData.key,\n        edgeData.attributes,\n        sourceData.key,\n        targetData.key,\n        sourceData.attributes,\n        targetData.attributes,\n        edgeData.undirected\n      );\n    }\n\n    this.emit('eachEdgeAttributesUpdated', {\n      hints: hints ? hints : null\n    });\n  }\n\n  /**---------------------------------------------------------------------------\n   * Iteration-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method iterating over the graph's adjacency using the given callback.\n   *\n   * @param  {function}  callback - Callback to use.\n   */\n  forEachAdjacencyEntry(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAdjacencyEntry: expecting a callback.'\n      );\n\n    forEachAdjacency(false, false, false, this, callback);\n  }\n  forEachAdjacencyEntryWithOrphans(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAdjacencyEntryWithOrphans: expecting a callback.'\n      );\n\n    forEachAdjacency(false, false, true, this, callback);\n  }\n\n  /**\n   * Method iterating over the graph's assymetric adjacency using the given callback.\n   *\n   * @param  {function}  callback - Callback to use.\n   */\n  forEachAssymetricAdjacencyEntry(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAssymetricAdjacencyEntry: expecting a callback.'\n      );\n\n    forEachAdjacency(false, true, false, this, callback);\n  }\n  forEachAssymetricAdjacencyEntryWithOrphans(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback.'\n      );\n\n    forEachAdjacency(false, true, true, this, callback);\n  }\n\n  /**\n   * Method returning the list of the graph's nodes.\n   *\n   * @return {array} - The nodes.\n   */\n  nodes() {\n    if (typeof Array.from === 'function') return Array.from(this._nodes.keys());\n\n    return take(this._nodes.keys(), this._nodes.size);\n  }\n\n  /**\n   * Method iterating over the graph's nodes using the given callback.\n   *\n   * @param  {function}  callback - Callback (key, attributes, index).\n   */\n  forEachNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      callback(nodeData.key, nodeData.attributes);\n    }\n  }\n\n  /**\n   * Method iterating attempting to find a node matching the given predicate\n   * function.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  findNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.findNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (callback(nodeData.key, nodeData.attributes)) return nodeData.key;\n    }\n\n    return;\n  }\n\n  /**\n   * Method mapping nodes.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  mapNodes(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.mapNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    const result = new Array(this.order);\n    let i = 0;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      result[i++] = callback(nodeData.key, nodeData.attributes);\n    }\n\n    return result;\n  }\n\n  /**\n   * Method returning whether some node verify the given predicate.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  someNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.someNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (callback(nodeData.key, nodeData.attributes)) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning whether all node verify the given predicate.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  everyNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.everyNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (!callback(nodeData.key, nodeData.attributes)) return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Method filtering nodes.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  filterNodes(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.filterNodes: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    const result = [];\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (callback(nodeData.key, nodeData.attributes))\n        result.push(nodeData.key);\n    }\n\n    return result;\n  }\n\n  /**\n   * Method reducing nodes.\n   *\n   * @param  {function}  callback - Callback (accumulator, key, attributes).\n   */\n  reduceNodes(callback, initialValue) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.reduceNodes: expecting a callback.'\n      );\n\n    if (arguments.length < 2)\n      throw new InvalidArgumentsGraphError(\n        'Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.'\n      );\n\n    let accumulator = initialValue;\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      accumulator = callback(accumulator, nodeData.key, nodeData.attributes);\n    }\n\n    return accumulator;\n  }\n\n  /**\n   * Method returning an iterator over the graph's node entries.\n   *\n   * @return {Iterator}\n   */\n  nodeEntries() {\n    const iterator = this._nodes.values();\n\n    return new Iterator(() => {\n      const step = iterator.next();\n\n      if (step.done) return step;\n\n      const data = step.value;\n\n      return {\n        value: {node: data.key, attributes: data.attributes},\n        done: false\n      };\n    });\n  }\n\n  /**---------------------------------------------------------------------------\n   * Serialization\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used to export the whole graph.\n   *\n   * @return {object} - The serialized graph.\n   */\n  export() {\n    const nodes = new Array(this._nodes.size);\n\n    let i = 0;\n\n    this._nodes.forEach((data, key) => {\n      nodes[i++] = serializeNode(key, data);\n    });\n\n    const edges = new Array(this._edges.size);\n\n    i = 0;\n\n    this._edges.forEach((data, key) => {\n      edges[i++] = serializeEdge(this.type, key, data);\n    });\n\n    return {\n      options: {\n        type: this.type,\n        multi: this.multi,\n        allowSelfLoops: this.allowSelfLoops\n      },\n      attributes: this.getAttributes(),\n      nodes,\n      edges\n    };\n  }\n\n  /**\n   * Method used to import a serialized graph.\n   *\n   * @param  {object|Graph} data  - The serialized graph.\n   * @param  {boolean}      merge - Whether to merge data.\n   * @return {Graph}              - Returns itself for chaining.\n   */\n  import(data, merge = false) {\n    // Importing a Graph instance directly\n    if (data instanceof Graph) {\n      // Nodes\n      data.forEachNode((n, a) => {\n        if (merge) this.mergeNode(n, a);\n        else this.addNode(n, a);\n      });\n\n      // Edges\n      data.forEachEdge((e, a, s, t, _sa, _ta, u) => {\n        if (merge) {\n          if (u) this.mergeUndirectedEdgeWithKey(e, s, t, a);\n          else this.mergeDirectedEdgeWithKey(e, s, t, a);\n        } else {\n          if (u) this.addUndirectedEdgeWithKey(e, s, t, a);\n          else this.addDirectedEdgeWithKey(e, s, t, a);\n        }\n      });\n\n      return this;\n    }\n\n    // Importing a serialized graph\n    if (!isPlainObject(data))\n      throw new InvalidArgumentsGraphError(\n        'Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.'\n      );\n\n    if (data.attributes) {\n      if (!isPlainObject(data.attributes))\n        throw new InvalidArgumentsGraphError(\n          'Graph.import: invalid attributes. Expecting a plain object.'\n        );\n\n      if (merge) this.mergeAttributes(data.attributes);\n      else this.replaceAttributes(data.attributes);\n    }\n\n    let i, l, list, node, edge;\n\n    if (data.nodes) {\n      list = data.nodes;\n\n      if (!Array.isArray(list))\n        throw new InvalidArgumentsGraphError(\n          'Graph.import: invalid nodes. Expecting an array.'\n        );\n\n      for (i = 0, l = list.length; i < l; i++) {\n        node = list[i];\n\n        // Validating\n        validateSerializedNode(node);\n\n        // Adding the node\n        const {key, attributes} = node;\n\n        if (merge) this.mergeNode(key, attributes);\n        else this.addNode(key, attributes);\n      }\n    }\n\n    if (data.edges) {\n      let undirectedByDefault = false;\n\n      if (this.type === 'undirected') {\n        undirectedByDefault = true;\n      }\n\n      list = data.edges;\n\n      if (!Array.isArray(list))\n        throw new InvalidArgumentsGraphError(\n          'Graph.import: invalid edges. Expecting an array.'\n        );\n\n      for (i = 0, l = list.length; i < l; i++) {\n        edge = list[i];\n\n        // Validating\n        validateSerializedEdge(edge);\n\n        // Adding the edge\n        const {\n          source,\n          target,\n          attributes,\n          undirected = undirectedByDefault\n        } = edge;\n\n        let method;\n\n        if ('key' in edge) {\n          method = merge\n            ? undirected\n              ? this.mergeUndirectedEdgeWithKey\n              : this.mergeDirectedEdgeWithKey\n            : undirected\n            ? this.addUndirectedEdgeWithKey\n            : this.addDirectedEdgeWithKey;\n\n          method.call(this, edge.key, source, target, attributes);\n        } else {\n          method = merge\n            ? undirected\n              ? this.mergeUndirectedEdge\n              : this.mergeDirectedEdge\n            : undirected\n            ? this.addUndirectedEdge\n            : this.addDirectedEdge;\n\n          method.call(this, source, target, attributes);\n        }\n      }\n    }\n\n    return this;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Utils\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning a null copy of the graph, i.e. a graph without nodes\n   * & edges but with the exact same options.\n   *\n   * @param  {object} options - Options to merge with the current ones.\n   * @return {Graph}          - The null copy.\n   */\n  nullCopy(options) {\n    const graph = new Graph(assign({}, this._options, options));\n    graph.replaceAttributes(assign({}, this.getAttributes()));\n    return graph;\n  }\n\n  /**\n   * Method returning an empty copy of the graph, i.e. a graph without edges but\n   * with the exact same options.\n   *\n   * @param  {object} options - Options to merge with the current ones.\n   * @return {Graph}          - The empty copy.\n   */\n  emptyCopy(options) {\n    const graph = this.nullCopy(options);\n\n    this._nodes.forEach((nodeData, key) => {\n      const attributes = assign({}, nodeData.attributes);\n\n      // NOTE: no need to emit events since user cannot access the instance yet\n      nodeData = new graph.NodeDataClass(key, attributes);\n      graph._nodes.set(key, nodeData);\n    });\n\n    return graph;\n  }\n\n  /**\n   * Method returning an exact copy of the graph.\n   *\n   * @param  {object} options - Upgrade options.\n   * @return {Graph}          - The copy.\n   */\n  copy(options) {\n    options = options || {};\n\n    if (\n      typeof options.type === 'string' &&\n      options.type !== this.type &&\n      options.type !== 'mixed'\n    )\n      throw new UsageGraphError(\n        `Graph.copy: cannot create an incompatible copy from \"${this.type}\" type to \"${options.type}\" because this would mean losing information about the current graph.`\n      );\n\n    if (\n      typeof options.multi === 'boolean' &&\n      options.multi !== this.multi &&\n      options.multi !== true\n    )\n      throw new UsageGraphError(\n        'Graph.copy: cannot create an incompatible copy by downgrading a multi graph to a simple one because this would mean losing information about the current graph.'\n      );\n\n    if (\n      typeof options.allowSelfLoops === 'boolean' &&\n      options.allowSelfLoops !== this.allowSelfLoops &&\n      options.allowSelfLoops !== true\n    )\n      throw new UsageGraphError(\n        'Graph.copy: cannot create an incompatible copy from a graph allowing self loops to one that does not because this would mean losing information about the current graph.'\n      );\n\n    const graph = this.emptyCopy(options);\n\n    const iterator = this._edges.values();\n\n    let step, edgeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      edgeData = step.value;\n\n      // NOTE: no need to emit events since user cannot access the instance yet\n      addEdge(\n        graph,\n        'copy',\n        false,\n        edgeData.undirected,\n        edgeData.key,\n        edgeData.source.key,\n        edgeData.target.key,\n        assign({}, edgeData.attributes)\n      );\n    }\n\n    return graph;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Known methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used by JavaScript to perform JSON serialization.\n   *\n   * @return {object} - The serialized graph.\n   */\n  toJSON() {\n    return this.export();\n  }\n\n  /**\n   * Method returning [object Graph].\n   */\n  toString() {\n    return '[object Graph]';\n  }\n\n  /**\n   * Method used internally by node's console to display a custom object.\n   *\n   * @return {object} - Formatted object representation of the graph.\n   */\n  inspect() {\n    const nodes = {};\n    this._nodes.forEach((data, key) => {\n      nodes[key] = data.attributes;\n    });\n\n    const edges = {},\n      multiIndex = {};\n\n    this._edges.forEach((data, key) => {\n      const direction = data.undirected ? '--' : '->';\n\n      let label = '';\n\n      let source = data.source.key;\n      let target = data.target.key;\n      let tmp;\n\n      if (data.undirected && source > target) {\n        tmp = source;\n        source = target;\n        target = tmp;\n      }\n\n      const desc = `(${source})${direction}(${target})`;\n\n      if (!key.startsWith('geid_')) {\n        label += `[${key}]: `;\n      } else if (this.multi) {\n        if (typeof multiIndex[desc] === 'undefined') {\n          multiIndex[desc] = 0;\n        } else {\n          multiIndex[desc]++;\n        }\n\n        label += `${multiIndex[desc]}. `;\n      }\n\n      label += desc;\n\n      edges[label] = data.attributes;\n    });\n\n    const dummy = {};\n\n    for (const k in this) {\n      if (\n        this.hasOwnProperty(k) &&\n        !EMITTER_PROPS.has(k) &&\n        typeof this[k] !== 'function' &&\n        typeof k !== 'symbol'\n      )\n        dummy[k] = this[k];\n    }\n\n    dummy.attributes = this._attributes;\n    dummy.nodes = nodes;\n    dummy.edges = edges;\n\n    privateProperty(dummy, 'constructor', this.constructor);\n\n    return dummy;\n  }\n}\n\n/**\n * Attaching methods to the prototype.\n *\n * Here, we are attaching a wide variety of methods to the Graph class'\n * prototype when those are very numerous and when their creation is\n * abstracted.\n */\n\n/**\n * Attaching custom inspect method for node >= 10.\n */\nif (typeof Symbol !== 'undefined')\n  Graph.prototype[Symbol.for('nodejs.util.inspect.custom')] =\n    Graph.prototype.inspect;\n\n/**\n * Related to edge addition.\n */\nEDGE_ADD_METHODS.forEach(method => {\n  ['add', 'merge', 'update'].forEach(verb => {\n    const name = method.name(verb);\n    const fn = verb === 'add' ? addEdge : mergeEdge;\n\n    if (method.generateKey) {\n      Graph.prototype[name] = function (source, target, attributes) {\n        return fn(\n          this,\n          name,\n          true,\n          (method.type || this.type) === 'undirected',\n          null,\n          source,\n          target,\n          attributes,\n          verb === 'update'\n        );\n      };\n    } else {\n      Graph.prototype[name] = function (edge, source, target, attributes) {\n        return fn(\n          this,\n          name,\n          false,\n          (method.type || this.type) === 'undirected',\n          edge,\n          source,\n          target,\n          attributes,\n          verb === 'update'\n        );\n      };\n    }\n  });\n});\n\n/**\n * Attributes-related.\n */\nattachNodeAttributesMethods(Graph);\nattachEdgeAttributesMethods(Graph);\n\n/**\n * Edge iteration-related.\n */\nattachEdgeIterationMethods(Graph);\n\n/**\n * Neighbor iteration-related.\n */\nattachNeighborIterationMethods(Graph);\n","/**\n * Graphology Helper Classes\n * ==========================\n *\n * Building some higher-order classes instantiating the graph with\n * predefinite options.\n */\nimport {assign} from './utils';\nimport Graph from './graph';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from './errors';\n\n/**\n * Alternative constructors.\n */\nclass DirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'directed'}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== false)\n      throw new InvalidArgumentsGraphError(\n        'DirectedGraph.from: inconsistent indication that the graph should be multi in given options!'\n      );\n\n    if (finalOptions.type !== 'directed')\n      throw new InvalidArgumentsGraphError(\n        'DirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass UndirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'undirected'}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== false)\n      throw new InvalidArgumentsGraphError(\n        'UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!'\n      );\n\n    if (finalOptions.type !== 'undirected')\n      throw new InvalidArgumentsGraphError(\n        'UndirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass MultiGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError(\n        'MultiGraph.from: inconsistent indication that the graph should be simple in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass MultiDirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'directed', multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError(\n        'MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!'\n      );\n\n    if (finalOptions.type !== 'directed')\n      throw new InvalidArgumentsGraphError(\n        'MultiDirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass MultiUndirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'undirected', multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError(\n        'MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!'\n      );\n\n    if (finalOptions.type !== 'undirected')\n      throw new InvalidArgumentsGraphError(\n        'MultiUndirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\n\n/**\n * Attaching static #.from method to each of the constructors.\n */\nfunction attachStaticFromMethod(Class) {\n  /**\n   * Builds a graph from serialized data or another graph's data.\n   *\n   * @param  {Graph|SerializedGraph} data      - Hydratation data.\n   * @param  {object}                [options] - Options.\n   * @return {Class}\n   */\n  Class.from = function (data, options) {\n    // Merging given options with serialized ones\n    const finalOptions = assign({}, data.options, options);\n\n    const instance = new Class(finalOptions);\n    instance.import(data);\n\n    return instance;\n  };\n}\n\nattachStaticFromMethod(Graph);\nattachStaticFromMethod(DirectedGraph);\nattachStaticFromMethod(UndirectedGraph);\nattachStaticFromMethod(MultiGraph);\nattachStaticFromMethod(MultiDirectedGraph);\nattachStaticFromMethod(MultiUndirectedGraph);\n\nGraph.Graph = Graph;\nGraph.DirectedGraph = DirectedGraph;\nGraph.UndirectedGraph = UndirectedGraph;\nGraph.MultiGraph = MultiGraph;\nGraph.MultiDirectedGraph = MultiDirectedGraph;\nGraph.MultiUndirectedGraph = MultiUndirectedGraph;\n\nGraph.InvalidArgumentsGraphError = InvalidArgumentsGraphError;\nGraph.NotFoundGraphError = NotFoundGraphError;\nGraph.UsageGraphError = UsageGraphError;\n\nexport {\n  Graph,\n  DirectedGraph,\n  UndirectedGraph,\n  MultiGraph,\n  MultiDirectedGraph,\n  MultiUndirectedGraph\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}