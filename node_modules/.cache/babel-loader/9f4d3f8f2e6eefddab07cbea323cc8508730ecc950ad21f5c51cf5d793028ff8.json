{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nfunction drawEdgeLabel(context, edgeData, sourceData, targetData, settings) {\n  var size = settings.edgeLabelSize,\n    font = settings.edgeLabelFont,\n    weight = settings.edgeLabelWeight,\n    color = settings.edgeLabelColor.attribute ? edgeData[settings.edgeLabelColor.attribute] || settings.edgeLabelColor.color || \"#000\" : settings.edgeLabelColor.color;\n  var label = edgeData.label;\n  if (!label) return;\n  context.fillStyle = color;\n  context.font = \"\".concat(weight, \" \").concat(size, \"px \").concat(font);\n  // Computing positions without considering nodes sizes:\n  var sSize = sourceData.size;\n  var tSize = targetData.size;\n  var sx = sourceData.x;\n  var sy = sourceData.y;\n  var tx = targetData.x;\n  var ty = targetData.y;\n  var cx = (sx + tx) / 2;\n  var cy = (sy + ty) / 2;\n  var dx = tx - sx;\n  var dy = ty - sy;\n  var d = Math.sqrt(dx * dx + dy * dy);\n  if (d < sSize + tSize) return;\n  // Adding nodes sizes:\n  sx += dx * sSize / d;\n  sy += dy * sSize / d;\n  tx -= dx * tSize / d;\n  ty -= dy * tSize / d;\n  cx = (sx + tx) / 2;\n  cy = (sy + ty) / 2;\n  dx = tx - sx;\n  dy = ty - sy;\n  d = Math.sqrt(dx * dx + dy * dy);\n  // Handling ellipsis\n  var textLength = context.measureText(label).width;\n  if (textLength > d) {\n    var ellipsis = \"…\";\n    label = label + ellipsis;\n    textLength = context.measureText(label).width;\n    while (textLength > d && label.length > 1) {\n      label = label.slice(0, -2) + ellipsis;\n      textLength = context.measureText(label).width;\n    }\n    if (label.length < 4) return;\n  }\n  var angle;\n  if (dx > 0) {\n    if (dy > 0) angle = Math.acos(dx / d);else angle = Math.asin(dy / d);\n  } else {\n    if (dy > 0) angle = Math.acos(dx / d) + Math.PI;else angle = Math.asin(dx / d) + Math.PI / 2;\n  }\n  context.save();\n  context.translate(cx, cy);\n  context.rotate(angle);\n  context.fillText(label, -textLength / 2, edgeData.size / 2 + size);\n  context.restore();\n}\nexports.default = drawEdgeLabel;","map":{"version":3,"names":["Object","defineProperty","exports","value","drawEdgeLabel","context","edgeData","sourceData","targetData","settings","size","edgeLabelSize","font","edgeLabelFont","weight","edgeLabelWeight","color","edgeLabelColor","attribute","label","fillStyle","concat","sSize","tSize","sx","x","sy","y","tx","ty","cx","cy","dx","dy","d","Math","sqrt","textLength","measureText","width","ellipsis","length","slice","angle","acos","asin","PI","save","translate","rotate","fillText","restore","default"],"sources":["/Users/radhika.bajaj/Documents/GitHub/Knowledge-Graph-Frontend/node_modules/sigma/rendering/canvas/edge-label.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction drawEdgeLabel(context, edgeData, sourceData, targetData, settings) {\n    var size = settings.edgeLabelSize, font = settings.edgeLabelFont, weight = settings.edgeLabelWeight, color = settings.edgeLabelColor.attribute\n        ? edgeData[settings.edgeLabelColor.attribute] || settings.edgeLabelColor.color || \"#000\"\n        : settings.edgeLabelColor.color;\n    var label = edgeData.label;\n    if (!label)\n        return;\n    context.fillStyle = color;\n    context.font = \"\".concat(weight, \" \").concat(size, \"px \").concat(font);\n    // Computing positions without considering nodes sizes:\n    var sSize = sourceData.size;\n    var tSize = targetData.size;\n    var sx = sourceData.x;\n    var sy = sourceData.y;\n    var tx = targetData.x;\n    var ty = targetData.y;\n    var cx = (sx + tx) / 2;\n    var cy = (sy + ty) / 2;\n    var dx = tx - sx;\n    var dy = ty - sy;\n    var d = Math.sqrt(dx * dx + dy * dy);\n    if (d < sSize + tSize)\n        return;\n    // Adding nodes sizes:\n    sx += (dx * sSize) / d;\n    sy += (dy * sSize) / d;\n    tx -= (dx * tSize) / d;\n    ty -= (dy * tSize) / d;\n    cx = (sx + tx) / 2;\n    cy = (sy + ty) / 2;\n    dx = tx - sx;\n    dy = ty - sy;\n    d = Math.sqrt(dx * dx + dy * dy);\n    // Handling ellipsis\n    var textLength = context.measureText(label).width;\n    if (textLength > d) {\n        var ellipsis = \"…\";\n        label = label + ellipsis;\n        textLength = context.measureText(label).width;\n        while (textLength > d && label.length > 1) {\n            label = label.slice(0, -2) + ellipsis;\n            textLength = context.measureText(label).width;\n        }\n        if (label.length < 4)\n            return;\n    }\n    var angle;\n    if (dx > 0) {\n        if (dy > 0)\n            angle = Math.acos(dx / d);\n        else\n            angle = Math.asin(dy / d);\n    }\n    else {\n        if (dy > 0)\n            angle = Math.acos(dx / d) + Math.PI;\n        else\n            angle = Math.asin(dx / d) + Math.PI / 2;\n    }\n    context.save();\n    context.translate(cx, cy);\n    context.rotate(angle);\n    context.fillText(label, -textLength / 2, edgeData.size / 2 + size);\n    context.restore();\n}\nexports.default = drawEdgeLabel;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}