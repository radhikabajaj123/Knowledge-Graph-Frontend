{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar extend_1 = __importDefault(require(\"@yomguithereal/helpers/extend\"));\nvar camera_1 = __importDefault(require(\"./core/camera\"));\nvar mouse_1 = __importDefault(require(\"./core/captors/mouse\"));\nvar quadtree_1 = __importDefault(require(\"./core/quadtree\"));\nvar types_1 = require(\"./types\");\nvar utils_1 = require(\"./utils\");\nvar labels_1 = require(\"./core/labels\");\nvar settings_1 = require(\"./settings\");\nvar touch_1 = __importDefault(require(\"./core/captors/touch\"));\nvar matrices_1 = require(\"./utils/matrices\");\nvar edge_collisions_1 = require(\"./utils/edge-collisions\");\n/**\n * Constants.\n */\nvar X_LABEL_MARGIN = 150;\nvar Y_LABEL_MARGIN = 50;\n/**\n * Important functions.\n */\nfunction applyNodeDefaults(settings, key, data) {\n  if (!data.hasOwnProperty(\"x\") || !data.hasOwnProperty(\"y\")) throw new Error(\"Sigma: could not find a valid position (x, y) for node \\\"\".concat(key, \"\\\". All your nodes must have a number \\\"x\\\" and \\\"y\\\". Maybe your forgot to apply a layout or your \\\"nodeReducer\\\" is not returning the correct data?\"));\n  if (!data.color) data.color = settings.defaultNodeColor;\n  if (!data.label && data.label !== \"\") data.label = null;\n  if (data.label !== undefined && data.label !== null) data.label = \"\" + data.label;else data.label = null;\n  if (!data.size) data.size = 2;\n  if (!data.hasOwnProperty(\"hidden\")) data.hidden = false;\n  if (!data.hasOwnProperty(\"highlighted\")) data.highlighted = false;\n  if (!data.hasOwnProperty(\"forceLabel\")) data.forceLabel = false;\n  if (!data.type || data.type === \"\") data.type = settings.defaultNodeType;\n  if (!data.zIndex) data.zIndex = 0;\n  return data;\n}\nfunction applyEdgeDefaults(settings, key, data) {\n  if (!data.color) data.color = settings.defaultEdgeColor;\n  if (!data.label) data.label = \"\";\n  if (!data.size) data.size = 0.5;\n  if (!data.hasOwnProperty(\"hidden\")) data.hidden = false;\n  if (!data.hasOwnProperty(\"forceLabel\")) data.forceLabel = false;\n  if (!data.type || data.type === \"\") data.type = settings.defaultEdgeType;\n  if (!data.zIndex) data.zIndex = 0;\n  return data;\n}\n/**\n * Main class.\n *\n * @constructor\n * @param {Graph}       graph     - Graph to render.\n * @param {HTMLElement} container - DOM container in which to render.\n * @param {object}      settings  - Optional settings.\n */\nvar Sigma = /** @class */function (_super) {\n  __extends(Sigma, _super);\n  function Sigma(graph, container, settings) {\n    if (settings === void 0) {\n      settings = {};\n    }\n    var _this = _super.call(this) || this;\n    _this.elements = {};\n    _this.canvasContexts = {};\n    _this.webGLContexts = {};\n    _this.activeListeners = {};\n    _this.quadtree = new quadtree_1.default();\n    _this.labelGrid = new labels_1.LabelGrid();\n    _this.nodeDataCache = {};\n    _this.edgeDataCache = {};\n    _this.nodesWithForcedLabels = [];\n    _this.edgesWithForcedLabels = [];\n    _this.nodeExtent = {\n      x: [0, 1],\n      y: [0, 1]\n    };\n    _this.matrix = (0, matrices_1.identity)();\n    _this.invMatrix = (0, matrices_1.identity)();\n    _this.correctionRatio = 1;\n    _this.customBBox = null;\n    _this.normalizationFunction = (0, utils_1.createNormalizationFunction)({\n      x: [0, 1],\n      y: [0, 1]\n    });\n    // Cache:\n    _this.cameraSizeRatio = 1;\n    // Starting dimensions and pixel ratio\n    _this.width = 0;\n    _this.height = 0;\n    _this.pixelRatio = (0, utils_1.getPixelRatio)();\n    // State\n    _this.displayedLabels = new Set();\n    _this.highlightedNodes = new Set();\n    _this.hoveredNode = null;\n    _this.hoveredEdge = null;\n    _this.renderFrame = null;\n    _this.renderHighlightedNodesFrame = null;\n    _this.needToProcess = false;\n    _this.needToSoftProcess = false;\n    _this.checkEdgesEventsFrame = null;\n    // Programs\n    _this.nodePrograms = {};\n    _this.nodeHoverPrograms = {};\n    _this.edgePrograms = {};\n    // Resolving settings\n    _this.settings = (0, settings_1.resolveSettings)(settings);\n    // Validating\n    (0, settings_1.validateSettings)(_this.settings);\n    (0, utils_1.validateGraph)(graph);\n    if (!(container instanceof HTMLElement)) throw new Error(\"Sigma: container should be an html element.\");\n    // Properties\n    _this.graph = graph;\n    _this.container = container;\n    // Initializing contexts\n    _this.createWebGLContext(\"edges\", {\n      preserveDrawingBuffer: true\n    });\n    _this.createCanvasContext(\"edgeLabels\");\n    _this.createWebGLContext(\"nodes\");\n    _this.createCanvasContext(\"labels\");\n    _this.createCanvasContext(\"hovers\");\n    _this.createWebGLContext(\"hoverNodes\");\n    _this.createCanvasContext(\"mouse\");\n    // Blending\n    for (var key in _this.webGLContexts) {\n      var gl = _this.webGLContexts[key];\n      gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n      gl.enable(gl.BLEND);\n    }\n    // Loading programs\n    for (var type in _this.settings.nodeProgramClasses) {\n      var NodeProgramClass = _this.settings.nodeProgramClasses[type];\n      _this.nodePrograms[type] = new NodeProgramClass(_this.webGLContexts.nodes, _this);\n      var NodeHoverProgram = NodeProgramClass;\n      if (type in _this.settings.nodeHoverProgramClasses) {\n        NodeHoverProgram = _this.settings.nodeHoverProgramClasses[type];\n      }\n      _this.nodeHoverPrograms[type] = new NodeHoverProgram(_this.webGLContexts.hoverNodes, _this);\n    }\n    for (var type in _this.settings.edgeProgramClasses) {\n      var EdgeProgramClass = _this.settings.edgeProgramClasses[type];\n      _this.edgePrograms[type] = new EdgeProgramClass(_this.webGLContexts.edges, _this);\n    }\n    // Initial resize\n    _this.resize();\n    // Initializing the camera\n    _this.camera = new camera_1.default();\n    // Binding camera events\n    _this.bindCameraHandlers();\n    // Initializing captors\n    _this.mouseCaptor = new mouse_1.default(_this.elements.mouse, _this);\n    _this.touchCaptor = new touch_1.default(_this.elements.mouse, _this);\n    // Binding event handlers\n    _this.bindEventHandlers();\n    // Binding graph handlers\n    _this.bindGraphHandlers();\n    // Trigger eventual settings-related things\n    _this.handleSettingsUpdate();\n    // Processing data for the first time & render\n    _this.process();\n    _this.render();\n    return _this;\n  }\n  /**---------------------------------------------------------------------------\n   * Internal methods.\n   **---------------------------------------------------------------------------\n   */\n  /**\n   * Internal function used to create a canvas element.\n   * @param  {string} id - Context's id.\n   * @return {Sigma}\n   */\n  Sigma.prototype.createCanvas = function (id) {\n    var canvas = (0, utils_1.createElement)(\"canvas\", {\n      position: \"absolute\"\n    }, {\n      class: \"sigma-\".concat(id)\n    });\n    this.elements[id] = canvas;\n    this.container.appendChild(canvas);\n    return canvas;\n  };\n  /**\n   * Internal function used to create a canvas context and add the relevant\n   * DOM elements.\n   *\n   * @param  {string} id - Context's id.\n   * @return {Sigma}\n   */\n  Sigma.prototype.createCanvasContext = function (id) {\n    var canvas = this.createCanvas(id);\n    var contextOptions = {\n      preserveDrawingBuffer: false,\n      antialias: false\n    };\n    this.canvasContexts[id] = canvas.getContext(\"2d\", contextOptions);\n    return this;\n  };\n  /**\n   * Internal function used to create a canvas context and add the relevant\n   * DOM elements.\n   *\n   * @param  {string}  id      - Context's id.\n   * @param  {object?} options - #getContext params to override (optional)\n   * @return {Sigma}\n   */\n  Sigma.prototype.createWebGLContext = function (id, options) {\n    var canvas = this.createCanvas(id);\n    var contextOptions = __assign({\n      preserveDrawingBuffer: false,\n      antialias: false\n    }, options || {});\n    var context;\n    // First we try webgl2 for an easy performance boost\n    context = canvas.getContext(\"webgl2\", contextOptions);\n    // Else we fall back to webgl\n    if (!context) context = canvas.getContext(\"webgl\", contextOptions);\n    // Edge, I am looking right at you...\n    if (!context) context = canvas.getContext(\"experimental-webgl\", contextOptions);\n    this.webGLContexts[id] = context;\n    return this;\n  };\n  /**\n   * Method binding camera handlers.\n   *\n   * @return {Sigma}\n   */\n  Sigma.prototype.bindCameraHandlers = function () {\n    var _this = this;\n    this.activeListeners.camera = function () {\n      _this._scheduleRefresh();\n    };\n    this.camera.on(\"updated\", this.activeListeners.camera);\n    return this;\n  };\n  /**\n   * Method that checks whether or not a node collides with a given position.\n   */\n  Sigma.prototype.mouseIsOnNode = function (_a, _b, size) {\n    var x = _a.x,\n      y = _a.y;\n    var nodeX = _b.x,\n      nodeY = _b.y;\n    return x > nodeX - size && x < nodeX + size && y > nodeY - size && y < nodeY + size && Math.sqrt(Math.pow(x - nodeX, 2) + Math.pow(y - nodeY, 2)) < size;\n  };\n  /**\n   * Method that returns all nodes in quad at a given position.\n   */\n  Sigma.prototype.getQuadNodes = function (position) {\n    var mouseGraphPosition = this.viewportToFramedGraph(position);\n    return this.quadtree.point(mouseGraphPosition.x, 1 - mouseGraphPosition.y);\n  };\n  /**\n   * Method that returns the closest node to a given position.\n   */\n  Sigma.prototype.getNodeAtPosition = function (position) {\n    var x = position.x,\n      y = position.y;\n    var quadNodes = this.getQuadNodes(position);\n    // We will hover the node whose center is closest to mouse\n    var minDistance = Infinity,\n      nodeAtPosition = null;\n    for (var i = 0, l = quadNodes.length; i < l; i++) {\n      var node = quadNodes[i];\n      var data = this.nodeDataCache[node];\n      var nodePosition = this.framedGraphToViewport(data);\n      var size = this.scaleSize(data.size);\n      if (!data.hidden && this.mouseIsOnNode(position, nodePosition, size)) {\n        var distance = Math.sqrt(Math.pow(x - nodePosition.x, 2) + Math.pow(y - nodePosition.y, 2));\n        // TODO: sort by min size also for cases where center is the same\n        if (distance < minDistance) {\n          minDistance = distance;\n          nodeAtPosition = node;\n        }\n      }\n    }\n    return nodeAtPosition;\n  };\n  /**\n   * Method binding event handlers.\n   *\n   * @return {Sigma}\n   */\n  Sigma.prototype.bindEventHandlers = function () {\n    var _this = this;\n    // Handling window resize\n    this.activeListeners.handleResize = function () {\n      _this.needToSoftProcess = true;\n      _this._scheduleRefresh();\n    };\n    window.addEventListener(\"resize\", this.activeListeners.handleResize);\n    // Handling mouse move\n    this.activeListeners.handleMove = function (e) {\n      var baseEvent = {\n        event: e,\n        preventSigmaDefault: function () {\n          e.preventSigmaDefault();\n        }\n      };\n      var nodeToHover = _this.getNodeAtPosition(e);\n      if (nodeToHover && _this.hoveredNode !== nodeToHover && !_this.nodeDataCache[nodeToHover].hidden) {\n        // Handling passing from one node to the other directly\n        if (_this.hoveredNode) _this.emit(\"leaveNode\", __assign(__assign({}, baseEvent), {\n          node: _this.hoveredNode\n        }));\n        _this.hoveredNode = nodeToHover;\n        _this.emit(\"enterNode\", __assign(__assign({}, baseEvent), {\n          node: nodeToHover\n        }));\n        _this.scheduleHighlightedNodesRender();\n        return;\n      }\n      // Checking if the hovered node is still hovered\n      if (_this.hoveredNode) {\n        var data = _this.nodeDataCache[_this.hoveredNode];\n        var pos = _this.framedGraphToViewport(data);\n        var size = _this.scaleSize(data.size);\n        if (!_this.mouseIsOnNode(e, pos, size)) {\n          var node = _this.hoveredNode;\n          _this.hoveredNode = null;\n          _this.emit(\"leaveNode\", __assign(__assign({}, baseEvent), {\n            node: node\n          }));\n          _this.scheduleHighlightedNodesRender();\n          return;\n        }\n      }\n      if (_this.settings.enableEdgeHoverEvents === true) {\n        _this.checkEdgeHoverEvents(baseEvent);\n      } else if (_this.settings.enableEdgeHoverEvents === \"debounce\") {\n        if (!_this.checkEdgesEventsFrame) _this.checkEdgesEventsFrame = (0, utils_1.requestFrame)(function () {\n          _this.checkEdgeHoverEvents(baseEvent);\n          _this.checkEdgesEventsFrame = null;\n        });\n      }\n    };\n    // Handling click\n    var createMouseListener = function (eventType) {\n      return function (e) {\n        var baseEvent = {\n          event: e,\n          preventSigmaDefault: function () {\n            e.preventSigmaDefault();\n          }\n        };\n        var isFakeSigmaMouseEvent = e.original.isFakeSigmaMouseEvent;\n        var nodeAtPosition = isFakeSigmaMouseEvent ? _this.getNodeAtPosition(e) : _this.hoveredNode;\n        if (nodeAtPosition) return _this.emit(\"\".concat(eventType, \"Node\"), __assign(__assign({}, baseEvent), {\n          node: nodeAtPosition\n        }));\n        if (eventType === \"wheel\" ? _this.settings.enableEdgeWheelEvents : _this.settings.enableEdgeClickEvents) {\n          var edge = _this.getEdgeAtPoint(e.x, e.y);\n          if (edge) return _this.emit(\"\".concat(eventType, \"Edge\"), __assign(__assign({}, baseEvent), {\n            edge: edge\n          }));\n        }\n        return _this.emit(\"\".concat(eventType, \"Stage\"), baseEvent);\n      };\n    };\n    this.activeListeners.handleClick = createMouseListener(\"click\");\n    this.activeListeners.handleRightClick = createMouseListener(\"rightClick\");\n    this.activeListeners.handleDoubleClick = createMouseListener(\"doubleClick\");\n    this.activeListeners.handleWheel = createMouseListener(\"wheel\");\n    this.activeListeners.handleDown = createMouseListener(\"down\");\n    this.mouseCaptor.on(\"mousemove\", this.activeListeners.handleMove);\n    this.mouseCaptor.on(\"click\", this.activeListeners.handleClick);\n    this.mouseCaptor.on(\"rightClick\", this.activeListeners.handleRightClick);\n    this.mouseCaptor.on(\"doubleClick\", this.activeListeners.handleDoubleClick);\n    this.mouseCaptor.on(\"wheel\", this.activeListeners.handleWheel);\n    this.mouseCaptor.on(\"mousedown\", this.activeListeners.handleDown);\n    // TODO\n    // Deal with Touch captor events\n    return this;\n  };\n  /**\n   * Method binding graph handlers\n   *\n   * @return {Sigma}\n   */\n  Sigma.prototype.bindGraphHandlers = function () {\n    var _this = this;\n    var graph = this.graph;\n    this.activeListeners.graphUpdate = function () {\n      _this.needToProcess = true;\n      _this._scheduleRefresh();\n    };\n    this.activeListeners.softGraphUpdate = function () {\n      _this.needToSoftProcess = true;\n      _this._scheduleRefresh();\n    };\n    this.activeListeners.dropNodeGraphUpdate = function (e) {\n      delete _this.nodeDataCache[e.key];\n      if (_this.hoveredNode === e.key) _this.hoveredNode = null;\n      _this.activeListeners.graphUpdate();\n    };\n    this.activeListeners.dropEdgeGraphUpdate = function (e) {\n      delete _this.edgeDataCache[e.key];\n      if (_this.hoveredEdge === e.key) _this.hoveredEdge = null;\n      _this.activeListeners.graphUpdate();\n    };\n    this.activeListeners.clearEdgesGraphUpdate = function () {\n      _this.edgeDataCache = {};\n      _this.hoveredEdge = null;\n      _this.activeListeners.graphUpdate();\n    };\n    this.activeListeners.clearGraphUpdate = function () {\n      _this.nodeDataCache = {};\n      _this.hoveredNode = null;\n      _this.activeListeners.clearEdgesGraphUpdate();\n    };\n    graph.on(\"nodeAdded\", this.activeListeners.graphUpdate);\n    graph.on(\"nodeDropped\", this.activeListeners.dropNodeGraphUpdate);\n    graph.on(\"nodeAttributesUpdated\", this.activeListeners.softGraphUpdate);\n    graph.on(\"eachNodeAttributesUpdated\", this.activeListeners.graphUpdate);\n    graph.on(\"edgeAdded\", this.activeListeners.graphUpdate);\n    graph.on(\"edgeDropped\", this.activeListeners.dropEdgeGraphUpdate);\n    graph.on(\"edgeAttributesUpdated\", this.activeListeners.softGraphUpdate);\n    graph.on(\"eachEdgeAttributesUpdated\", this.activeListeners.graphUpdate);\n    graph.on(\"edgesCleared\", this.activeListeners.clearEdgesGraphUpdate);\n    graph.on(\"cleared\", this.activeListeners.clearGraphUpdate);\n    return this;\n  };\n  /**\n   * Method used to unbind handlers from the graph.\n   *\n   * @return {undefined}\n   */\n  Sigma.prototype.unbindGraphHandlers = function () {\n    var graph = this.graph;\n    graph.removeListener(\"nodeAdded\", this.activeListeners.graphUpdate);\n    graph.removeListener(\"nodeDropped\", this.activeListeners.dropNodeGraphUpdate);\n    graph.removeListener(\"nodeAttributesUpdated\", this.activeListeners.softGraphUpdate);\n    graph.removeListener(\"eachNodeAttributesUpdated\", this.activeListeners.graphUpdate);\n    graph.removeListener(\"edgeAdded\", this.activeListeners.graphUpdate);\n    graph.removeListener(\"edgeDropped\", this.activeListeners.dropEdgeGraphUpdate);\n    graph.removeListener(\"edgeAttributesUpdated\", this.activeListeners.softGraphUpdate);\n    graph.removeListener(\"eachEdgeAttributesUpdated\", this.activeListeners.graphUpdate);\n    graph.removeListener(\"edgesCleared\", this.activeListeners.clearEdgesGraphUpdate);\n    graph.removeListener(\"cleared\", this.activeListeners.clearGraphUpdate);\n  };\n  /**\n   * Method dealing with \"leaveEdge\" and \"enterEdge\" events.\n   *\n   * @return {Sigma}\n   */\n  Sigma.prototype.checkEdgeHoverEvents = function (payload) {\n    var edgeToHover = this.hoveredNode ? null : this.getEdgeAtPoint(payload.event.x, payload.event.y);\n    if (edgeToHover !== this.hoveredEdge) {\n      if (this.hoveredEdge) this.emit(\"leaveEdge\", __assign(__assign({}, payload), {\n        edge: this.hoveredEdge\n      }));\n      if (edgeToHover) this.emit(\"enterEdge\", __assign(__assign({}, payload), {\n        edge: edgeToHover\n      }));\n      this.hoveredEdge = edgeToHover;\n    }\n    return this;\n  };\n  /**\n   * Method looking for an edge colliding with a given point at (x, y). Returns\n   * the key of the edge if any, or null else.\n   */\n  Sigma.prototype.getEdgeAtPoint = function (x, y) {\n    var e_1, _a;\n    var _this = this;\n    var _b = this,\n      edgeDataCache = _b.edgeDataCache,\n      nodeDataCache = _b.nodeDataCache;\n    // Check first that pixel is colored:\n    // Note that mouse positions must be corrected by pixel ratio to correctly\n    // index the drawing buffer.\n    if (!(0, edge_collisions_1.isPixelColored)(this.webGLContexts.edges, x * this.pixelRatio, y * this.pixelRatio)) return null;\n    // Check for each edge if it collides with the point:\n    var _c = this.viewportToGraph({\n        x: x,\n        y: y\n      }),\n      graphX = _c.x,\n      graphY = _c.y;\n    // To translate edge thicknesses to the graph system, we observe by how much\n    // the length of a non-null edge is transformed to between the graph system\n    // and the viewport system:\n    var transformationRatio = 0;\n    this.graph.someEdge(function (key, _, sourceId, targetId, _a, _b) {\n      var xs = _a.x,\n        ys = _a.y;\n      var xt = _b.x,\n        yt = _b.y;\n      if (edgeDataCache[key].hidden || nodeDataCache[sourceId].hidden || nodeDataCache[targetId].hidden) return false;\n      if (xs !== xt || ys !== yt) {\n        var graphLength = Math.sqrt(Math.pow(xt - xs, 2) + Math.pow(yt - ys, 2));\n        var _c = _this.graphToViewport({\n            x: xs,\n            y: ys\n          }),\n          vp_xs = _c.x,\n          vp_ys = _c.y;\n        var _d = _this.graphToViewport({\n            x: xt,\n            y: yt\n          }),\n          vp_xt = _d.x,\n          vp_yt = _d.y;\n        var viewportLength = Math.sqrt(Math.pow(vp_xt - vp_xs, 2) + Math.pow(vp_yt - vp_ys, 2));\n        transformationRatio = graphLength / viewportLength;\n        return true;\n      }\n    });\n    // If no non-null edge has been found, return null:\n    if (!transformationRatio) return null;\n    // Now we can look for matching edges:\n    var edges = this.graph.filterEdges(function (key, edgeAttributes, sourceId, targetId, sourcePosition, targetPosition) {\n      if (edgeDataCache[key].hidden || nodeDataCache[sourceId].hidden || nodeDataCache[targetId].hidden) return false;\n      if ((0, edge_collisions_1.doEdgeCollideWithPoint)(graphX, graphY, sourcePosition.x, sourcePosition.y, targetPosition.x, targetPosition.y,\n      // Adapt the edge size to the zoom ratio:\n      edgeDataCache[key].size * transformationRatio / _this.cameraSizeRatio)) {\n        return true;\n      }\n    });\n    if (edges.length === 0) return null; // no edges found\n    // if none of the edges have a zIndex, selected the most recently created one to match the rendering order\n    var selectedEdge = edges[edges.length - 1];\n    // otherwise select edge with highest zIndex\n    var highestZIndex = -Infinity;\n    try {\n      for (var edges_1 = __values(edges), edges_1_1 = edges_1.next(); !edges_1_1.done; edges_1_1 = edges_1.next()) {\n        var edge = edges_1_1.value;\n        var zIndex = this.graph.getEdgeAttribute(edge, \"zIndex\");\n        if (zIndex >= highestZIndex) {\n          selectedEdge = edge;\n          highestZIndex = zIndex;\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (edges_1_1 && !edges_1_1.done && (_a = edges_1.return)) _a.call(edges_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    return selectedEdge;\n  };\n  /**\n   * Method used to process the whole graph's data.\n   *\n   * @return {Sigma}\n   */\n  Sigma.prototype.process = function (keepArrays) {\n    var _this = this;\n    if (keepArrays === void 0) {\n      keepArrays = false;\n    }\n    var graph = this.graph;\n    var settings = this.settings;\n    var dimensions = this.getDimensions();\n    var nodeZExtent = [Infinity, -Infinity];\n    var edgeZExtent = [Infinity, -Infinity];\n    // Clearing the quad\n    this.quadtree.clear();\n    // Resetting the label grid\n    // TODO: it's probably better to do this explicitly or on resizes for layout and anims\n    this.labelGrid.resizeAndClear(dimensions, settings.labelGridCellSize);\n    // Clear the highlightedNodes\n    this.highlightedNodes = new Set();\n    // Computing extents\n    this.nodeExtent = (0, utils_1.graphExtent)(graph);\n    // Resetting `forceLabel` indices\n    this.nodesWithForcedLabels = [];\n    this.edgesWithForcedLabels = [];\n    // NOTE: it is important to compute this matrix after computing the node's extent\n    // because #.getGraphDimensions relies on it\n    var nullCamera = new camera_1.default();\n    var nullCameraMatrix = (0, utils_1.matrixFromCamera)(nullCamera.getState(), this.getDimensions(), this.getGraphDimensions(), this.getSetting(\"stagePadding\") || 0);\n    // Rescaling function\n    this.normalizationFunction = (0, utils_1.createNormalizationFunction)(this.customBBox || this.nodeExtent);\n    var nodesPerPrograms = {};\n    var nodes = graph.nodes();\n    for (var i = 0, l = nodes.length; i < l; i++) {\n      var node = nodes[i];\n      // Node display data resolution:\n      //   1. First we get the node's attributes\n      //   2. We optionally reduce them using the function provided by the user\n      //      Note that this function must return a total object and won't be merged\n      //   3. We apply our defaults, while running some vital checks\n      //   4. We apply the normalization function\n      // We shallow copy node data to avoid dangerous behaviors from reducers\n      var attr = Object.assign({}, graph.getNodeAttributes(node));\n      if (settings.nodeReducer) attr = settings.nodeReducer(node, attr);\n      var data = applyNodeDefaults(this.settings, node, attr);\n      nodesPerPrograms[data.type] = (nodesPerPrograms[data.type] || 0) + 1;\n      this.nodeDataCache[node] = data;\n      this.normalizationFunction.applyTo(data);\n      if (data.forceLabel) this.nodesWithForcedLabels.push(node);\n      if (this.settings.zIndex) {\n        if (data.zIndex < nodeZExtent[0]) nodeZExtent[0] = data.zIndex;\n        if (data.zIndex > nodeZExtent[1]) nodeZExtent[1] = data.zIndex;\n      }\n    }\n    for (var type in this.nodePrograms) {\n      if (!this.nodePrograms.hasOwnProperty(type)) {\n        throw new Error(\"Sigma: could not find a suitable program for node type \\\"\".concat(type, \"\\\"!\"));\n      }\n      if (!keepArrays) this.nodePrograms[type].allocate(nodesPerPrograms[type] || 0);\n      // We reset that count here, so that we can reuse it while calling the Program#process methods:\n      nodesPerPrograms[type] = 0;\n    }\n    // Handling node z-index\n    // TODO: z-index needs us to compute display data before hand\n    if (this.settings.zIndex && nodeZExtent[0] !== nodeZExtent[1]) nodes = (0, utils_1.zIndexOrdering)(nodeZExtent, function (node) {\n      return _this.nodeDataCache[node].zIndex;\n    }, nodes);\n    for (var i = 0, l = nodes.length; i < l; i++) {\n      var node = nodes[i];\n      var data = this.nodeDataCache[node];\n      this.quadtree.add(node, data.x, 1 - data.y, data.size / this.width);\n      if (typeof data.label === \"string\" && !data.hidden) this.labelGrid.add(node, data.size, this.framedGraphToViewport(data, {\n        matrix: nullCameraMatrix\n      }));\n      var nodeProgram = this.nodePrograms[data.type];\n      if (!nodeProgram) throw new Error(\"Sigma: could not find a suitable program for node type \\\"\".concat(data.type, \"\\\"!\"));\n      nodeProgram.process(data, data.hidden, nodesPerPrograms[data.type]++);\n      // Save the node in the highlighted set if needed\n      if (data.highlighted && !data.hidden) this.highlightedNodes.add(node);\n    }\n    this.labelGrid.organize();\n    var edgesPerPrograms = {};\n    var edges = graph.edges();\n    for (var i = 0, l = edges.length; i < l; i++) {\n      var edge = edges[i];\n      // Edge display data resolution:\n      //   1. First we get the edge's attributes\n      //   2. We optionally reduce them using the function provided by the user\n      //      Note that this function must return a total object and won't be merged\n      //   3. We apply our defaults, while running some vital checks\n      // We shallow copy edge data to avoid dangerous behaviors from reducers\n      var attr = Object.assign({}, graph.getEdgeAttributes(edge));\n      if (settings.edgeReducer) attr = settings.edgeReducer(edge, attr);\n      var data = applyEdgeDefaults(this.settings, edge, attr);\n      edgesPerPrograms[data.type] = (edgesPerPrograms[data.type] || 0) + 1;\n      this.edgeDataCache[edge] = data;\n      if (data.forceLabel && !data.hidden) this.edgesWithForcedLabels.push(edge);\n      if (this.settings.zIndex) {\n        if (data.zIndex < edgeZExtent[0]) edgeZExtent[0] = data.zIndex;\n        if (data.zIndex > edgeZExtent[1]) edgeZExtent[1] = data.zIndex;\n      }\n    }\n    for (var type in this.edgePrograms) {\n      if (!this.edgePrograms.hasOwnProperty(type)) {\n        throw new Error(\"Sigma: could not find a suitable program for edge type \\\"\".concat(type, \"\\\"!\"));\n      }\n      if (!keepArrays) this.edgePrograms[type].allocate(edgesPerPrograms[type] || 0);\n      // We reset that count here, so that we can reuse it while calling the Program#process methods:\n      edgesPerPrograms[type] = 0;\n    }\n    // Handling edge z-index\n    if (this.settings.zIndex && edgeZExtent[0] !== edgeZExtent[1]) edges = (0, utils_1.zIndexOrdering)(edgeZExtent, function (edge) {\n      return _this.edgeDataCache[edge].zIndex;\n    }, edges);\n    for (var i = 0, l = edges.length; i < l; i++) {\n      var edge = edges[i];\n      var data = this.edgeDataCache[edge];\n      var extremities = graph.extremities(edge),\n        sourceData = this.nodeDataCache[extremities[0]],\n        targetData = this.nodeDataCache[extremities[1]];\n      var hidden = data.hidden || sourceData.hidden || targetData.hidden;\n      this.edgePrograms[data.type].process(sourceData, targetData, data, hidden, edgesPerPrograms[data.type]++);\n    }\n    for (var type in this.edgePrograms) {\n      var program = this.edgePrograms[type];\n      if (!keepArrays && typeof program.computeIndices === \"function\") program.computeIndices();\n    }\n    return this;\n  };\n  /**\n   * Method that backports potential settings updates where it's needed.\n   * @private\n   */\n  Sigma.prototype.handleSettingsUpdate = function () {\n    this.camera.minRatio = this.settings.minCameraRatio;\n    this.camera.maxRatio = this.settings.maxCameraRatio;\n    this.camera.setState(this.camera.validateState(this.camera.getState()));\n    return this;\n  };\n  /**\n   * Method that decides whether to reprocess graph or not, and then render the\n   * graph.\n   *\n   * @return {Sigma}\n   */\n  Sigma.prototype._refresh = function () {\n    // Do we need to process data?\n    if (this.needToProcess) {\n      this.process();\n    } else if (this.needToSoftProcess) {\n      this.process(true);\n    }\n    // Resetting state\n    this.needToProcess = false;\n    this.needToSoftProcess = false;\n    // Rendering\n    this.render();\n    return this;\n  };\n  /**\n   * Method that schedules a `_refresh` call if none has been scheduled yet. It\n   * will then be processed next available frame.\n   *\n   * @return {Sigma}\n   */\n  Sigma.prototype._scheduleRefresh = function () {\n    var _this = this;\n    if (!this.renderFrame) {\n      this.renderFrame = (0, utils_1.requestFrame)(function () {\n        _this._refresh();\n        _this.renderFrame = null;\n      });\n    }\n    return this;\n  };\n  /**\n   * Method used to render labels.\n   *\n   * @return {Sigma}\n   */\n  Sigma.prototype.renderLabels = function () {\n    if (!this.settings.renderLabels) return this;\n    var cameraState = this.camera.getState();\n    // Selecting labels to draw\n    var labelsToDisplay = this.labelGrid.getLabelsToDisplay(cameraState.ratio, this.settings.labelDensity);\n    (0, extend_1.default)(labelsToDisplay, this.nodesWithForcedLabels);\n    this.displayedLabels = new Set();\n    // Drawing labels\n    var context = this.canvasContexts.labels;\n    for (var i = 0, l = labelsToDisplay.length; i < l; i++) {\n      var node = labelsToDisplay[i];\n      var data = this.nodeDataCache[node];\n      // If the node was already drawn (like if it is eligible AND has\n      // `forceLabel`), we don't want to draw it again\n      // NOTE: we can do better probably\n      if (this.displayedLabels.has(node)) continue;\n      // If the node is hidden, we don't need to display its label obviously\n      if (data.hidden) continue;\n      var _a = this.framedGraphToViewport(data),\n        x = _a.x,\n        y = _a.y;\n      // NOTE: we can cache the labels we need to render until the camera's ratio changes\n      var size = this.scaleSize(data.size);\n      // Is node big enough?\n      if (!data.forceLabel && size < this.settings.labelRenderedSizeThreshold) continue;\n      // Is node actually on screen (with some margin)\n      // NOTE: we used to rely on the quadtree for this, but the coordinates\n      // conversion make it unreliable and at that point we already converted\n      // to viewport coordinates and since the label grid already culls the\n      // number of potential labels to display this looks like a good\n      // performance compromise.\n      // NOTE: labelGrid.getLabelsToDisplay could probably optimize by not\n      // considering cells obviously outside of the range of the current\n      // view rectangle.\n      if (x < -X_LABEL_MARGIN || x > this.width + X_LABEL_MARGIN || y < -Y_LABEL_MARGIN || y > this.height + Y_LABEL_MARGIN) continue;\n      // Because displayed edge labels depend directly on actually rendered node\n      // labels, we need to only add to this.displayedLabels nodes whose label\n      // is rendered.\n      // This makes this.displayedLabels depend on viewport, which might become\n      // an issue once we start memoizing getLabelsToDisplay.\n      this.displayedLabels.add(node);\n      this.settings.labelRenderer(context, __assign(__assign({\n        key: node\n      }, data), {\n        size: size,\n        x: x,\n        y: y\n      }), this.settings);\n    }\n    return this;\n  };\n  /**\n   * Method used to render edge labels, based on which node labels were\n   * rendered.\n   *\n   * @return {Sigma}\n   */\n  Sigma.prototype.renderEdgeLabels = function () {\n    if (!this.settings.renderEdgeLabels) return this;\n    var context = this.canvasContexts.edgeLabels;\n    // Clearing\n    context.clearRect(0, 0, this.width, this.height);\n    var edgeLabelsToDisplay = (0, labels_1.edgeLabelsToDisplayFromNodes)({\n      graph: this.graph,\n      hoveredNode: this.hoveredNode,\n      displayedNodeLabels: this.displayedLabels,\n      highlightedNodes: this.highlightedNodes\n    }).concat(this.edgesWithForcedLabels);\n    var displayedLabels = new Set();\n    for (var i = 0, l = edgeLabelsToDisplay.length; i < l; i++) {\n      var edge = edgeLabelsToDisplay[i],\n        extremities = this.graph.extremities(edge),\n        sourceData = this.nodeDataCache[extremities[0]],\n        targetData = this.nodeDataCache[extremities[1]],\n        edgeData = this.edgeDataCache[edge];\n      // If the edge was already drawn (like if it is eligible AND has\n      // `forceLabel`), we don't want to draw it again\n      if (displayedLabels.has(edge)) continue;\n      // If the edge is hidden we don't need to display its label\n      // NOTE: the test on sourceData & targetData is probably paranoid at this point?\n      if (edgeData.hidden || sourceData.hidden || targetData.hidden) {\n        continue;\n      }\n      this.settings.edgeLabelRenderer(context, __assign(__assign({\n        key: edge\n      }, edgeData), {\n        size: this.scaleSize(edgeData.size)\n      }), __assign(__assign(__assign({\n        key: extremities[0]\n      }, sourceData), this.framedGraphToViewport(sourceData)), {\n        size: this.scaleSize(sourceData.size)\n      }), __assign(__assign(__assign({\n        key: extremities[1]\n      }, targetData), this.framedGraphToViewport(targetData)), {\n        size: this.scaleSize(targetData.size)\n      }), this.settings);\n      displayedLabels.add(edge);\n    }\n    return this;\n  };\n  /**\n   * Method used to render the highlighted nodes.\n   *\n   * @return {Sigma}\n   */\n  Sigma.prototype.renderHighlightedNodes = function () {\n    var _this = this;\n    var context = this.canvasContexts.hovers;\n    // Clearing\n    context.clearRect(0, 0, this.width, this.height);\n    // Rendering\n    var render = function (node) {\n      var data = _this.nodeDataCache[node];\n      var _a = _this.framedGraphToViewport(data),\n        x = _a.x,\n        y = _a.y;\n      var size = _this.scaleSize(data.size);\n      _this.settings.hoverRenderer(context, __assign(__assign({\n        key: node\n      }, data), {\n        size: size,\n        x: x,\n        y: y\n      }), _this.settings);\n    };\n    var nodesToRender = [];\n    if (this.hoveredNode && !this.nodeDataCache[this.hoveredNode].hidden) {\n      nodesToRender.push(this.hoveredNode);\n    }\n    this.highlightedNodes.forEach(function (node) {\n      // The hovered node has already been highlighted\n      if (node !== _this.hoveredNode) nodesToRender.push(node);\n    });\n    // Draw labels:\n    nodesToRender.forEach(function (node) {\n      return render(node);\n    });\n    // Draw WebGL nodes on top of the labels:\n    var nodesPerPrograms = {};\n    // 1. Count nodes per type:\n    nodesToRender.forEach(function (node) {\n      var type = _this.nodeDataCache[node].type;\n      nodesPerPrograms[type] = (nodesPerPrograms[type] || 0) + 1;\n    });\n    // 2. Allocate for each type for the proper number of nodes\n    for (var type in this.nodeHoverPrograms) {\n      this.nodeHoverPrograms[type].allocate(nodesPerPrograms[type] || 0);\n      // Also reset count, to use when rendering:\n      nodesPerPrograms[type] = 0;\n    }\n    // 3. Process all nodes to render:\n    nodesToRender.forEach(function (node) {\n      var data = _this.nodeDataCache[node];\n      _this.nodeHoverPrograms[data.type].process(data, data.hidden, nodesPerPrograms[data.type]++);\n    });\n    // 4. Clear hovered nodes layer:\n    this.webGLContexts.hoverNodes.clear(this.webGLContexts.hoverNodes.COLOR_BUFFER_BIT);\n    // 5. Render:\n    for (var type in this.nodeHoverPrograms) {\n      var program = this.nodeHoverPrograms[type];\n      program.bind();\n      program.bufferData();\n      program.render({\n        matrix: this.matrix,\n        width: this.width,\n        height: this.height,\n        ratio: this.camera.ratio,\n        correctionRatio: this.correctionRatio / this.camera.ratio,\n        scalingRatio: this.pixelRatio\n      });\n    }\n  };\n  /**\n   * Method used to schedule a hover render.\n   *\n   */\n  Sigma.prototype.scheduleHighlightedNodesRender = function () {\n    var _this = this;\n    if (this.renderHighlightedNodesFrame || this.renderFrame) return;\n    this.renderHighlightedNodesFrame = (0, utils_1.requestFrame)(function () {\n      // Resetting state\n      _this.renderHighlightedNodesFrame = null;\n      // Rendering\n      _this.renderHighlightedNodes();\n      _this.renderEdgeLabels();\n    });\n  };\n  /**\n   * Method used to render.\n   *\n   * @return {Sigma}\n   */\n  Sigma.prototype.render = function () {\n    var _this = this;\n    this.emit(\"beforeRender\");\n    var exitRender = function () {\n      _this.emit(\"afterRender\");\n      return _this;\n    };\n    // If a render was scheduled, we cancel it\n    if (this.renderFrame) {\n      (0, utils_1.cancelFrame)(this.renderFrame);\n      this.renderFrame = null;\n      this.needToProcess = false;\n      this.needToSoftProcess = false;\n    }\n    // First we need to resize\n    this.resize();\n    // Clearing the canvases\n    this.clear();\n    // Recomputing useful camera-related values:\n    this.updateCachedValues();\n    // If we have no nodes we can stop right there\n    if (!this.graph.order) return exitRender();\n    // TODO: improve this heuristic or move to the captor itself?\n    // TODO: deal with the touch captor here as well\n    var mouseCaptor = this.mouseCaptor;\n    var moving = this.camera.isAnimated() || mouseCaptor.isMoving || mouseCaptor.draggedEvents || mouseCaptor.currentWheelDirection;\n    // Then we need to extract a matrix from the camera\n    var cameraState = this.camera.getState();\n    var viewportDimensions = this.getDimensions();\n    var graphDimensions = this.getGraphDimensions();\n    var padding = this.getSetting(\"stagePadding\") || 0;\n    this.matrix = (0, utils_1.matrixFromCamera)(cameraState, viewportDimensions, graphDimensions, padding);\n    this.invMatrix = (0, utils_1.matrixFromCamera)(cameraState, viewportDimensions, graphDimensions, padding, true);\n    this.correctionRatio = (0, utils_1.getMatrixImpact)(this.matrix, cameraState, viewportDimensions);\n    // Drawing nodes\n    for (var type in this.nodePrograms) {\n      var program = this.nodePrograms[type];\n      program.bind();\n      program.bufferData();\n      program.render({\n        matrix: this.matrix,\n        width: this.width,\n        height: this.height,\n        ratio: cameraState.ratio,\n        correctionRatio: this.correctionRatio / cameraState.ratio,\n        scalingRatio: this.pixelRatio\n      });\n    }\n    // Drawing edges\n    if (!this.settings.hideEdgesOnMove || !moving) {\n      for (var type in this.edgePrograms) {\n        var program = this.edgePrograms[type];\n        program.bind();\n        program.bufferData();\n        program.render({\n          matrix: this.matrix,\n          width: this.width,\n          height: this.height,\n          ratio: cameraState.ratio,\n          correctionRatio: this.correctionRatio / cameraState.ratio,\n          scalingRatio: this.pixelRatio\n        });\n      }\n    }\n    // Do not display labels on move per setting\n    if (this.settings.hideLabelsOnMove && moving) return exitRender();\n    this.renderLabels();\n    this.renderEdgeLabels();\n    this.renderHighlightedNodes();\n    return exitRender();\n  };\n  /**\n   * Internal method used to update expensive and therefore cached values\n   * each time the camera state is updated.\n   */\n  Sigma.prototype.updateCachedValues = function () {\n    var ratio = this.camera.getState().ratio;\n    this.cameraSizeRatio = Math.sqrt(ratio);\n  };\n  /**---------------------------------------------------------------------------\n   * Public API.\n   **---------------------------------------------------------------------------\n   */\n  /**\n   * Method returning the renderer's camera.\n   *\n   * @return {Camera}\n   */\n  Sigma.prototype.getCamera = function () {\n    return this.camera;\n  };\n  /**\n   * Method returning the container DOM element.\n   *\n   * @return {HTMLElement}\n   */\n  Sigma.prototype.getContainer = function () {\n    return this.container;\n  };\n  /**\n   * Method returning the renderer's graph.\n   *\n   * @return {Graph}\n   */\n  Sigma.prototype.getGraph = function () {\n    return this.graph;\n  };\n  /**\n   * Method used to set the renderer's graph.\n   *\n   * @return {Graph}\n   */\n  Sigma.prototype.setGraph = function (graph) {\n    if (graph === this.graph) return;\n    // Unbinding handlers on the current graph\n    this.unbindGraphHandlers();\n    // Clearing the graph data caches\n    this.nodeDataCache = {};\n    this.edgeDataCache = {};\n    // Cleaning renderer state tied to the current graph\n    this.displayedLabels.clear();\n    this.highlightedNodes.clear();\n    this.hoveredNode = null;\n    this.hoveredEdge = null;\n    this.nodesWithForcedLabels.length = 0;\n    this.edgesWithForcedLabels.length = 0;\n    if (this.checkEdgesEventsFrame !== null) {\n      (0, utils_1.cancelFrame)(this.checkEdgesEventsFrame);\n      this.checkEdgesEventsFrame = null;\n    }\n    // Installing new graph\n    this.graph = graph;\n    // Binding new handlers\n    this.bindGraphHandlers();\n    // Re-rendering now to avoid discrepancies from now to next frame\n    this.process();\n    this.render();\n  };\n  /**\n   * Method returning the mouse captor.\n   *\n   * @return {MouseCaptor}\n   */\n  Sigma.prototype.getMouseCaptor = function () {\n    return this.mouseCaptor;\n  };\n  /**\n   * Method returning the touch captor.\n   *\n   * @return {TouchCaptor}\n   */\n  Sigma.prototype.getTouchCaptor = function () {\n    return this.touchCaptor;\n  };\n  /**\n   * Method returning the current renderer's dimensions.\n   *\n   * @return {Dimensions}\n   */\n  Sigma.prototype.getDimensions = function () {\n    return {\n      width: this.width,\n      height: this.height\n    };\n  };\n  /**\n   * Method returning the current graph's dimensions.\n   *\n   * @return {Dimensions}\n   */\n  Sigma.prototype.getGraphDimensions = function () {\n    var extent = this.customBBox || this.nodeExtent;\n    return {\n      width: extent.x[1] - extent.x[0] || 1,\n      height: extent.y[1] - extent.y[0] || 1\n    };\n  };\n  /**\n   * Method used to get all the sigma node attributes.\n   * It's usefull for example to get the position of a node\n   * and to get values that are set by the nodeReducer\n   *\n   * @param  {string} key - The node's key.\n   * @return {NodeDisplayData | undefined} A copy of the desired node's attribute or undefined if not found\n   */\n  Sigma.prototype.getNodeDisplayData = function (key) {\n    var node = this.nodeDataCache[key];\n    return node ? Object.assign({}, node) : undefined;\n  };\n  /**\n   * Method used to get all the sigma edge attributes.\n   * It's usefull for example to get values that are set by the edgeReducer.\n   *\n   * @param  {string} key - The edge's key.\n   * @return {EdgeDisplayData | undefined} A copy of the desired edge's attribute or undefined if not found\n   */\n  Sigma.prototype.getEdgeDisplayData = function (key) {\n    var edge = this.edgeDataCache[key];\n    return edge ? Object.assign({}, edge) : undefined;\n  };\n  /**\n   * Method returning a copy of the settings collection.\n   *\n   * @return {Settings} A copy of the settings collection.\n   */\n  Sigma.prototype.getSettings = function () {\n    return __assign({}, this.settings);\n  };\n  /**\n   * Method returning the current value for a given setting key.\n   *\n   * @param  {string} key - The setting key to get.\n   * @return {any} The value attached to this setting key or undefined if not found\n   */\n  Sigma.prototype.getSetting = function (key) {\n    return this.settings[key];\n  };\n  /**\n   * Method setting the value of a given setting key. Note that this will schedule\n   * a new render next frame.\n   *\n   * @param  {string} key - The setting key to set.\n   * @param  {any}    value - The value to set.\n   * @return {Sigma}\n   */\n  Sigma.prototype.setSetting = function (key, value) {\n    this.settings[key] = value;\n    (0, settings_1.validateSettings)(this.settings);\n    this.handleSettingsUpdate();\n    this.needToProcess = true; // TODO: some keys may work with only needToSoftProcess or even nothing\n    this._scheduleRefresh();\n    return this;\n  };\n  /**\n   * Method updating the value of a given setting key using the provided function.\n   * Note that this will schedule a new render next frame.\n   *\n   * @param  {string}   key     - The setting key to set.\n   * @param  {function} updater - The update function.\n   * @return {Sigma}\n   */\n  Sigma.prototype.updateSetting = function (key, updater) {\n    this.settings[key] = updater(this.settings[key]);\n    (0, settings_1.validateSettings)(this.settings);\n    this.handleSettingsUpdate();\n    this.needToProcess = true; // TODO: some keys may work with only needToSoftProcess or even nothing\n    this._scheduleRefresh();\n    return this;\n  };\n  /**\n   * Method used to resize the renderer.\n   *\n   * @return {Sigma}\n   */\n  Sigma.prototype.resize = function () {\n    var previousWidth = this.width,\n      previousHeight = this.height;\n    this.width = this.container.offsetWidth;\n    this.height = this.container.offsetHeight;\n    this.pixelRatio = (0, utils_1.getPixelRatio)();\n    if (this.width === 0) {\n      if (this.settings.allowInvalidContainer) this.width = 1;else throw new Error(\"Sigma: Container has no width. You can set the allowInvalidContainer setting to true to stop seeing this error.\");\n    }\n    if (this.height === 0) {\n      if (this.settings.allowInvalidContainer) this.height = 1;else throw new Error(\"Sigma: Container has no height. You can set the allowInvalidContainer setting to true to stop seeing this error.\");\n    }\n    // If nothing has changed, we can stop right here\n    if (previousWidth === this.width && previousHeight === this.height) return this;\n    this.emit(\"resize\");\n    // Sizing dom elements\n    for (var id in this.elements) {\n      var element = this.elements[id];\n      element.style.width = this.width + \"px\";\n      element.style.height = this.height + \"px\";\n    }\n    // Sizing canvas contexts\n    for (var id in this.canvasContexts) {\n      this.elements[id].setAttribute(\"width\", this.width * this.pixelRatio + \"px\");\n      this.elements[id].setAttribute(\"height\", this.height * this.pixelRatio + \"px\");\n      if (this.pixelRatio !== 1) this.canvasContexts[id].scale(this.pixelRatio, this.pixelRatio);\n    }\n    // Sizing WebGL contexts\n    for (var id in this.webGLContexts) {\n      this.elements[id].setAttribute(\"width\", this.width * this.pixelRatio + \"px\");\n      this.elements[id].setAttribute(\"height\", this.height * this.pixelRatio + \"px\");\n      this.webGLContexts[id].viewport(0, 0, this.width * this.pixelRatio, this.height * this.pixelRatio);\n    }\n    return this;\n  };\n  /**\n   * Method used to clear all the canvases.\n   *\n   * @return {Sigma}\n   */\n  Sigma.prototype.clear = function () {\n    this.webGLContexts.nodes.clear(this.webGLContexts.nodes.COLOR_BUFFER_BIT);\n    this.webGLContexts.edges.clear(this.webGLContexts.edges.COLOR_BUFFER_BIT);\n    this.webGLContexts.hoverNodes.clear(this.webGLContexts.hoverNodes.COLOR_BUFFER_BIT);\n    this.canvasContexts.labels.clearRect(0, 0, this.width, this.height);\n    this.canvasContexts.hovers.clearRect(0, 0, this.width, this.height);\n    this.canvasContexts.edgeLabels.clearRect(0, 0, this.width, this.height);\n    return this;\n  };\n  /**\n   * Method used to refresh all computed data.\n   *\n   * @return {Sigma}\n   */\n  Sigma.prototype.refresh = function () {\n    this.needToProcess = true;\n    this._refresh();\n    return this;\n  };\n  /**\n   * Method used to refresh all computed data, at the next available frame.\n   * If this method has already been called this frame, then it will only render once at the next available frame.\n   *\n   * @return {Sigma}\n   */\n  Sigma.prototype.scheduleRefresh = function () {\n    this.needToProcess = true;\n    this._scheduleRefresh();\n    return this;\n  };\n  /**\n   * Method used to (un)zoom, while preserving the position of a viewport point.\n   * Used for instance to zoom \"on the mouse cursor\".\n   *\n   * @param viewportTarget\n   * @param newRatio\n   * @return {CameraState}\n   */\n  Sigma.prototype.getViewportZoomedState = function (viewportTarget, newRatio) {\n    var _a = this.camera.getState(),\n      ratio = _a.ratio,\n      angle = _a.angle,\n      x = _a.x,\n      y = _a.y;\n    // TODO: handle max zoom\n    var ratioDiff = newRatio / ratio;\n    var center = {\n      x: this.width / 2,\n      y: this.height / 2\n    };\n    var graphMousePosition = this.viewportToFramedGraph(viewportTarget);\n    var graphCenterPosition = this.viewportToFramedGraph(center);\n    return {\n      angle: angle,\n      x: (graphMousePosition.x - graphCenterPosition.x) * (1 - ratioDiff) + x,\n      y: (graphMousePosition.y - graphCenterPosition.y) * (1 - ratioDiff) + y,\n      ratio: newRatio\n    };\n  };\n  /**\n   * Method returning the abstract rectangle containing the graph according\n   * to the camera's state.\n   *\n   * @return {object} - The view's rectangle.\n   */\n  Sigma.prototype.viewRectangle = function () {\n    // TODO: reduce relative margin?\n    var marginX = 0 * this.width / 8,\n      marginY = 0 * this.height / 8;\n    var p1 = this.viewportToFramedGraph({\n        x: 0 - marginX,\n        y: 0 - marginY\n      }),\n      p2 = this.viewportToFramedGraph({\n        x: this.width + marginX,\n        y: 0 - marginY\n      }),\n      h = this.viewportToFramedGraph({\n        x: 0,\n        y: this.height + marginY\n      });\n    return {\n      x1: p1.x,\n      y1: p1.y,\n      x2: p2.x,\n      y2: p2.y,\n      height: p2.y - h.y\n    };\n  };\n  /**\n   * Method returning the coordinates of a point from the framed graph system to the viewport system. It allows\n   * overriding anything that is used to get the translation matrix, or even the matrix itself.\n   *\n   * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest\n   * of computations.\n   */\n  Sigma.prototype.framedGraphToViewport = function (coordinates, override) {\n    if (override === void 0) {\n      override = {};\n    }\n    var recomputeMatrix = !!override.cameraState || !!override.viewportDimensions || !!override.graphDimensions;\n    var matrix = override.matrix ? override.matrix : recomputeMatrix ? (0, utils_1.matrixFromCamera)(override.cameraState || this.camera.getState(), override.viewportDimensions || this.getDimensions(), override.graphDimensions || this.getGraphDimensions(), override.padding || this.getSetting(\"stagePadding\") || 0) : this.matrix;\n    var viewportPos = (0, matrices_1.multiplyVec2)(matrix, coordinates);\n    return {\n      x: (1 + viewportPos.x) * this.width / 2,\n      y: (1 - viewportPos.y) * this.height / 2\n    };\n  };\n  /**\n   * Method returning the coordinates of a point from the viewport system to the framed graph system. It allows\n   * overriding anything that is used to get the translation matrix, or even the matrix itself.\n   *\n   * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest\n   * of computations.\n   */\n  Sigma.prototype.viewportToFramedGraph = function (coordinates, override) {\n    if (override === void 0) {\n      override = {};\n    }\n    var recomputeMatrix = !!override.cameraState || !!override.viewportDimensions || !override.graphDimensions;\n    var invMatrix = override.matrix ? override.matrix : recomputeMatrix ? (0, utils_1.matrixFromCamera)(override.cameraState || this.camera.getState(), override.viewportDimensions || this.getDimensions(), override.graphDimensions || this.getGraphDimensions(), override.padding || this.getSetting(\"stagePadding\") || 0, true) : this.invMatrix;\n    var res = (0, matrices_1.multiplyVec2)(invMatrix, {\n      x: coordinates.x / this.width * 2 - 1,\n      y: 1 - coordinates.y / this.height * 2\n    });\n    if (isNaN(res.x)) res.x = 0;\n    if (isNaN(res.y)) res.y = 0;\n    return res;\n  };\n  /**\n   * Method used to translate a point's coordinates from the viewport system (pixel distance from the top-left of the\n   * stage) to the graph system (the reference system of data as they are in the given graph instance).\n   *\n   * This method accepts an optional camera which can be useful if you need to translate coordinates\n   * based on a different view than the one being currently being displayed on screen.\n   *\n   * @param {Coordinates}                  viewportPoint\n   * @param {CoordinateConversionOverride} override\n   */\n  Sigma.prototype.viewportToGraph = function (viewportPoint, override) {\n    if (override === void 0) {\n      override = {};\n    }\n    return this.normalizationFunction.inverse(this.viewportToFramedGraph(viewportPoint, override));\n  };\n  /**\n   * Method used to translate a point's coordinates from the graph system (the reference system of data as they are in\n   * the given graph instance) to the viewport system (pixel distance from the top-left of the stage).\n   *\n   * This method accepts an optional camera which can be useful if you need to translate coordinates\n   * based on a different view than the one being currently being displayed on screen.\n   *\n   * @param {Coordinates}                  graphPoint\n   * @param {CoordinateConversionOverride} override\n   */\n  Sigma.prototype.graphToViewport = function (graphPoint, override) {\n    if (override === void 0) {\n      override = {};\n    }\n    return this.framedGraphToViewport(this.normalizationFunction(graphPoint), override);\n  };\n  /**\n   * Method returning the graph's bounding box.\n   *\n   * @return {{ x: Extent, y: Extent }}\n   */\n  Sigma.prototype.getBBox = function () {\n    return (0, utils_1.graphExtent)(this.graph);\n  };\n  /**\n   * Method returning the graph's custom bounding box, if any.\n   *\n   * @return {{ x: Extent, y: Extent } | null}\n   */\n  Sigma.prototype.getCustomBBox = function () {\n    return this.customBBox;\n  };\n  /**\n   * Method used to override the graph's bounding box with a custom one. Give `null` as the argument to stop overriding.\n   *\n   * @return {Sigma}\n   */\n  Sigma.prototype.setCustomBBox = function (customBBox) {\n    this.customBBox = customBBox;\n    this._scheduleRefresh();\n    return this;\n  };\n  /**\n   * Method used to shut the container & release event listeners.\n   *\n   * @return {undefined}\n   */\n  Sigma.prototype.kill = function () {\n    // Emitting \"kill\" events so that plugins and such can cleanup\n    this.emit(\"kill\");\n    // Releasing events\n    this.removeAllListeners();\n    // Releasing camera handlers\n    this.camera.removeListener(\"updated\", this.activeListeners.camera);\n    // Releasing DOM events & captors\n    window.removeEventListener(\"resize\", this.activeListeners.handleResize);\n    this.mouseCaptor.kill();\n    this.touchCaptor.kill();\n    // Releasing graph handlers\n    this.unbindGraphHandlers();\n    // Releasing cache & state\n    this.quadtree = new quadtree_1.default();\n    this.nodeDataCache = {};\n    this.edgeDataCache = {};\n    this.nodesWithForcedLabels = [];\n    this.edgesWithForcedLabels = [];\n    this.highlightedNodes.clear();\n    // Clearing frames\n    if (this.renderFrame) {\n      (0, utils_1.cancelFrame)(this.renderFrame);\n      this.renderFrame = null;\n    }\n    if (this.renderHighlightedNodesFrame) {\n      (0, utils_1.cancelFrame)(this.renderHighlightedNodesFrame);\n      this.renderHighlightedNodesFrame = null;\n    }\n    // Destroying canvases\n    var container = this.container;\n    while (container.firstChild) container.removeChild(container.firstChild);\n  };\n  /**\n   * Method used to scale the given size according to the camera's ratio, i.e.\n   * zooming state.\n   *\n   * @param  {number} size - The size to scale (node size, edge thickness etc.).\n   * @return {number}      - The scaled size.\n   */\n  Sigma.prototype.scaleSize = function (size) {\n    return size / this.cameraSizeRatio;\n  };\n  /**\n   * Method that returns the collection of all used canvases.\n   * At the moment, the instantiated canvases are the following, and in the\n   * following order in the DOM:\n   * - `edges`\n   * - `nodes`\n   * - `edgeLabels`\n   * - `labels`\n   * - `hovers`\n   * - `hoverNodes`\n   * - `mouse`\n   *\n   * @return {PlainObject<HTMLCanvasElement>} - The collection of canvases.\n   */\n  Sigma.prototype.getCanvases = function () {\n    return __assign({}, this.elements);\n  };\n  return Sigma;\n}(types_1.TypedEventEmitter);\nexports.default = Sigma;","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","__assign","assign","t","s","i","n","arguments","length","apply","__values","o","Symbol","iterator","m","next","value","done","__importDefault","mod","__esModule","defineProperty","exports","extend_1","require","camera_1","mouse_1","quadtree_1","types_1","utils_1","labels_1","settings_1","touch_1","matrices_1","edge_collisions_1","X_LABEL_MARGIN","Y_LABEL_MARGIN","applyNodeDefaults","settings","key","data","Error","concat","color","defaultNodeColor","label","undefined","size","hidden","highlighted","forceLabel","type","defaultNodeType","zIndex","applyEdgeDefaults","defaultEdgeColor","defaultEdgeType","Sigma","_super","graph","container","_this","elements","canvasContexts","webGLContexts","activeListeners","quadtree","default","labelGrid","LabelGrid","nodeDataCache","edgeDataCache","nodesWithForcedLabels","edgesWithForcedLabels","nodeExtent","x","y","matrix","identity","invMatrix","correctionRatio","customBBox","normalizationFunction","createNormalizationFunction","cameraSizeRatio","width","height","pixelRatio","getPixelRatio","displayedLabels","Set","highlightedNodes","hoveredNode","hoveredEdge","renderFrame","renderHighlightedNodesFrame","needToProcess","needToSoftProcess","checkEdgesEventsFrame","nodePrograms","nodeHoverPrograms","edgePrograms","resolveSettings","validateSettings","validateGraph","HTMLElement","createWebGLContext","preserveDrawingBuffer","createCanvasContext","gl","blendFunc","ONE","ONE_MINUS_SRC_ALPHA","enable","BLEND","nodeProgramClasses","NodeProgramClass","nodes","NodeHoverProgram","nodeHoverProgramClasses","hoverNodes","edgeProgramClasses","EdgeProgramClass","edges","resize","camera","bindCameraHandlers","mouseCaptor","mouse","touchCaptor","bindEventHandlers","bindGraphHandlers","handleSettingsUpdate","process","render","createCanvas","id","canvas","createElement","position","class","appendChild","contextOptions","antialias","getContext","options","context","_scheduleRefresh","on","mouseIsOnNode","_a","_b","nodeX","nodeY","Math","sqrt","pow","getQuadNodes","mouseGraphPosition","viewportToFramedGraph","point","getNodeAtPosition","quadNodes","minDistance","Infinity","nodeAtPosition","l","node","nodePosition","framedGraphToViewport","scaleSize","distance","handleResize","window","addEventListener","handleMove","e","baseEvent","event","preventSigmaDefault","nodeToHover","emit","scheduleHighlightedNodesRender","pos","enableEdgeHoverEvents","checkEdgeHoverEvents","requestFrame","createMouseListener","eventType","isFakeSigmaMouseEvent","original","enableEdgeWheelEvents","enableEdgeClickEvents","edge","getEdgeAtPoint","handleClick","handleRightClick","handleDoubleClick","handleWheel","handleDown","graphUpdate","softGraphUpdate","dropNodeGraphUpdate","dropEdgeGraphUpdate","clearEdgesGraphUpdate","clearGraphUpdate","unbindGraphHandlers","removeListener","payload","edgeToHover","e_1","isPixelColored","_c","viewportToGraph","graphX","graphY","transformationRatio","someEdge","_","sourceId","targetId","xs","ys","xt","yt","graphLength","graphToViewport","vp_xs","vp_ys","_d","vp_xt","vp_yt","viewportLength","filterEdges","edgeAttributes","sourcePosition","targetPosition","doEdgeCollideWithPoint","selectedEdge","highestZIndex","edges_1","edges_1_1","getEdgeAttribute","e_1_1","error","return","keepArrays","dimensions","getDimensions","nodeZExtent","edgeZExtent","clear","resizeAndClear","labelGridCellSize","graphExtent","nullCamera","nullCameraMatrix","matrixFromCamera","getState","getGraphDimensions","getSetting","nodesPerPrograms","attr","getNodeAttributes","nodeReducer","applyTo","push","allocate","zIndexOrdering","add","nodeProgram","organize","edgesPerPrograms","getEdgeAttributes","edgeReducer","extremities","sourceData","targetData","program","computeIndices","minRatio","minCameraRatio","maxRatio","maxCameraRatio","setState","validateState","_refresh","renderLabels","cameraState","labelsToDisplay","getLabelsToDisplay","ratio","labelDensity","labels","has","labelRenderedSizeThreshold","labelRenderer","renderEdgeLabels","edgeLabels","clearRect","edgeLabelsToDisplay","edgeLabelsToDisplayFromNodes","displayedNodeLabels","edgeData","edgeLabelRenderer","renderHighlightedNodes","hovers","hoverRenderer","nodesToRender","forEach","COLOR_BUFFER_BIT","bind","bufferData","scalingRatio","exitRender","cancelFrame","updateCachedValues","order","moving","isAnimated","isMoving","draggedEvents","currentWheelDirection","viewportDimensions","graphDimensions","padding","getMatrixImpact","hideEdgesOnMove","hideLabelsOnMove","getCamera","getContainer","getGraph","setGraph","getMouseCaptor","getTouchCaptor","extent","getNodeDisplayData","getEdgeDisplayData","getSettings","setSetting","updateSetting","updater","previousWidth","previousHeight","offsetWidth","offsetHeight","allowInvalidContainer","element","style","setAttribute","scale","viewport","refresh","scheduleRefresh","getViewportZoomedState","viewportTarget","newRatio","angle","ratioDiff","center","graphMousePosition","graphCenterPosition","viewRectangle","marginX","marginY","p1","p2","h","x1","y1","x2","y2","coordinates","override","recomputeMatrix","viewportPos","multiplyVec2","res","isNaN","viewportPoint","inverse","graphPoint","getBBox","getCustomBBox","setCustomBBox","kill","removeAllListeners","removeEventListener","firstChild","removeChild","getCanvases","TypedEventEmitter"],"sources":["/Users/radhika.bajaj/Documents/GitHub/Knowledge-Graph-Frontend/node_modules/sigma/sigma.js"],"sourcesContent":["\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend_1 = __importDefault(require(\"@yomguithereal/helpers/extend\"));\nvar camera_1 = __importDefault(require(\"./core/camera\"));\nvar mouse_1 = __importDefault(require(\"./core/captors/mouse\"));\nvar quadtree_1 = __importDefault(require(\"./core/quadtree\"));\nvar types_1 = require(\"./types\");\nvar utils_1 = require(\"./utils\");\nvar labels_1 = require(\"./core/labels\");\nvar settings_1 = require(\"./settings\");\nvar touch_1 = __importDefault(require(\"./core/captors/touch\"));\nvar matrices_1 = require(\"./utils/matrices\");\nvar edge_collisions_1 = require(\"./utils/edge-collisions\");\n/**\n * Constants.\n */\nvar X_LABEL_MARGIN = 150;\nvar Y_LABEL_MARGIN = 50;\n/**\n * Important functions.\n */\nfunction applyNodeDefaults(settings, key, data) {\n    if (!data.hasOwnProperty(\"x\") || !data.hasOwnProperty(\"y\"))\n        throw new Error(\"Sigma: could not find a valid position (x, y) for node \\\"\".concat(key, \"\\\". All your nodes must have a number \\\"x\\\" and \\\"y\\\". Maybe your forgot to apply a layout or your \\\"nodeReducer\\\" is not returning the correct data?\"));\n    if (!data.color)\n        data.color = settings.defaultNodeColor;\n    if (!data.label && data.label !== \"\")\n        data.label = null;\n    if (data.label !== undefined && data.label !== null)\n        data.label = \"\" + data.label;\n    else\n        data.label = null;\n    if (!data.size)\n        data.size = 2;\n    if (!data.hasOwnProperty(\"hidden\"))\n        data.hidden = false;\n    if (!data.hasOwnProperty(\"highlighted\"))\n        data.highlighted = false;\n    if (!data.hasOwnProperty(\"forceLabel\"))\n        data.forceLabel = false;\n    if (!data.type || data.type === \"\")\n        data.type = settings.defaultNodeType;\n    if (!data.zIndex)\n        data.zIndex = 0;\n    return data;\n}\nfunction applyEdgeDefaults(settings, key, data) {\n    if (!data.color)\n        data.color = settings.defaultEdgeColor;\n    if (!data.label)\n        data.label = \"\";\n    if (!data.size)\n        data.size = 0.5;\n    if (!data.hasOwnProperty(\"hidden\"))\n        data.hidden = false;\n    if (!data.hasOwnProperty(\"forceLabel\"))\n        data.forceLabel = false;\n    if (!data.type || data.type === \"\")\n        data.type = settings.defaultEdgeType;\n    if (!data.zIndex)\n        data.zIndex = 0;\n    return data;\n}\n/**\n * Main class.\n *\n * @constructor\n * @param {Graph}       graph     - Graph to render.\n * @param {HTMLElement} container - DOM container in which to render.\n * @param {object}      settings  - Optional settings.\n */\nvar Sigma = /** @class */ (function (_super) {\n    __extends(Sigma, _super);\n    function Sigma(graph, container, settings) {\n        if (settings === void 0) { settings = {}; }\n        var _this = _super.call(this) || this;\n        _this.elements = {};\n        _this.canvasContexts = {};\n        _this.webGLContexts = {};\n        _this.activeListeners = {};\n        _this.quadtree = new quadtree_1.default();\n        _this.labelGrid = new labels_1.LabelGrid();\n        _this.nodeDataCache = {};\n        _this.edgeDataCache = {};\n        _this.nodesWithForcedLabels = [];\n        _this.edgesWithForcedLabels = [];\n        _this.nodeExtent = { x: [0, 1], y: [0, 1] };\n        _this.matrix = (0, matrices_1.identity)();\n        _this.invMatrix = (0, matrices_1.identity)();\n        _this.correctionRatio = 1;\n        _this.customBBox = null;\n        _this.normalizationFunction = (0, utils_1.createNormalizationFunction)({\n            x: [0, 1],\n            y: [0, 1],\n        });\n        // Cache:\n        _this.cameraSizeRatio = 1;\n        // Starting dimensions and pixel ratio\n        _this.width = 0;\n        _this.height = 0;\n        _this.pixelRatio = (0, utils_1.getPixelRatio)();\n        // State\n        _this.displayedLabels = new Set();\n        _this.highlightedNodes = new Set();\n        _this.hoveredNode = null;\n        _this.hoveredEdge = null;\n        _this.renderFrame = null;\n        _this.renderHighlightedNodesFrame = null;\n        _this.needToProcess = false;\n        _this.needToSoftProcess = false;\n        _this.checkEdgesEventsFrame = null;\n        // Programs\n        _this.nodePrograms = {};\n        _this.nodeHoverPrograms = {};\n        _this.edgePrograms = {};\n        // Resolving settings\n        _this.settings = (0, settings_1.resolveSettings)(settings);\n        // Validating\n        (0, settings_1.validateSettings)(_this.settings);\n        (0, utils_1.validateGraph)(graph);\n        if (!(container instanceof HTMLElement))\n            throw new Error(\"Sigma: container should be an html element.\");\n        // Properties\n        _this.graph = graph;\n        _this.container = container;\n        // Initializing contexts\n        _this.createWebGLContext(\"edges\", { preserveDrawingBuffer: true });\n        _this.createCanvasContext(\"edgeLabels\");\n        _this.createWebGLContext(\"nodes\");\n        _this.createCanvasContext(\"labels\");\n        _this.createCanvasContext(\"hovers\");\n        _this.createWebGLContext(\"hoverNodes\");\n        _this.createCanvasContext(\"mouse\");\n        // Blending\n        for (var key in _this.webGLContexts) {\n            var gl = _this.webGLContexts[key];\n            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n            gl.enable(gl.BLEND);\n        }\n        // Loading programs\n        for (var type in _this.settings.nodeProgramClasses) {\n            var NodeProgramClass = _this.settings.nodeProgramClasses[type];\n            _this.nodePrograms[type] = new NodeProgramClass(_this.webGLContexts.nodes, _this);\n            var NodeHoverProgram = NodeProgramClass;\n            if (type in _this.settings.nodeHoverProgramClasses) {\n                NodeHoverProgram = _this.settings.nodeHoverProgramClasses[type];\n            }\n            _this.nodeHoverPrograms[type] = new NodeHoverProgram(_this.webGLContexts.hoverNodes, _this);\n        }\n        for (var type in _this.settings.edgeProgramClasses) {\n            var EdgeProgramClass = _this.settings.edgeProgramClasses[type];\n            _this.edgePrograms[type] = new EdgeProgramClass(_this.webGLContexts.edges, _this);\n        }\n        // Initial resize\n        _this.resize();\n        // Initializing the camera\n        _this.camera = new camera_1.default();\n        // Binding camera events\n        _this.bindCameraHandlers();\n        // Initializing captors\n        _this.mouseCaptor = new mouse_1.default(_this.elements.mouse, _this);\n        _this.touchCaptor = new touch_1.default(_this.elements.mouse, _this);\n        // Binding event handlers\n        _this.bindEventHandlers();\n        // Binding graph handlers\n        _this.bindGraphHandlers();\n        // Trigger eventual settings-related things\n        _this.handleSettingsUpdate();\n        // Processing data for the first time & render\n        _this.process();\n        _this.render();\n        return _this;\n    }\n    /**---------------------------------------------------------------------------\n     * Internal methods.\n     **---------------------------------------------------------------------------\n     */\n    /**\n     * Internal function used to create a canvas element.\n     * @param  {string} id - Context's id.\n     * @return {Sigma}\n     */\n    Sigma.prototype.createCanvas = function (id) {\n        var canvas = (0, utils_1.createElement)(\"canvas\", {\n            position: \"absolute\",\n        }, {\n            class: \"sigma-\".concat(id),\n        });\n        this.elements[id] = canvas;\n        this.container.appendChild(canvas);\n        return canvas;\n    };\n    /**\n     * Internal function used to create a canvas context and add the relevant\n     * DOM elements.\n     *\n     * @param  {string} id - Context's id.\n     * @return {Sigma}\n     */\n    Sigma.prototype.createCanvasContext = function (id) {\n        var canvas = this.createCanvas(id);\n        var contextOptions = {\n            preserveDrawingBuffer: false,\n            antialias: false,\n        };\n        this.canvasContexts[id] = canvas.getContext(\"2d\", contextOptions);\n        return this;\n    };\n    /**\n     * Internal function used to create a canvas context and add the relevant\n     * DOM elements.\n     *\n     * @param  {string}  id      - Context's id.\n     * @param  {object?} options - #getContext params to override (optional)\n     * @return {Sigma}\n     */\n    Sigma.prototype.createWebGLContext = function (id, options) {\n        var canvas = this.createCanvas(id);\n        var contextOptions = __assign({ preserveDrawingBuffer: false, antialias: false }, (options || {}));\n        var context;\n        // First we try webgl2 for an easy performance boost\n        context = canvas.getContext(\"webgl2\", contextOptions);\n        // Else we fall back to webgl\n        if (!context)\n            context = canvas.getContext(\"webgl\", contextOptions);\n        // Edge, I am looking right at you...\n        if (!context)\n            context = canvas.getContext(\"experimental-webgl\", contextOptions);\n        this.webGLContexts[id] = context;\n        return this;\n    };\n    /**\n     * Method binding camera handlers.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.bindCameraHandlers = function () {\n        var _this = this;\n        this.activeListeners.camera = function () {\n            _this._scheduleRefresh();\n        };\n        this.camera.on(\"updated\", this.activeListeners.camera);\n        return this;\n    };\n    /**\n     * Method that checks whether or not a node collides with a given position.\n     */\n    Sigma.prototype.mouseIsOnNode = function (_a, _b, size) {\n        var x = _a.x, y = _a.y;\n        var nodeX = _b.x, nodeY = _b.y;\n        return (x > nodeX - size &&\n            x < nodeX + size &&\n            y > nodeY - size &&\n            y < nodeY + size &&\n            Math.sqrt(Math.pow(x - nodeX, 2) + Math.pow(y - nodeY, 2)) < size);\n    };\n    /**\n     * Method that returns all nodes in quad at a given position.\n     */\n    Sigma.prototype.getQuadNodes = function (position) {\n        var mouseGraphPosition = this.viewportToFramedGraph(position);\n        return this.quadtree.point(mouseGraphPosition.x, 1 - mouseGraphPosition.y);\n    };\n    /**\n     * Method that returns the closest node to a given position.\n     */\n    Sigma.prototype.getNodeAtPosition = function (position) {\n        var x = position.x, y = position.y;\n        var quadNodes = this.getQuadNodes(position);\n        // We will hover the node whose center is closest to mouse\n        var minDistance = Infinity, nodeAtPosition = null;\n        for (var i = 0, l = quadNodes.length; i < l; i++) {\n            var node = quadNodes[i];\n            var data = this.nodeDataCache[node];\n            var nodePosition = this.framedGraphToViewport(data);\n            var size = this.scaleSize(data.size);\n            if (!data.hidden && this.mouseIsOnNode(position, nodePosition, size)) {\n                var distance = Math.sqrt(Math.pow(x - nodePosition.x, 2) + Math.pow(y - nodePosition.y, 2));\n                // TODO: sort by min size also for cases where center is the same\n                if (distance < minDistance) {\n                    minDistance = distance;\n                    nodeAtPosition = node;\n                }\n            }\n        }\n        return nodeAtPosition;\n    };\n    /**\n     * Method binding event handlers.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.bindEventHandlers = function () {\n        var _this = this;\n        // Handling window resize\n        this.activeListeners.handleResize = function () {\n            _this.needToSoftProcess = true;\n            _this._scheduleRefresh();\n        };\n        window.addEventListener(\"resize\", this.activeListeners.handleResize);\n        // Handling mouse move\n        this.activeListeners.handleMove = function (e) {\n            var baseEvent = {\n                event: e,\n                preventSigmaDefault: function () {\n                    e.preventSigmaDefault();\n                },\n            };\n            var nodeToHover = _this.getNodeAtPosition(e);\n            if (nodeToHover && _this.hoveredNode !== nodeToHover && !_this.nodeDataCache[nodeToHover].hidden) {\n                // Handling passing from one node to the other directly\n                if (_this.hoveredNode)\n                    _this.emit(\"leaveNode\", __assign(__assign({}, baseEvent), { node: _this.hoveredNode }));\n                _this.hoveredNode = nodeToHover;\n                _this.emit(\"enterNode\", __assign(__assign({}, baseEvent), { node: nodeToHover }));\n                _this.scheduleHighlightedNodesRender();\n                return;\n            }\n            // Checking if the hovered node is still hovered\n            if (_this.hoveredNode) {\n                var data = _this.nodeDataCache[_this.hoveredNode];\n                var pos = _this.framedGraphToViewport(data);\n                var size = _this.scaleSize(data.size);\n                if (!_this.mouseIsOnNode(e, pos, size)) {\n                    var node = _this.hoveredNode;\n                    _this.hoveredNode = null;\n                    _this.emit(\"leaveNode\", __assign(__assign({}, baseEvent), { node: node }));\n                    _this.scheduleHighlightedNodesRender();\n                    return;\n                }\n            }\n            if (_this.settings.enableEdgeHoverEvents === true) {\n                _this.checkEdgeHoverEvents(baseEvent);\n            }\n            else if (_this.settings.enableEdgeHoverEvents === \"debounce\") {\n                if (!_this.checkEdgesEventsFrame)\n                    _this.checkEdgesEventsFrame = (0, utils_1.requestFrame)(function () {\n                        _this.checkEdgeHoverEvents(baseEvent);\n                        _this.checkEdgesEventsFrame = null;\n                    });\n            }\n        };\n        // Handling click\n        var createMouseListener = function (eventType) {\n            return function (e) {\n                var baseEvent = {\n                    event: e,\n                    preventSigmaDefault: function () {\n                        e.preventSigmaDefault();\n                    },\n                };\n                var isFakeSigmaMouseEvent = e.original.isFakeSigmaMouseEvent;\n                var nodeAtPosition = isFakeSigmaMouseEvent ? _this.getNodeAtPosition(e) : _this.hoveredNode;\n                if (nodeAtPosition)\n                    return _this.emit(\"\".concat(eventType, \"Node\"), __assign(__assign({}, baseEvent), { node: nodeAtPosition }));\n                if (eventType === \"wheel\" ? _this.settings.enableEdgeWheelEvents : _this.settings.enableEdgeClickEvents) {\n                    var edge = _this.getEdgeAtPoint(e.x, e.y);\n                    if (edge)\n                        return _this.emit(\"\".concat(eventType, \"Edge\"), __assign(__assign({}, baseEvent), { edge: edge }));\n                }\n                return _this.emit(\"\".concat(eventType, \"Stage\"), baseEvent);\n            };\n        };\n        this.activeListeners.handleClick = createMouseListener(\"click\");\n        this.activeListeners.handleRightClick = createMouseListener(\"rightClick\");\n        this.activeListeners.handleDoubleClick = createMouseListener(\"doubleClick\");\n        this.activeListeners.handleWheel = createMouseListener(\"wheel\");\n        this.activeListeners.handleDown = createMouseListener(\"down\");\n        this.mouseCaptor.on(\"mousemove\", this.activeListeners.handleMove);\n        this.mouseCaptor.on(\"click\", this.activeListeners.handleClick);\n        this.mouseCaptor.on(\"rightClick\", this.activeListeners.handleRightClick);\n        this.mouseCaptor.on(\"doubleClick\", this.activeListeners.handleDoubleClick);\n        this.mouseCaptor.on(\"wheel\", this.activeListeners.handleWheel);\n        this.mouseCaptor.on(\"mousedown\", this.activeListeners.handleDown);\n        // TODO\n        // Deal with Touch captor events\n        return this;\n    };\n    /**\n     * Method binding graph handlers\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.bindGraphHandlers = function () {\n        var _this = this;\n        var graph = this.graph;\n        this.activeListeners.graphUpdate = function () {\n            _this.needToProcess = true;\n            _this._scheduleRefresh();\n        };\n        this.activeListeners.softGraphUpdate = function () {\n            _this.needToSoftProcess = true;\n            _this._scheduleRefresh();\n        };\n        this.activeListeners.dropNodeGraphUpdate = function (e) {\n            delete _this.nodeDataCache[e.key];\n            if (_this.hoveredNode === e.key)\n                _this.hoveredNode = null;\n            _this.activeListeners.graphUpdate();\n        };\n        this.activeListeners.dropEdgeGraphUpdate = function (e) {\n            delete _this.edgeDataCache[e.key];\n            if (_this.hoveredEdge === e.key)\n                _this.hoveredEdge = null;\n            _this.activeListeners.graphUpdate();\n        };\n        this.activeListeners.clearEdgesGraphUpdate = function () {\n            _this.edgeDataCache = {};\n            _this.hoveredEdge = null;\n            _this.activeListeners.graphUpdate();\n        };\n        this.activeListeners.clearGraphUpdate = function () {\n            _this.nodeDataCache = {};\n            _this.hoveredNode = null;\n            _this.activeListeners.clearEdgesGraphUpdate();\n        };\n        graph.on(\"nodeAdded\", this.activeListeners.graphUpdate);\n        graph.on(\"nodeDropped\", this.activeListeners.dropNodeGraphUpdate);\n        graph.on(\"nodeAttributesUpdated\", this.activeListeners.softGraphUpdate);\n        graph.on(\"eachNodeAttributesUpdated\", this.activeListeners.graphUpdate);\n        graph.on(\"edgeAdded\", this.activeListeners.graphUpdate);\n        graph.on(\"edgeDropped\", this.activeListeners.dropEdgeGraphUpdate);\n        graph.on(\"edgeAttributesUpdated\", this.activeListeners.softGraphUpdate);\n        graph.on(\"eachEdgeAttributesUpdated\", this.activeListeners.graphUpdate);\n        graph.on(\"edgesCleared\", this.activeListeners.clearEdgesGraphUpdate);\n        graph.on(\"cleared\", this.activeListeners.clearGraphUpdate);\n        return this;\n    };\n    /**\n     * Method used to unbind handlers from the graph.\n     *\n     * @return {undefined}\n     */\n    Sigma.prototype.unbindGraphHandlers = function () {\n        var graph = this.graph;\n        graph.removeListener(\"nodeAdded\", this.activeListeners.graphUpdate);\n        graph.removeListener(\"nodeDropped\", this.activeListeners.dropNodeGraphUpdate);\n        graph.removeListener(\"nodeAttributesUpdated\", this.activeListeners.softGraphUpdate);\n        graph.removeListener(\"eachNodeAttributesUpdated\", this.activeListeners.graphUpdate);\n        graph.removeListener(\"edgeAdded\", this.activeListeners.graphUpdate);\n        graph.removeListener(\"edgeDropped\", this.activeListeners.dropEdgeGraphUpdate);\n        graph.removeListener(\"edgeAttributesUpdated\", this.activeListeners.softGraphUpdate);\n        graph.removeListener(\"eachEdgeAttributesUpdated\", this.activeListeners.graphUpdate);\n        graph.removeListener(\"edgesCleared\", this.activeListeners.clearEdgesGraphUpdate);\n        graph.removeListener(\"cleared\", this.activeListeners.clearGraphUpdate);\n    };\n    /**\n     * Method dealing with \"leaveEdge\" and \"enterEdge\" events.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.checkEdgeHoverEvents = function (payload) {\n        var edgeToHover = this.hoveredNode ? null : this.getEdgeAtPoint(payload.event.x, payload.event.y);\n        if (edgeToHover !== this.hoveredEdge) {\n            if (this.hoveredEdge)\n                this.emit(\"leaveEdge\", __assign(__assign({}, payload), { edge: this.hoveredEdge }));\n            if (edgeToHover)\n                this.emit(\"enterEdge\", __assign(__assign({}, payload), { edge: edgeToHover }));\n            this.hoveredEdge = edgeToHover;\n        }\n        return this;\n    };\n    /**\n     * Method looking for an edge colliding with a given point at (x, y). Returns\n     * the key of the edge if any, or null else.\n     */\n    Sigma.prototype.getEdgeAtPoint = function (x, y) {\n        var e_1, _a;\n        var _this = this;\n        var _b = this, edgeDataCache = _b.edgeDataCache, nodeDataCache = _b.nodeDataCache;\n        // Check first that pixel is colored:\n        // Note that mouse positions must be corrected by pixel ratio to correctly\n        // index the drawing buffer.\n        if (!(0, edge_collisions_1.isPixelColored)(this.webGLContexts.edges, x * this.pixelRatio, y * this.pixelRatio))\n            return null;\n        // Check for each edge if it collides with the point:\n        var _c = this.viewportToGraph({ x: x, y: y }), graphX = _c.x, graphY = _c.y;\n        // To translate edge thicknesses to the graph system, we observe by how much\n        // the length of a non-null edge is transformed to between the graph system\n        // and the viewport system:\n        var transformationRatio = 0;\n        this.graph.someEdge(function (key, _, sourceId, targetId, _a, _b) {\n            var xs = _a.x, ys = _a.y;\n            var xt = _b.x, yt = _b.y;\n            if (edgeDataCache[key].hidden || nodeDataCache[sourceId].hidden || nodeDataCache[targetId].hidden)\n                return false;\n            if (xs !== xt || ys !== yt) {\n                var graphLength = Math.sqrt(Math.pow(xt - xs, 2) + Math.pow(yt - ys, 2));\n                var _c = _this.graphToViewport({ x: xs, y: ys }), vp_xs = _c.x, vp_ys = _c.y;\n                var _d = _this.graphToViewport({ x: xt, y: yt }), vp_xt = _d.x, vp_yt = _d.y;\n                var viewportLength = Math.sqrt(Math.pow(vp_xt - vp_xs, 2) + Math.pow(vp_yt - vp_ys, 2));\n                transformationRatio = graphLength / viewportLength;\n                return true;\n            }\n        });\n        // If no non-null edge has been found, return null:\n        if (!transformationRatio)\n            return null;\n        // Now we can look for matching edges:\n        var edges = this.graph.filterEdges(function (key, edgeAttributes, sourceId, targetId, sourcePosition, targetPosition) {\n            if (edgeDataCache[key].hidden || nodeDataCache[sourceId].hidden || nodeDataCache[targetId].hidden)\n                return false;\n            if ((0, edge_collisions_1.doEdgeCollideWithPoint)(graphX, graphY, sourcePosition.x, sourcePosition.y, targetPosition.x, targetPosition.y, \n            // Adapt the edge size to the zoom ratio:\n            (edgeDataCache[key].size * transformationRatio) / _this.cameraSizeRatio)) {\n                return true;\n            }\n        });\n        if (edges.length === 0)\n            return null; // no edges found\n        // if none of the edges have a zIndex, selected the most recently created one to match the rendering order\n        var selectedEdge = edges[edges.length - 1];\n        // otherwise select edge with highest zIndex\n        var highestZIndex = -Infinity;\n        try {\n            for (var edges_1 = __values(edges), edges_1_1 = edges_1.next(); !edges_1_1.done; edges_1_1 = edges_1.next()) {\n                var edge = edges_1_1.value;\n                var zIndex = this.graph.getEdgeAttribute(edge, \"zIndex\");\n                if (zIndex >= highestZIndex) {\n                    selectedEdge = edge;\n                    highestZIndex = zIndex;\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (edges_1_1 && !edges_1_1.done && (_a = edges_1.return)) _a.call(edges_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return selectedEdge;\n    };\n    /**\n     * Method used to process the whole graph's data.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.process = function (keepArrays) {\n        var _this = this;\n        if (keepArrays === void 0) { keepArrays = false; }\n        var graph = this.graph;\n        var settings = this.settings;\n        var dimensions = this.getDimensions();\n        var nodeZExtent = [Infinity, -Infinity];\n        var edgeZExtent = [Infinity, -Infinity];\n        // Clearing the quad\n        this.quadtree.clear();\n        // Resetting the label grid\n        // TODO: it's probably better to do this explicitly or on resizes for layout and anims\n        this.labelGrid.resizeAndClear(dimensions, settings.labelGridCellSize);\n        // Clear the highlightedNodes\n        this.highlightedNodes = new Set();\n        // Computing extents\n        this.nodeExtent = (0, utils_1.graphExtent)(graph);\n        // Resetting `forceLabel` indices\n        this.nodesWithForcedLabels = [];\n        this.edgesWithForcedLabels = [];\n        // NOTE: it is important to compute this matrix after computing the node's extent\n        // because #.getGraphDimensions relies on it\n        var nullCamera = new camera_1.default();\n        var nullCameraMatrix = (0, utils_1.matrixFromCamera)(nullCamera.getState(), this.getDimensions(), this.getGraphDimensions(), this.getSetting(\"stagePadding\") || 0);\n        // Rescaling function\n        this.normalizationFunction = (0, utils_1.createNormalizationFunction)(this.customBBox || this.nodeExtent);\n        var nodesPerPrograms = {};\n        var nodes = graph.nodes();\n        for (var i = 0, l = nodes.length; i < l; i++) {\n            var node = nodes[i];\n            // Node display data resolution:\n            //   1. First we get the node's attributes\n            //   2. We optionally reduce them using the function provided by the user\n            //      Note that this function must return a total object and won't be merged\n            //   3. We apply our defaults, while running some vital checks\n            //   4. We apply the normalization function\n            // We shallow copy node data to avoid dangerous behaviors from reducers\n            var attr = Object.assign({}, graph.getNodeAttributes(node));\n            if (settings.nodeReducer)\n                attr = settings.nodeReducer(node, attr);\n            var data = applyNodeDefaults(this.settings, node, attr);\n            nodesPerPrograms[data.type] = (nodesPerPrograms[data.type] || 0) + 1;\n            this.nodeDataCache[node] = data;\n            this.normalizationFunction.applyTo(data);\n            if (data.forceLabel)\n                this.nodesWithForcedLabels.push(node);\n            if (this.settings.zIndex) {\n                if (data.zIndex < nodeZExtent[0])\n                    nodeZExtent[0] = data.zIndex;\n                if (data.zIndex > nodeZExtent[1])\n                    nodeZExtent[1] = data.zIndex;\n            }\n        }\n        for (var type in this.nodePrograms) {\n            if (!this.nodePrograms.hasOwnProperty(type)) {\n                throw new Error(\"Sigma: could not find a suitable program for node type \\\"\".concat(type, \"\\\"!\"));\n            }\n            if (!keepArrays)\n                this.nodePrograms[type].allocate(nodesPerPrograms[type] || 0);\n            // We reset that count here, so that we can reuse it while calling the Program#process methods:\n            nodesPerPrograms[type] = 0;\n        }\n        // Handling node z-index\n        // TODO: z-index needs us to compute display data before hand\n        if (this.settings.zIndex && nodeZExtent[0] !== nodeZExtent[1])\n            nodes = (0, utils_1.zIndexOrdering)(nodeZExtent, function (node) { return _this.nodeDataCache[node].zIndex; }, nodes);\n        for (var i = 0, l = nodes.length; i < l; i++) {\n            var node = nodes[i];\n            var data = this.nodeDataCache[node];\n            this.quadtree.add(node, data.x, 1 - data.y, data.size / this.width);\n            if (typeof data.label === \"string\" && !data.hidden)\n                this.labelGrid.add(node, data.size, this.framedGraphToViewport(data, { matrix: nullCameraMatrix }));\n            var nodeProgram = this.nodePrograms[data.type];\n            if (!nodeProgram)\n                throw new Error(\"Sigma: could not find a suitable program for node type \\\"\".concat(data.type, \"\\\"!\"));\n            nodeProgram.process(data, data.hidden, nodesPerPrograms[data.type]++);\n            // Save the node in the highlighted set if needed\n            if (data.highlighted && !data.hidden)\n                this.highlightedNodes.add(node);\n        }\n        this.labelGrid.organize();\n        var edgesPerPrograms = {};\n        var edges = graph.edges();\n        for (var i = 0, l = edges.length; i < l; i++) {\n            var edge = edges[i];\n            // Edge display data resolution:\n            //   1. First we get the edge's attributes\n            //   2. We optionally reduce them using the function provided by the user\n            //      Note that this function must return a total object and won't be merged\n            //   3. We apply our defaults, while running some vital checks\n            // We shallow copy edge data to avoid dangerous behaviors from reducers\n            var attr = Object.assign({}, graph.getEdgeAttributes(edge));\n            if (settings.edgeReducer)\n                attr = settings.edgeReducer(edge, attr);\n            var data = applyEdgeDefaults(this.settings, edge, attr);\n            edgesPerPrograms[data.type] = (edgesPerPrograms[data.type] || 0) + 1;\n            this.edgeDataCache[edge] = data;\n            if (data.forceLabel && !data.hidden)\n                this.edgesWithForcedLabels.push(edge);\n            if (this.settings.zIndex) {\n                if (data.zIndex < edgeZExtent[0])\n                    edgeZExtent[0] = data.zIndex;\n                if (data.zIndex > edgeZExtent[1])\n                    edgeZExtent[1] = data.zIndex;\n            }\n        }\n        for (var type in this.edgePrograms) {\n            if (!this.edgePrograms.hasOwnProperty(type)) {\n                throw new Error(\"Sigma: could not find a suitable program for edge type \\\"\".concat(type, \"\\\"!\"));\n            }\n            if (!keepArrays)\n                this.edgePrograms[type].allocate(edgesPerPrograms[type] || 0);\n            // We reset that count here, so that we can reuse it while calling the Program#process methods:\n            edgesPerPrograms[type] = 0;\n        }\n        // Handling edge z-index\n        if (this.settings.zIndex && edgeZExtent[0] !== edgeZExtent[1])\n            edges = (0, utils_1.zIndexOrdering)(edgeZExtent, function (edge) { return _this.edgeDataCache[edge].zIndex; }, edges);\n        for (var i = 0, l = edges.length; i < l; i++) {\n            var edge = edges[i];\n            var data = this.edgeDataCache[edge];\n            var extremities = graph.extremities(edge), sourceData = this.nodeDataCache[extremities[0]], targetData = this.nodeDataCache[extremities[1]];\n            var hidden = data.hidden || sourceData.hidden || targetData.hidden;\n            this.edgePrograms[data.type].process(sourceData, targetData, data, hidden, edgesPerPrograms[data.type]++);\n        }\n        for (var type in this.edgePrograms) {\n            var program = this.edgePrograms[type];\n            if (!keepArrays && typeof program.computeIndices === \"function\")\n                program.computeIndices();\n        }\n        return this;\n    };\n    /**\n     * Method that backports potential settings updates where it's needed.\n     * @private\n     */\n    Sigma.prototype.handleSettingsUpdate = function () {\n        this.camera.minRatio = this.settings.minCameraRatio;\n        this.camera.maxRatio = this.settings.maxCameraRatio;\n        this.camera.setState(this.camera.validateState(this.camera.getState()));\n        return this;\n    };\n    /**\n     * Method that decides whether to reprocess graph or not, and then render the\n     * graph.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype._refresh = function () {\n        // Do we need to process data?\n        if (this.needToProcess) {\n            this.process();\n        }\n        else if (this.needToSoftProcess) {\n            this.process(true);\n        }\n        // Resetting state\n        this.needToProcess = false;\n        this.needToSoftProcess = false;\n        // Rendering\n        this.render();\n        return this;\n    };\n    /**\n     * Method that schedules a `_refresh` call if none has been scheduled yet. It\n     * will then be processed next available frame.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype._scheduleRefresh = function () {\n        var _this = this;\n        if (!this.renderFrame) {\n            this.renderFrame = (0, utils_1.requestFrame)(function () {\n                _this._refresh();\n                _this.renderFrame = null;\n            });\n        }\n        return this;\n    };\n    /**\n     * Method used to render labels.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.renderLabels = function () {\n        if (!this.settings.renderLabels)\n            return this;\n        var cameraState = this.camera.getState();\n        // Selecting labels to draw\n        var labelsToDisplay = this.labelGrid.getLabelsToDisplay(cameraState.ratio, this.settings.labelDensity);\n        (0, extend_1.default)(labelsToDisplay, this.nodesWithForcedLabels);\n        this.displayedLabels = new Set();\n        // Drawing labels\n        var context = this.canvasContexts.labels;\n        for (var i = 0, l = labelsToDisplay.length; i < l; i++) {\n            var node = labelsToDisplay[i];\n            var data = this.nodeDataCache[node];\n            // If the node was already drawn (like if it is eligible AND has\n            // `forceLabel`), we don't want to draw it again\n            // NOTE: we can do better probably\n            if (this.displayedLabels.has(node))\n                continue;\n            // If the node is hidden, we don't need to display its label obviously\n            if (data.hidden)\n                continue;\n            var _a = this.framedGraphToViewport(data), x = _a.x, y = _a.y;\n            // NOTE: we can cache the labels we need to render until the camera's ratio changes\n            var size = this.scaleSize(data.size);\n            // Is node big enough?\n            if (!data.forceLabel && size < this.settings.labelRenderedSizeThreshold)\n                continue;\n            // Is node actually on screen (with some margin)\n            // NOTE: we used to rely on the quadtree for this, but the coordinates\n            // conversion make it unreliable and at that point we already converted\n            // to viewport coordinates and since the label grid already culls the\n            // number of potential labels to display this looks like a good\n            // performance compromise.\n            // NOTE: labelGrid.getLabelsToDisplay could probably optimize by not\n            // considering cells obviously outside of the range of the current\n            // view rectangle.\n            if (x < -X_LABEL_MARGIN ||\n                x > this.width + X_LABEL_MARGIN ||\n                y < -Y_LABEL_MARGIN ||\n                y > this.height + Y_LABEL_MARGIN)\n                continue;\n            // Because displayed edge labels depend directly on actually rendered node\n            // labels, we need to only add to this.displayedLabels nodes whose label\n            // is rendered.\n            // This makes this.displayedLabels depend on viewport, which might become\n            // an issue once we start memoizing getLabelsToDisplay.\n            this.displayedLabels.add(node);\n            this.settings.labelRenderer(context, __assign(__assign({ key: node }, data), { size: size, x: x, y: y }), this.settings);\n        }\n        return this;\n    };\n    /**\n     * Method used to render edge labels, based on which node labels were\n     * rendered.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.renderEdgeLabels = function () {\n        if (!this.settings.renderEdgeLabels)\n            return this;\n        var context = this.canvasContexts.edgeLabels;\n        // Clearing\n        context.clearRect(0, 0, this.width, this.height);\n        var edgeLabelsToDisplay = (0, labels_1.edgeLabelsToDisplayFromNodes)({\n            graph: this.graph,\n            hoveredNode: this.hoveredNode,\n            displayedNodeLabels: this.displayedLabels,\n            highlightedNodes: this.highlightedNodes,\n        }).concat(this.edgesWithForcedLabels);\n        var displayedLabels = new Set();\n        for (var i = 0, l = edgeLabelsToDisplay.length; i < l; i++) {\n            var edge = edgeLabelsToDisplay[i], extremities = this.graph.extremities(edge), sourceData = this.nodeDataCache[extremities[0]], targetData = this.nodeDataCache[extremities[1]], edgeData = this.edgeDataCache[edge];\n            // If the edge was already drawn (like if it is eligible AND has\n            // `forceLabel`), we don't want to draw it again\n            if (displayedLabels.has(edge))\n                continue;\n            // If the edge is hidden we don't need to display its label\n            // NOTE: the test on sourceData & targetData is probably paranoid at this point?\n            if (edgeData.hidden || sourceData.hidden || targetData.hidden) {\n                continue;\n            }\n            this.settings.edgeLabelRenderer(context, __assign(__assign({ key: edge }, edgeData), { size: this.scaleSize(edgeData.size) }), __assign(__assign(__assign({ key: extremities[0] }, sourceData), this.framedGraphToViewport(sourceData)), { size: this.scaleSize(sourceData.size) }), __assign(__assign(__assign({ key: extremities[1] }, targetData), this.framedGraphToViewport(targetData)), { size: this.scaleSize(targetData.size) }), this.settings);\n            displayedLabels.add(edge);\n        }\n        return this;\n    };\n    /**\n     * Method used to render the highlighted nodes.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.renderHighlightedNodes = function () {\n        var _this = this;\n        var context = this.canvasContexts.hovers;\n        // Clearing\n        context.clearRect(0, 0, this.width, this.height);\n        // Rendering\n        var render = function (node) {\n            var data = _this.nodeDataCache[node];\n            var _a = _this.framedGraphToViewport(data), x = _a.x, y = _a.y;\n            var size = _this.scaleSize(data.size);\n            _this.settings.hoverRenderer(context, __assign(__assign({ key: node }, data), { size: size, x: x, y: y }), _this.settings);\n        };\n        var nodesToRender = [];\n        if (this.hoveredNode && !this.nodeDataCache[this.hoveredNode].hidden) {\n            nodesToRender.push(this.hoveredNode);\n        }\n        this.highlightedNodes.forEach(function (node) {\n            // The hovered node has already been highlighted\n            if (node !== _this.hoveredNode)\n                nodesToRender.push(node);\n        });\n        // Draw labels:\n        nodesToRender.forEach(function (node) { return render(node); });\n        // Draw WebGL nodes on top of the labels:\n        var nodesPerPrograms = {};\n        // 1. Count nodes per type:\n        nodesToRender.forEach(function (node) {\n            var type = _this.nodeDataCache[node].type;\n            nodesPerPrograms[type] = (nodesPerPrograms[type] || 0) + 1;\n        });\n        // 2. Allocate for each type for the proper number of nodes\n        for (var type in this.nodeHoverPrograms) {\n            this.nodeHoverPrograms[type].allocate(nodesPerPrograms[type] || 0);\n            // Also reset count, to use when rendering:\n            nodesPerPrograms[type] = 0;\n        }\n        // 3. Process all nodes to render:\n        nodesToRender.forEach(function (node) {\n            var data = _this.nodeDataCache[node];\n            _this.nodeHoverPrograms[data.type].process(data, data.hidden, nodesPerPrograms[data.type]++);\n        });\n        // 4. Clear hovered nodes layer:\n        this.webGLContexts.hoverNodes.clear(this.webGLContexts.hoverNodes.COLOR_BUFFER_BIT);\n        // 5. Render:\n        for (var type in this.nodeHoverPrograms) {\n            var program = this.nodeHoverPrograms[type];\n            program.bind();\n            program.bufferData();\n            program.render({\n                matrix: this.matrix,\n                width: this.width,\n                height: this.height,\n                ratio: this.camera.ratio,\n                correctionRatio: this.correctionRatio / this.camera.ratio,\n                scalingRatio: this.pixelRatio,\n            });\n        }\n    };\n    /**\n     * Method used to schedule a hover render.\n     *\n     */\n    Sigma.prototype.scheduleHighlightedNodesRender = function () {\n        var _this = this;\n        if (this.renderHighlightedNodesFrame || this.renderFrame)\n            return;\n        this.renderHighlightedNodesFrame = (0, utils_1.requestFrame)(function () {\n            // Resetting state\n            _this.renderHighlightedNodesFrame = null;\n            // Rendering\n            _this.renderHighlightedNodes();\n            _this.renderEdgeLabels();\n        });\n    };\n    /**\n     * Method used to render.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.render = function () {\n        var _this = this;\n        this.emit(\"beforeRender\");\n        var exitRender = function () {\n            _this.emit(\"afterRender\");\n            return _this;\n        };\n        // If a render was scheduled, we cancel it\n        if (this.renderFrame) {\n            (0, utils_1.cancelFrame)(this.renderFrame);\n            this.renderFrame = null;\n            this.needToProcess = false;\n            this.needToSoftProcess = false;\n        }\n        // First we need to resize\n        this.resize();\n        // Clearing the canvases\n        this.clear();\n        // Recomputing useful camera-related values:\n        this.updateCachedValues();\n        // If we have no nodes we can stop right there\n        if (!this.graph.order)\n            return exitRender();\n        // TODO: improve this heuristic or move to the captor itself?\n        // TODO: deal with the touch captor here as well\n        var mouseCaptor = this.mouseCaptor;\n        var moving = this.camera.isAnimated() ||\n            mouseCaptor.isMoving ||\n            mouseCaptor.draggedEvents ||\n            mouseCaptor.currentWheelDirection;\n        // Then we need to extract a matrix from the camera\n        var cameraState = this.camera.getState();\n        var viewportDimensions = this.getDimensions();\n        var graphDimensions = this.getGraphDimensions();\n        var padding = this.getSetting(\"stagePadding\") || 0;\n        this.matrix = (0, utils_1.matrixFromCamera)(cameraState, viewportDimensions, graphDimensions, padding);\n        this.invMatrix = (0, utils_1.matrixFromCamera)(cameraState, viewportDimensions, graphDimensions, padding, true);\n        this.correctionRatio = (0, utils_1.getMatrixImpact)(this.matrix, cameraState, viewportDimensions);\n        // Drawing nodes\n        for (var type in this.nodePrograms) {\n            var program = this.nodePrograms[type];\n            program.bind();\n            program.bufferData();\n            program.render({\n                matrix: this.matrix,\n                width: this.width,\n                height: this.height,\n                ratio: cameraState.ratio,\n                correctionRatio: this.correctionRatio / cameraState.ratio,\n                scalingRatio: this.pixelRatio,\n            });\n        }\n        // Drawing edges\n        if (!this.settings.hideEdgesOnMove || !moving) {\n            for (var type in this.edgePrograms) {\n                var program = this.edgePrograms[type];\n                program.bind();\n                program.bufferData();\n                program.render({\n                    matrix: this.matrix,\n                    width: this.width,\n                    height: this.height,\n                    ratio: cameraState.ratio,\n                    correctionRatio: this.correctionRatio / cameraState.ratio,\n                    scalingRatio: this.pixelRatio,\n                });\n            }\n        }\n        // Do not display labels on move per setting\n        if (this.settings.hideLabelsOnMove && moving)\n            return exitRender();\n        this.renderLabels();\n        this.renderEdgeLabels();\n        this.renderHighlightedNodes();\n        return exitRender();\n    };\n    /**\n     * Internal method used to update expensive and therefore cached values\n     * each time the camera state is updated.\n     */\n    Sigma.prototype.updateCachedValues = function () {\n        var ratio = this.camera.getState().ratio;\n        this.cameraSizeRatio = Math.sqrt(ratio);\n    };\n    /**---------------------------------------------------------------------------\n     * Public API.\n     **---------------------------------------------------------------------------\n     */\n    /**\n     * Method returning the renderer's camera.\n     *\n     * @return {Camera}\n     */\n    Sigma.prototype.getCamera = function () {\n        return this.camera;\n    };\n    /**\n     * Method returning the container DOM element.\n     *\n     * @return {HTMLElement}\n     */\n    Sigma.prototype.getContainer = function () {\n        return this.container;\n    };\n    /**\n     * Method returning the renderer's graph.\n     *\n     * @return {Graph}\n     */\n    Sigma.prototype.getGraph = function () {\n        return this.graph;\n    };\n    /**\n     * Method used to set the renderer's graph.\n     *\n     * @return {Graph}\n     */\n    Sigma.prototype.setGraph = function (graph) {\n        if (graph === this.graph)\n            return;\n        // Unbinding handlers on the current graph\n        this.unbindGraphHandlers();\n        // Clearing the graph data caches\n        this.nodeDataCache = {};\n        this.edgeDataCache = {};\n        // Cleaning renderer state tied to the current graph\n        this.displayedLabels.clear();\n        this.highlightedNodes.clear();\n        this.hoveredNode = null;\n        this.hoveredEdge = null;\n        this.nodesWithForcedLabels.length = 0;\n        this.edgesWithForcedLabels.length = 0;\n        if (this.checkEdgesEventsFrame !== null) {\n            (0, utils_1.cancelFrame)(this.checkEdgesEventsFrame);\n            this.checkEdgesEventsFrame = null;\n        }\n        // Installing new graph\n        this.graph = graph;\n        // Binding new handlers\n        this.bindGraphHandlers();\n        // Re-rendering now to avoid discrepancies from now to next frame\n        this.process();\n        this.render();\n    };\n    /**\n     * Method returning the mouse captor.\n     *\n     * @return {MouseCaptor}\n     */\n    Sigma.prototype.getMouseCaptor = function () {\n        return this.mouseCaptor;\n    };\n    /**\n     * Method returning the touch captor.\n     *\n     * @return {TouchCaptor}\n     */\n    Sigma.prototype.getTouchCaptor = function () {\n        return this.touchCaptor;\n    };\n    /**\n     * Method returning the current renderer's dimensions.\n     *\n     * @return {Dimensions}\n     */\n    Sigma.prototype.getDimensions = function () {\n        return { width: this.width, height: this.height };\n    };\n    /**\n     * Method returning the current graph's dimensions.\n     *\n     * @return {Dimensions}\n     */\n    Sigma.prototype.getGraphDimensions = function () {\n        var extent = this.customBBox || this.nodeExtent;\n        return {\n            width: extent.x[1] - extent.x[0] || 1,\n            height: extent.y[1] - extent.y[0] || 1,\n        };\n    };\n    /**\n     * Method used to get all the sigma node attributes.\n     * It's usefull for example to get the position of a node\n     * and to get values that are set by the nodeReducer\n     *\n     * @param  {string} key - The node's key.\n     * @return {NodeDisplayData | undefined} A copy of the desired node's attribute or undefined if not found\n     */\n    Sigma.prototype.getNodeDisplayData = function (key) {\n        var node = this.nodeDataCache[key];\n        return node ? Object.assign({}, node) : undefined;\n    };\n    /**\n     * Method used to get all the sigma edge attributes.\n     * It's usefull for example to get values that are set by the edgeReducer.\n     *\n     * @param  {string} key - The edge's key.\n     * @return {EdgeDisplayData | undefined} A copy of the desired edge's attribute or undefined if not found\n     */\n    Sigma.prototype.getEdgeDisplayData = function (key) {\n        var edge = this.edgeDataCache[key];\n        return edge ? Object.assign({}, edge) : undefined;\n    };\n    /**\n     * Method returning a copy of the settings collection.\n     *\n     * @return {Settings} A copy of the settings collection.\n     */\n    Sigma.prototype.getSettings = function () {\n        return __assign({}, this.settings);\n    };\n    /**\n     * Method returning the current value for a given setting key.\n     *\n     * @param  {string} key - The setting key to get.\n     * @return {any} The value attached to this setting key or undefined if not found\n     */\n    Sigma.prototype.getSetting = function (key) {\n        return this.settings[key];\n    };\n    /**\n     * Method setting the value of a given setting key. Note that this will schedule\n     * a new render next frame.\n     *\n     * @param  {string} key - The setting key to set.\n     * @param  {any}    value - The value to set.\n     * @return {Sigma}\n     */\n    Sigma.prototype.setSetting = function (key, value) {\n        this.settings[key] = value;\n        (0, settings_1.validateSettings)(this.settings);\n        this.handleSettingsUpdate();\n        this.needToProcess = true; // TODO: some keys may work with only needToSoftProcess or even nothing\n        this._scheduleRefresh();\n        return this;\n    };\n    /**\n     * Method updating the value of a given setting key using the provided function.\n     * Note that this will schedule a new render next frame.\n     *\n     * @param  {string}   key     - The setting key to set.\n     * @param  {function} updater - The update function.\n     * @return {Sigma}\n     */\n    Sigma.prototype.updateSetting = function (key, updater) {\n        this.settings[key] = updater(this.settings[key]);\n        (0, settings_1.validateSettings)(this.settings);\n        this.handleSettingsUpdate();\n        this.needToProcess = true; // TODO: some keys may work with only needToSoftProcess or even nothing\n        this._scheduleRefresh();\n        return this;\n    };\n    /**\n     * Method used to resize the renderer.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.resize = function () {\n        var previousWidth = this.width, previousHeight = this.height;\n        this.width = this.container.offsetWidth;\n        this.height = this.container.offsetHeight;\n        this.pixelRatio = (0, utils_1.getPixelRatio)();\n        if (this.width === 0) {\n            if (this.settings.allowInvalidContainer)\n                this.width = 1;\n            else\n                throw new Error(\"Sigma: Container has no width. You can set the allowInvalidContainer setting to true to stop seeing this error.\");\n        }\n        if (this.height === 0) {\n            if (this.settings.allowInvalidContainer)\n                this.height = 1;\n            else\n                throw new Error(\"Sigma: Container has no height. You can set the allowInvalidContainer setting to true to stop seeing this error.\");\n        }\n        // If nothing has changed, we can stop right here\n        if (previousWidth === this.width && previousHeight === this.height)\n            return this;\n        this.emit(\"resize\");\n        // Sizing dom elements\n        for (var id in this.elements) {\n            var element = this.elements[id];\n            element.style.width = this.width + \"px\";\n            element.style.height = this.height + \"px\";\n        }\n        // Sizing canvas contexts\n        for (var id in this.canvasContexts) {\n            this.elements[id].setAttribute(\"width\", this.width * this.pixelRatio + \"px\");\n            this.elements[id].setAttribute(\"height\", this.height * this.pixelRatio + \"px\");\n            if (this.pixelRatio !== 1)\n                this.canvasContexts[id].scale(this.pixelRatio, this.pixelRatio);\n        }\n        // Sizing WebGL contexts\n        for (var id in this.webGLContexts) {\n            this.elements[id].setAttribute(\"width\", this.width * this.pixelRatio + \"px\");\n            this.elements[id].setAttribute(\"height\", this.height * this.pixelRatio + \"px\");\n            this.webGLContexts[id].viewport(0, 0, this.width * this.pixelRatio, this.height * this.pixelRatio);\n        }\n        return this;\n    };\n    /**\n     * Method used to clear all the canvases.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.clear = function () {\n        this.webGLContexts.nodes.clear(this.webGLContexts.nodes.COLOR_BUFFER_BIT);\n        this.webGLContexts.edges.clear(this.webGLContexts.edges.COLOR_BUFFER_BIT);\n        this.webGLContexts.hoverNodes.clear(this.webGLContexts.hoverNodes.COLOR_BUFFER_BIT);\n        this.canvasContexts.labels.clearRect(0, 0, this.width, this.height);\n        this.canvasContexts.hovers.clearRect(0, 0, this.width, this.height);\n        this.canvasContexts.edgeLabels.clearRect(0, 0, this.width, this.height);\n        return this;\n    };\n    /**\n     * Method used to refresh all computed data.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.refresh = function () {\n        this.needToProcess = true;\n        this._refresh();\n        return this;\n    };\n    /**\n     * Method used to refresh all computed data, at the next available frame.\n     * If this method has already been called this frame, then it will only render once at the next available frame.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.scheduleRefresh = function () {\n        this.needToProcess = true;\n        this._scheduleRefresh();\n        return this;\n    };\n    /**\n     * Method used to (un)zoom, while preserving the position of a viewport point.\n     * Used for instance to zoom \"on the mouse cursor\".\n     *\n     * @param viewportTarget\n     * @param newRatio\n     * @return {CameraState}\n     */\n    Sigma.prototype.getViewportZoomedState = function (viewportTarget, newRatio) {\n        var _a = this.camera.getState(), ratio = _a.ratio, angle = _a.angle, x = _a.x, y = _a.y;\n        // TODO: handle max zoom\n        var ratioDiff = newRatio / ratio;\n        var center = {\n            x: this.width / 2,\n            y: this.height / 2,\n        };\n        var graphMousePosition = this.viewportToFramedGraph(viewportTarget);\n        var graphCenterPosition = this.viewportToFramedGraph(center);\n        return {\n            angle: angle,\n            x: (graphMousePosition.x - graphCenterPosition.x) * (1 - ratioDiff) + x,\n            y: (graphMousePosition.y - graphCenterPosition.y) * (1 - ratioDiff) + y,\n            ratio: newRatio,\n        };\n    };\n    /**\n     * Method returning the abstract rectangle containing the graph according\n     * to the camera's state.\n     *\n     * @return {object} - The view's rectangle.\n     */\n    Sigma.prototype.viewRectangle = function () {\n        // TODO: reduce relative margin?\n        var marginX = (0 * this.width) / 8, marginY = (0 * this.height) / 8;\n        var p1 = this.viewportToFramedGraph({ x: 0 - marginX, y: 0 - marginY }), p2 = this.viewportToFramedGraph({ x: this.width + marginX, y: 0 - marginY }), h = this.viewportToFramedGraph({ x: 0, y: this.height + marginY });\n        return {\n            x1: p1.x,\n            y1: p1.y,\n            x2: p2.x,\n            y2: p2.y,\n            height: p2.y - h.y,\n        };\n    };\n    /**\n     * Method returning the coordinates of a point from the framed graph system to the viewport system. It allows\n     * overriding anything that is used to get the translation matrix, or even the matrix itself.\n     *\n     * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest\n     * of computations.\n     */\n    Sigma.prototype.framedGraphToViewport = function (coordinates, override) {\n        if (override === void 0) { override = {}; }\n        var recomputeMatrix = !!override.cameraState || !!override.viewportDimensions || !!override.graphDimensions;\n        var matrix = override.matrix\n            ? override.matrix\n            : recomputeMatrix\n                ? (0, utils_1.matrixFromCamera)(override.cameraState || this.camera.getState(), override.viewportDimensions || this.getDimensions(), override.graphDimensions || this.getGraphDimensions(), override.padding || this.getSetting(\"stagePadding\") || 0)\n                : this.matrix;\n        var viewportPos = (0, matrices_1.multiplyVec2)(matrix, coordinates);\n        return {\n            x: ((1 + viewportPos.x) * this.width) / 2,\n            y: ((1 - viewportPos.y) * this.height) / 2,\n        };\n    };\n    /**\n     * Method returning the coordinates of a point from the viewport system to the framed graph system. It allows\n     * overriding anything that is used to get the translation matrix, or even the matrix itself.\n     *\n     * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest\n     * of computations.\n     */\n    Sigma.prototype.viewportToFramedGraph = function (coordinates, override) {\n        if (override === void 0) { override = {}; }\n        var recomputeMatrix = !!override.cameraState || !!override.viewportDimensions || !override.graphDimensions;\n        var invMatrix = override.matrix\n            ? override.matrix\n            : recomputeMatrix\n                ? (0, utils_1.matrixFromCamera)(override.cameraState || this.camera.getState(), override.viewportDimensions || this.getDimensions(), override.graphDimensions || this.getGraphDimensions(), override.padding || this.getSetting(\"stagePadding\") || 0, true)\n                : this.invMatrix;\n        var res = (0, matrices_1.multiplyVec2)(invMatrix, {\n            x: (coordinates.x / this.width) * 2 - 1,\n            y: 1 - (coordinates.y / this.height) * 2,\n        });\n        if (isNaN(res.x))\n            res.x = 0;\n        if (isNaN(res.y))\n            res.y = 0;\n        return res;\n    };\n    /**\n     * Method used to translate a point's coordinates from the viewport system (pixel distance from the top-left of the\n     * stage) to the graph system (the reference system of data as they are in the given graph instance).\n     *\n     * This method accepts an optional camera which can be useful if you need to translate coordinates\n     * based on a different view than the one being currently being displayed on screen.\n     *\n     * @param {Coordinates}                  viewportPoint\n     * @param {CoordinateConversionOverride} override\n     */\n    Sigma.prototype.viewportToGraph = function (viewportPoint, override) {\n        if (override === void 0) { override = {}; }\n        return this.normalizationFunction.inverse(this.viewportToFramedGraph(viewportPoint, override));\n    };\n    /**\n     * Method used to translate a point's coordinates from the graph system (the reference system of data as they are in\n     * the given graph instance) to the viewport system (pixel distance from the top-left of the stage).\n     *\n     * This method accepts an optional camera which can be useful if you need to translate coordinates\n     * based on a different view than the one being currently being displayed on screen.\n     *\n     * @param {Coordinates}                  graphPoint\n     * @param {CoordinateConversionOverride} override\n     */\n    Sigma.prototype.graphToViewport = function (graphPoint, override) {\n        if (override === void 0) { override = {}; }\n        return this.framedGraphToViewport(this.normalizationFunction(graphPoint), override);\n    };\n    /**\n     * Method returning the graph's bounding box.\n     *\n     * @return {{ x: Extent, y: Extent }}\n     */\n    Sigma.prototype.getBBox = function () {\n        return (0, utils_1.graphExtent)(this.graph);\n    };\n    /**\n     * Method returning the graph's custom bounding box, if any.\n     *\n     * @return {{ x: Extent, y: Extent } | null}\n     */\n    Sigma.prototype.getCustomBBox = function () {\n        return this.customBBox;\n    };\n    /**\n     * Method used to override the graph's bounding box with a custom one. Give `null` as the argument to stop overriding.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.setCustomBBox = function (customBBox) {\n        this.customBBox = customBBox;\n        this._scheduleRefresh();\n        return this;\n    };\n    /**\n     * Method used to shut the container & release event listeners.\n     *\n     * @return {undefined}\n     */\n    Sigma.prototype.kill = function () {\n        // Emitting \"kill\" events so that plugins and such can cleanup\n        this.emit(\"kill\");\n        // Releasing events\n        this.removeAllListeners();\n        // Releasing camera handlers\n        this.camera.removeListener(\"updated\", this.activeListeners.camera);\n        // Releasing DOM events & captors\n        window.removeEventListener(\"resize\", this.activeListeners.handleResize);\n        this.mouseCaptor.kill();\n        this.touchCaptor.kill();\n        // Releasing graph handlers\n        this.unbindGraphHandlers();\n        // Releasing cache & state\n        this.quadtree = new quadtree_1.default();\n        this.nodeDataCache = {};\n        this.edgeDataCache = {};\n        this.nodesWithForcedLabels = [];\n        this.edgesWithForcedLabels = [];\n        this.highlightedNodes.clear();\n        // Clearing frames\n        if (this.renderFrame) {\n            (0, utils_1.cancelFrame)(this.renderFrame);\n            this.renderFrame = null;\n        }\n        if (this.renderHighlightedNodesFrame) {\n            (0, utils_1.cancelFrame)(this.renderHighlightedNodesFrame);\n            this.renderHighlightedNodesFrame = null;\n        }\n        // Destroying canvases\n        var container = this.container;\n        while (container.firstChild)\n            container.removeChild(container.firstChild);\n    };\n    /**\n     * Method used to scale the given size according to the camera's ratio, i.e.\n     * zooming state.\n     *\n     * @param  {number} size - The size to scale (node size, edge thickness etc.).\n     * @return {number}      - The scaled size.\n     */\n    Sigma.prototype.scaleSize = function (size) {\n        return size / this.cameraSizeRatio;\n    };\n    /**\n     * Method that returns the collection of all used canvases.\n     * At the moment, the instantiated canvases are the following, and in the\n     * following order in the DOM:\n     * - `edges`\n     * - `nodes`\n     * - `edgeLabels`\n     * - `labels`\n     * - `hovers`\n     * - `hoverNodes`\n     * - `mouse`\n     *\n     * @return {PlainObject<HTMLCanvasElement>} - The collection of canvases.\n     */\n    Sigma.prototype.getCanvases = function () {\n        return __assign({}, this.elements);\n    };\n    return Sigma;\n}(types_1.TypedEventEmitter));\nexports.default = Sigma;\n"],"mappings":"AAAA,YAAY;;AACZ,IAAIA,SAAS,GAAI,IAAI,IAAI,IAAI,CAACA,SAAS,IAAM,YAAY;EACrD,IAAIC,aAAa,GAAG,SAAAA,CAAUC,CAAC,EAAEC,CAAC,EAAE;IAChCF,aAAa,GAAGG,MAAM,CAACC,cAAc,IAChC;MAAEC,SAAS,EAAE;IAAG,CAAC,YAAYC,KAAK,IAAI,UAAUL,CAAC,EAAEC,CAAC,EAAE;MAAED,CAAC,CAACI,SAAS,GAAGH,CAAC;IAAE,CAAE,IAC5E,UAAUD,CAAC,EAAEC,CAAC,EAAE;MAAE,KAAK,IAAIK,CAAC,IAAIL,CAAC,EAAE,IAAIC,MAAM,CAACK,SAAS,CAACC,cAAc,CAACC,IAAI,CAACR,CAAC,EAAEK,CAAC,CAAC,EAAEN,CAAC,CAACM,CAAC,CAAC,GAAGL,CAAC,CAACK,CAAC,CAAC;IAAE,CAAC;IACrG,OAAOP,aAAa,CAACC,CAAC,EAAEC,CAAC,CAAC;EAC9B,CAAC;EACD,OAAO,UAAUD,CAAC,EAAEC,CAAC,EAAE;IACnB,IAAI,OAAOA,CAAC,KAAK,UAAU,IAAIA,CAAC,KAAK,IAAI,EACrC,MAAM,IAAIS,SAAS,CAAC,sBAAsB,GAAGC,MAAM,CAACV,CAAC,CAAC,GAAG,+BAA+B,CAAC;IAC7FF,aAAa,CAACC,CAAC,EAAEC,CAAC,CAAC;IACnB,SAASW,EAAEA,CAAA,EAAG;MAAE,IAAI,CAACC,WAAW,GAAGb,CAAC;IAAE;IACtCA,CAAC,CAACO,SAAS,GAAGN,CAAC,KAAK,IAAI,GAAGC,MAAM,CAACY,MAAM,CAACb,CAAC,CAAC,IAAIW,EAAE,CAACL,SAAS,GAAGN,CAAC,CAACM,SAAS,EAAE,IAAIK,EAAE,CAAC,CAAC,CAAC;EACxF,CAAC;AACL,CAAC,CAAE,CAAC;AACJ,IAAIG,QAAQ,GAAI,IAAI,IAAI,IAAI,CAACA,QAAQ,IAAK,YAAY;EAClDA,QAAQ,GAAGb,MAAM,CAACc,MAAM,IAAI,UAASC,CAAC,EAAE;IACpC,KAAK,IAAIC,CAAC,EAAEC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGC,SAAS,CAACC,MAAM,EAAEH,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;MACjDD,CAAC,GAAGG,SAAS,CAACF,CAAC,CAAC;MAChB,KAAK,IAAIb,CAAC,IAAIY,CAAC,EAAE,IAAIhB,MAAM,CAACK,SAAS,CAACC,cAAc,CAACC,IAAI,CAACS,CAAC,EAAEZ,CAAC,CAAC,EAC3DW,CAAC,CAACX,CAAC,CAAC,GAAGY,CAAC,CAACZ,CAAC,CAAC;IACnB;IACA,OAAOW,CAAC;EACZ,CAAC;EACD,OAAOF,QAAQ,CAACQ,KAAK,CAAC,IAAI,EAAEF,SAAS,CAAC;AAC1C,CAAC;AACD,IAAIG,QAAQ,GAAI,IAAI,IAAI,IAAI,CAACA,QAAQ,IAAK,UAASC,CAAC,EAAE;EAClD,IAAIP,CAAC,GAAG,OAAOQ,MAAM,KAAK,UAAU,IAAIA,MAAM,CAACC,QAAQ;IAAEC,CAAC,GAAGV,CAAC,IAAIO,CAAC,CAACP,CAAC,CAAC;IAAEC,CAAC,GAAG,CAAC;EAC7E,IAAIS,CAAC,EAAE,OAAOA,CAAC,CAACnB,IAAI,CAACgB,CAAC,CAAC;EACvB,IAAIA,CAAC,IAAI,OAAOA,CAAC,CAACH,MAAM,KAAK,QAAQ,EAAE,OAAO;IAC1CO,IAAI,EAAE,SAAAA,CAAA,EAAY;MACd,IAAIJ,CAAC,IAAIN,CAAC,IAAIM,CAAC,CAACH,MAAM,EAAEG,CAAC,GAAG,KAAK,CAAC;MAClC,OAAO;QAAEK,KAAK,EAAEL,CAAC,IAAIA,CAAC,CAACN,CAAC,EAAE,CAAC;QAAEY,IAAI,EAAE,CAACN;MAAE,CAAC;IAC3C;EACJ,CAAC;EACD,MAAM,IAAIf,SAAS,CAACQ,CAAC,GAAG,yBAAyB,GAAG,iCAAiC,CAAC;AAC1F,CAAC;AACD,IAAIc,eAAe,GAAI,IAAI,IAAI,IAAI,CAACA,eAAe,IAAK,UAAUC,GAAG,EAAE;EACnE,OAAQA,GAAG,IAAIA,GAAG,CAACC,UAAU,GAAID,GAAG,GAAG;IAAE,SAAS,EAAEA;EAAI,CAAC;AAC7D,CAAC;AACD/B,MAAM,CAACiC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEN,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7D,IAAIO,QAAQ,GAAGL,eAAe,CAACM,OAAO,CAAC,+BAA+B,CAAC,CAAC;AACxE,IAAIC,QAAQ,GAAGP,eAAe,CAACM,OAAO,CAAC,eAAe,CAAC,CAAC;AACxD,IAAIE,OAAO,GAAGR,eAAe,CAACM,OAAO,CAAC,sBAAsB,CAAC,CAAC;AAC9D,IAAIG,UAAU,GAAGT,eAAe,CAACM,OAAO,CAAC,iBAAiB,CAAC,CAAC;AAC5D,IAAII,OAAO,GAAGJ,OAAO,CAAC,SAAS,CAAC;AAChC,IAAIK,OAAO,GAAGL,OAAO,CAAC,SAAS,CAAC;AAChC,IAAIM,QAAQ,GAAGN,OAAO,CAAC,eAAe,CAAC;AACvC,IAAIO,UAAU,GAAGP,OAAO,CAAC,YAAY,CAAC;AACtC,IAAIQ,OAAO,GAAGd,eAAe,CAACM,OAAO,CAAC,sBAAsB,CAAC,CAAC;AAC9D,IAAIS,UAAU,GAAGT,OAAO,CAAC,kBAAkB,CAAC;AAC5C,IAAIU,iBAAiB,GAAGV,OAAO,CAAC,yBAAyB,CAAC;AAC1D;AACA;AACA;AACA,IAAIW,cAAc,GAAG,GAAG;AACxB,IAAIC,cAAc,GAAG,EAAE;AACvB;AACA;AACA;AACA,SAASC,iBAAiBA,CAACC,QAAQ,EAAEC,GAAG,EAAEC,IAAI,EAAE;EAC5C,IAAI,CAACA,IAAI,CAAC9C,cAAc,CAAC,GAAG,CAAC,IAAI,CAAC8C,IAAI,CAAC9C,cAAc,CAAC,GAAG,CAAC,EACtD,MAAM,IAAI+C,KAAK,CAAC,2DAA2D,CAACC,MAAM,CAACH,GAAG,EAAE,uJAAuJ,CAAC,CAAC;EACrP,IAAI,CAACC,IAAI,CAACG,KAAK,EACXH,IAAI,CAACG,KAAK,GAAGL,QAAQ,CAACM,gBAAgB;EAC1C,IAAI,CAACJ,IAAI,CAACK,KAAK,IAAIL,IAAI,CAACK,KAAK,KAAK,EAAE,EAChCL,IAAI,CAACK,KAAK,GAAG,IAAI;EACrB,IAAIL,IAAI,CAACK,KAAK,KAAKC,SAAS,IAAIN,IAAI,CAACK,KAAK,KAAK,IAAI,EAC/CL,IAAI,CAACK,KAAK,GAAG,EAAE,GAAGL,IAAI,CAACK,KAAK,CAAC,KAE7BL,IAAI,CAACK,KAAK,GAAG,IAAI;EACrB,IAAI,CAACL,IAAI,CAACO,IAAI,EACVP,IAAI,CAACO,IAAI,GAAG,CAAC;EACjB,IAAI,CAACP,IAAI,CAAC9C,cAAc,CAAC,QAAQ,CAAC,EAC9B8C,IAAI,CAACQ,MAAM,GAAG,KAAK;EACvB,IAAI,CAACR,IAAI,CAAC9C,cAAc,CAAC,aAAa,CAAC,EACnC8C,IAAI,CAACS,WAAW,GAAG,KAAK;EAC5B,IAAI,CAACT,IAAI,CAAC9C,cAAc,CAAC,YAAY,CAAC,EAClC8C,IAAI,CAACU,UAAU,GAAG,KAAK;EAC3B,IAAI,CAACV,IAAI,CAACW,IAAI,IAAIX,IAAI,CAACW,IAAI,KAAK,EAAE,EAC9BX,IAAI,CAACW,IAAI,GAAGb,QAAQ,CAACc,eAAe;EACxC,IAAI,CAACZ,IAAI,CAACa,MAAM,EACZb,IAAI,CAACa,MAAM,GAAG,CAAC;EACnB,OAAOb,IAAI;AACf;AACA,SAASc,iBAAiBA,CAAChB,QAAQ,EAAEC,GAAG,EAAEC,IAAI,EAAE;EAC5C,IAAI,CAACA,IAAI,CAACG,KAAK,EACXH,IAAI,CAACG,KAAK,GAAGL,QAAQ,CAACiB,gBAAgB;EAC1C,IAAI,CAACf,IAAI,CAACK,KAAK,EACXL,IAAI,CAACK,KAAK,GAAG,EAAE;EACnB,IAAI,CAACL,IAAI,CAACO,IAAI,EACVP,IAAI,CAACO,IAAI,GAAG,GAAG;EACnB,IAAI,CAACP,IAAI,CAAC9C,cAAc,CAAC,QAAQ,CAAC,EAC9B8C,IAAI,CAACQ,MAAM,GAAG,KAAK;EACvB,IAAI,CAACR,IAAI,CAAC9C,cAAc,CAAC,YAAY,CAAC,EAClC8C,IAAI,CAACU,UAAU,GAAG,KAAK;EAC3B,IAAI,CAACV,IAAI,CAACW,IAAI,IAAIX,IAAI,CAACW,IAAI,KAAK,EAAE,EAC9BX,IAAI,CAACW,IAAI,GAAGb,QAAQ,CAACkB,eAAe;EACxC,IAAI,CAAChB,IAAI,CAACa,MAAM,EACZb,IAAI,CAACa,MAAM,GAAG,CAAC;EACnB,OAAOb,IAAI;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIiB,KAAK,GAAG,aAAe,UAAUC,MAAM,EAAE;EACzC1E,SAAS,CAACyE,KAAK,EAAEC,MAAM,CAAC;EACxB,SAASD,KAAKA,CAACE,KAAK,EAAEC,SAAS,EAAEtB,QAAQ,EAAE;IACvC,IAAIA,QAAQ,KAAK,KAAK,CAAC,EAAE;MAAEA,QAAQ,GAAG,CAAC,CAAC;IAAE;IAC1C,IAAIuB,KAAK,GAAGH,MAAM,CAAC/D,IAAI,CAAC,IAAI,CAAC,IAAI,IAAI;IACrCkE,KAAK,CAACC,QAAQ,GAAG,CAAC,CAAC;IACnBD,KAAK,CAACE,cAAc,GAAG,CAAC,CAAC;IACzBF,KAAK,CAACG,aAAa,GAAG,CAAC,CAAC;IACxBH,KAAK,CAACI,eAAe,GAAG,CAAC,CAAC;IAC1BJ,KAAK,CAACK,QAAQ,GAAG,IAAIvC,UAAU,CAACwC,OAAO,CAAC,CAAC;IACzCN,KAAK,CAACO,SAAS,GAAG,IAAItC,QAAQ,CAACuC,SAAS,CAAC,CAAC;IAC1CR,KAAK,CAACS,aAAa,GAAG,CAAC,CAAC;IACxBT,KAAK,CAACU,aAAa,GAAG,CAAC,CAAC;IACxBV,KAAK,CAACW,qBAAqB,GAAG,EAAE;IAChCX,KAAK,CAACY,qBAAqB,GAAG,EAAE;IAChCZ,KAAK,CAACa,UAAU,GAAG;MAAEC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;MAAEC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC;IAAE,CAAC;IAC3Cf,KAAK,CAACgB,MAAM,GAAG,CAAC,CAAC,EAAE5C,UAAU,CAAC6C,QAAQ,EAAE,CAAC;IACzCjB,KAAK,CAACkB,SAAS,GAAG,CAAC,CAAC,EAAE9C,UAAU,CAAC6C,QAAQ,EAAE,CAAC;IAC5CjB,KAAK,CAACmB,eAAe,GAAG,CAAC;IACzBnB,KAAK,CAACoB,UAAU,GAAG,IAAI;IACvBpB,KAAK,CAACqB,qBAAqB,GAAG,CAAC,CAAC,EAAErD,OAAO,CAACsD,2BAA2B,EAAE;MACnER,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;MACTC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC;IACZ,CAAC,CAAC;IACF;IACAf,KAAK,CAACuB,eAAe,GAAG,CAAC;IACzB;IACAvB,KAAK,CAACwB,KAAK,GAAG,CAAC;IACfxB,KAAK,CAACyB,MAAM,GAAG,CAAC;IAChBzB,KAAK,CAAC0B,UAAU,GAAG,CAAC,CAAC,EAAE1D,OAAO,CAAC2D,aAAa,EAAE,CAAC;IAC/C;IACA3B,KAAK,CAAC4B,eAAe,GAAG,IAAIC,GAAG,CAAC,CAAC;IACjC7B,KAAK,CAAC8B,gBAAgB,GAAG,IAAID,GAAG,CAAC,CAAC;IAClC7B,KAAK,CAAC+B,WAAW,GAAG,IAAI;IACxB/B,KAAK,CAACgC,WAAW,GAAG,IAAI;IACxBhC,KAAK,CAACiC,WAAW,GAAG,IAAI;IACxBjC,KAAK,CAACkC,2BAA2B,GAAG,IAAI;IACxClC,KAAK,CAACmC,aAAa,GAAG,KAAK;IAC3BnC,KAAK,CAACoC,iBAAiB,GAAG,KAAK;IAC/BpC,KAAK,CAACqC,qBAAqB,GAAG,IAAI;IAClC;IACArC,KAAK,CAACsC,YAAY,GAAG,CAAC,CAAC;IACvBtC,KAAK,CAACuC,iBAAiB,GAAG,CAAC,CAAC;IAC5BvC,KAAK,CAACwC,YAAY,GAAG,CAAC,CAAC;IACvB;IACAxC,KAAK,CAACvB,QAAQ,GAAG,CAAC,CAAC,EAAEP,UAAU,CAACuE,eAAe,EAAEhE,QAAQ,CAAC;IAC1D;IACA,CAAC,CAAC,EAAEP,UAAU,CAACwE,gBAAgB,EAAE1C,KAAK,CAACvB,QAAQ,CAAC;IAChD,CAAC,CAAC,EAAET,OAAO,CAAC2E,aAAa,EAAE7C,KAAK,CAAC;IACjC,IAAI,EAAEC,SAAS,YAAY6C,WAAW,CAAC,EACnC,MAAM,IAAIhE,KAAK,CAAC,6CAA6C,CAAC;IAClE;IACAoB,KAAK,CAACF,KAAK,GAAGA,KAAK;IACnBE,KAAK,CAACD,SAAS,GAAGA,SAAS;IAC3B;IACAC,KAAK,CAAC6C,kBAAkB,CAAC,OAAO,EAAE;MAAEC,qBAAqB,EAAE;IAAK,CAAC,CAAC;IAClE9C,KAAK,CAAC+C,mBAAmB,CAAC,YAAY,CAAC;IACvC/C,KAAK,CAAC6C,kBAAkB,CAAC,OAAO,CAAC;IACjC7C,KAAK,CAAC+C,mBAAmB,CAAC,QAAQ,CAAC;IACnC/C,KAAK,CAAC+C,mBAAmB,CAAC,QAAQ,CAAC;IACnC/C,KAAK,CAAC6C,kBAAkB,CAAC,YAAY,CAAC;IACtC7C,KAAK,CAAC+C,mBAAmB,CAAC,OAAO,CAAC;IAClC;IACA,KAAK,IAAIrE,GAAG,IAAIsB,KAAK,CAACG,aAAa,EAAE;MACjC,IAAI6C,EAAE,GAAGhD,KAAK,CAACG,aAAa,CAACzB,GAAG,CAAC;MACjCsE,EAAE,CAACC,SAAS,CAACD,EAAE,CAACE,GAAG,EAAEF,EAAE,CAACG,mBAAmB,CAAC;MAC5CH,EAAE,CAACI,MAAM,CAACJ,EAAE,CAACK,KAAK,CAAC;IACvB;IACA;IACA,KAAK,IAAI/D,IAAI,IAAIU,KAAK,CAACvB,QAAQ,CAAC6E,kBAAkB,EAAE;MAChD,IAAIC,gBAAgB,GAAGvD,KAAK,CAACvB,QAAQ,CAAC6E,kBAAkB,CAAChE,IAAI,CAAC;MAC9DU,KAAK,CAACsC,YAAY,CAAChD,IAAI,CAAC,GAAG,IAAIiE,gBAAgB,CAACvD,KAAK,CAACG,aAAa,CAACqD,KAAK,EAAExD,KAAK,CAAC;MACjF,IAAIyD,gBAAgB,GAAGF,gBAAgB;MACvC,IAAIjE,IAAI,IAAIU,KAAK,CAACvB,QAAQ,CAACiF,uBAAuB,EAAE;QAChDD,gBAAgB,GAAGzD,KAAK,CAACvB,QAAQ,CAACiF,uBAAuB,CAACpE,IAAI,CAAC;MACnE;MACAU,KAAK,CAACuC,iBAAiB,CAACjD,IAAI,CAAC,GAAG,IAAImE,gBAAgB,CAACzD,KAAK,CAACG,aAAa,CAACwD,UAAU,EAAE3D,KAAK,CAAC;IAC/F;IACA,KAAK,IAAIV,IAAI,IAAIU,KAAK,CAACvB,QAAQ,CAACmF,kBAAkB,EAAE;MAChD,IAAIC,gBAAgB,GAAG7D,KAAK,CAACvB,QAAQ,CAACmF,kBAAkB,CAACtE,IAAI,CAAC;MAC9DU,KAAK,CAACwC,YAAY,CAAClD,IAAI,CAAC,GAAG,IAAIuE,gBAAgB,CAAC7D,KAAK,CAACG,aAAa,CAAC2D,KAAK,EAAE9D,KAAK,CAAC;IACrF;IACA;IACAA,KAAK,CAAC+D,MAAM,CAAC,CAAC;IACd;IACA/D,KAAK,CAACgE,MAAM,GAAG,IAAIpG,QAAQ,CAAC0C,OAAO,CAAC,CAAC;IACrC;IACAN,KAAK,CAACiE,kBAAkB,CAAC,CAAC;IAC1B;IACAjE,KAAK,CAACkE,WAAW,GAAG,IAAIrG,OAAO,CAACyC,OAAO,CAACN,KAAK,CAACC,QAAQ,CAACkE,KAAK,EAAEnE,KAAK,CAAC;IACpEA,KAAK,CAACoE,WAAW,GAAG,IAAIjG,OAAO,CAACmC,OAAO,CAACN,KAAK,CAACC,QAAQ,CAACkE,KAAK,EAAEnE,KAAK,CAAC;IACpE;IACAA,KAAK,CAACqE,iBAAiB,CAAC,CAAC;IACzB;IACArE,KAAK,CAACsE,iBAAiB,CAAC,CAAC;IACzB;IACAtE,KAAK,CAACuE,oBAAoB,CAAC,CAAC;IAC5B;IACAvE,KAAK,CAACwE,OAAO,CAAC,CAAC;IACfxE,KAAK,CAACyE,MAAM,CAAC,CAAC;IACd,OAAOzE,KAAK;EAChB;EACA;AACJ;AACA;AACA;EACI;AACJ;AACA;AACA;AACA;EACIJ,KAAK,CAAChE,SAAS,CAAC8I,YAAY,GAAG,UAAUC,EAAE,EAAE;IACzC,IAAIC,MAAM,GAAG,CAAC,CAAC,EAAE5G,OAAO,CAAC6G,aAAa,EAAE,QAAQ,EAAE;MAC9CC,QAAQ,EAAE;IACd,CAAC,EAAE;MACCC,KAAK,EAAE,QAAQ,CAAClG,MAAM,CAAC8F,EAAE;IAC7B,CAAC,CAAC;IACF,IAAI,CAAC1E,QAAQ,CAAC0E,EAAE,CAAC,GAAGC,MAAM;IAC1B,IAAI,CAAC7E,SAAS,CAACiF,WAAW,CAACJ,MAAM,CAAC;IAClC,OAAOA,MAAM;EACjB,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;EACIhF,KAAK,CAAChE,SAAS,CAACmH,mBAAmB,GAAG,UAAU4B,EAAE,EAAE;IAChD,IAAIC,MAAM,GAAG,IAAI,CAACF,YAAY,CAACC,EAAE,CAAC;IAClC,IAAIM,cAAc,GAAG;MACjBnC,qBAAqB,EAAE,KAAK;MAC5BoC,SAAS,EAAE;IACf,CAAC;IACD,IAAI,CAAChF,cAAc,CAACyE,EAAE,CAAC,GAAGC,MAAM,CAACO,UAAU,CAAC,IAAI,EAAEF,cAAc,CAAC;IACjE,OAAO,IAAI;EACf,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIrF,KAAK,CAAChE,SAAS,CAACiH,kBAAkB,GAAG,UAAU8B,EAAE,EAAES,OAAO,EAAE;IACxD,IAAIR,MAAM,GAAG,IAAI,CAACF,YAAY,CAACC,EAAE,CAAC;IAClC,IAAIM,cAAc,GAAG7I,QAAQ,CAAC;MAAE0G,qBAAqB,EAAE,KAAK;MAAEoC,SAAS,EAAE;IAAM,CAAC,EAAGE,OAAO,IAAI,CAAC,CAAE,CAAC;IAClG,IAAIC,OAAO;IACX;IACAA,OAAO,GAAGT,MAAM,CAACO,UAAU,CAAC,QAAQ,EAAEF,cAAc,CAAC;IACrD;IACA,IAAI,CAACI,OAAO,EACRA,OAAO,GAAGT,MAAM,CAACO,UAAU,CAAC,OAAO,EAAEF,cAAc,CAAC;IACxD;IACA,IAAI,CAACI,OAAO,EACRA,OAAO,GAAGT,MAAM,CAACO,UAAU,CAAC,oBAAoB,EAAEF,cAAc,CAAC;IACrE,IAAI,CAAC9E,aAAa,CAACwE,EAAE,CAAC,GAAGU,OAAO;IAChC,OAAO,IAAI;EACf,CAAC;EACD;AACJ;AACA;AACA;AACA;EACIzF,KAAK,CAAChE,SAAS,CAACqI,kBAAkB,GAAG,YAAY;IAC7C,IAAIjE,KAAK,GAAG,IAAI;IAChB,IAAI,CAACI,eAAe,CAAC4D,MAAM,GAAG,YAAY;MACtChE,KAAK,CAACsF,gBAAgB,CAAC,CAAC;IAC5B,CAAC;IACD,IAAI,CAACtB,MAAM,CAACuB,EAAE,CAAC,SAAS,EAAE,IAAI,CAACnF,eAAe,CAAC4D,MAAM,CAAC;IACtD,OAAO,IAAI;EACf,CAAC;EACD;AACJ;AACA;EACIpE,KAAK,CAAChE,SAAS,CAAC4J,aAAa,GAAG,UAAUC,EAAE,EAAEC,EAAE,EAAExG,IAAI,EAAE;IACpD,IAAI4B,CAAC,GAAG2E,EAAE,CAAC3E,CAAC;MAAEC,CAAC,GAAG0E,EAAE,CAAC1E,CAAC;IACtB,IAAI4E,KAAK,GAAGD,EAAE,CAAC5E,CAAC;MAAE8E,KAAK,GAAGF,EAAE,CAAC3E,CAAC;IAC9B,OAAQD,CAAC,GAAG6E,KAAK,GAAGzG,IAAI,IACpB4B,CAAC,GAAG6E,KAAK,GAAGzG,IAAI,IAChB6B,CAAC,GAAG6E,KAAK,GAAG1G,IAAI,IAChB6B,CAAC,GAAG6E,KAAK,GAAG1G,IAAI,IAChB2G,IAAI,CAACC,IAAI,CAACD,IAAI,CAACE,GAAG,CAACjF,CAAC,GAAG6E,KAAK,EAAE,CAAC,CAAC,GAAGE,IAAI,CAACE,GAAG,CAAChF,CAAC,GAAG6E,KAAK,EAAE,CAAC,CAAC,CAAC,GAAG1G,IAAI;EACzE,CAAC;EACD;AACJ;AACA;EACIU,KAAK,CAAChE,SAAS,CAACoK,YAAY,GAAG,UAAUlB,QAAQ,EAAE;IAC/C,IAAImB,kBAAkB,GAAG,IAAI,CAACC,qBAAqB,CAACpB,QAAQ,CAAC;IAC7D,OAAO,IAAI,CAACzE,QAAQ,CAAC8F,KAAK,CAACF,kBAAkB,CAACnF,CAAC,EAAE,CAAC,GAAGmF,kBAAkB,CAAClF,CAAC,CAAC;EAC9E,CAAC;EACD;AACJ;AACA;EACInB,KAAK,CAAChE,SAAS,CAACwK,iBAAiB,GAAG,UAAUtB,QAAQ,EAAE;IACpD,IAAIhE,CAAC,GAAGgE,QAAQ,CAAChE,CAAC;MAAEC,CAAC,GAAG+D,QAAQ,CAAC/D,CAAC;IAClC,IAAIsF,SAAS,GAAG,IAAI,CAACL,YAAY,CAAClB,QAAQ,CAAC;IAC3C;IACA,IAAIwB,WAAW,GAAGC,QAAQ;MAAEC,cAAc,GAAG,IAAI;IACjD,KAAK,IAAIhK,CAAC,GAAG,CAAC,EAAEiK,CAAC,GAAGJ,SAAS,CAAC1J,MAAM,EAAEH,CAAC,GAAGiK,CAAC,EAAEjK,CAAC,EAAE,EAAE;MAC9C,IAAIkK,IAAI,GAAGL,SAAS,CAAC7J,CAAC,CAAC;MACvB,IAAImC,IAAI,GAAG,IAAI,CAAC8B,aAAa,CAACiG,IAAI,CAAC;MACnC,IAAIC,YAAY,GAAG,IAAI,CAACC,qBAAqB,CAACjI,IAAI,CAAC;MACnD,IAAIO,IAAI,GAAG,IAAI,CAAC2H,SAAS,CAAClI,IAAI,CAACO,IAAI,CAAC;MACpC,IAAI,CAACP,IAAI,CAACQ,MAAM,IAAI,IAAI,CAACqG,aAAa,CAACV,QAAQ,EAAE6B,YAAY,EAAEzH,IAAI,CAAC,EAAE;QAClE,IAAI4H,QAAQ,GAAGjB,IAAI,CAACC,IAAI,CAACD,IAAI,CAACE,GAAG,CAACjF,CAAC,GAAG6F,YAAY,CAAC7F,CAAC,EAAE,CAAC,CAAC,GAAG+E,IAAI,CAACE,GAAG,CAAChF,CAAC,GAAG4F,YAAY,CAAC5F,CAAC,EAAE,CAAC,CAAC,CAAC;QAC3F;QACA,IAAI+F,QAAQ,GAAGR,WAAW,EAAE;UACxBA,WAAW,GAAGQ,QAAQ;UACtBN,cAAc,GAAGE,IAAI;QACzB;MACJ;IACJ;IACA,OAAOF,cAAc;EACzB,CAAC;EACD;AACJ;AACA;AACA;AACA;EACI5G,KAAK,CAAChE,SAAS,CAACyI,iBAAiB,GAAG,YAAY;IAC5C,IAAIrE,KAAK,GAAG,IAAI;IAChB;IACA,IAAI,CAACI,eAAe,CAAC2G,YAAY,GAAG,YAAY;MAC5C/G,KAAK,CAACoC,iBAAiB,GAAG,IAAI;MAC9BpC,KAAK,CAACsF,gBAAgB,CAAC,CAAC;IAC5B,CAAC;IACD0B,MAAM,CAACC,gBAAgB,CAAC,QAAQ,EAAE,IAAI,CAAC7G,eAAe,CAAC2G,YAAY,CAAC;IACpE;IACA,IAAI,CAAC3G,eAAe,CAAC8G,UAAU,GAAG,UAAUC,CAAC,EAAE;MAC3C,IAAIC,SAAS,GAAG;QACZC,KAAK,EAAEF,CAAC;QACRG,mBAAmB,EAAE,SAAAA,CAAA,EAAY;UAC7BH,CAAC,CAACG,mBAAmB,CAAC,CAAC;QAC3B;MACJ,CAAC;MACD,IAAIC,WAAW,GAAGvH,KAAK,CAACoG,iBAAiB,CAACe,CAAC,CAAC;MAC5C,IAAII,WAAW,IAAIvH,KAAK,CAAC+B,WAAW,KAAKwF,WAAW,IAAI,CAACvH,KAAK,CAACS,aAAa,CAAC8G,WAAW,CAAC,CAACpI,MAAM,EAAE;QAC9F;QACA,IAAIa,KAAK,CAAC+B,WAAW,EACjB/B,KAAK,CAACwH,IAAI,CAAC,WAAW,EAAEpL,QAAQ,CAACA,QAAQ,CAAC,CAAC,CAAC,EAAEgL,SAAS,CAAC,EAAE;UAAEV,IAAI,EAAE1G,KAAK,CAAC+B;QAAY,CAAC,CAAC,CAAC;QAC3F/B,KAAK,CAAC+B,WAAW,GAAGwF,WAAW;QAC/BvH,KAAK,CAACwH,IAAI,CAAC,WAAW,EAAEpL,QAAQ,CAACA,QAAQ,CAAC,CAAC,CAAC,EAAEgL,SAAS,CAAC,EAAE;UAAEV,IAAI,EAAEa;QAAY,CAAC,CAAC,CAAC;QACjFvH,KAAK,CAACyH,8BAA8B,CAAC,CAAC;QACtC;MACJ;MACA;MACA,IAAIzH,KAAK,CAAC+B,WAAW,EAAE;QACnB,IAAIpD,IAAI,GAAGqB,KAAK,CAACS,aAAa,CAACT,KAAK,CAAC+B,WAAW,CAAC;QACjD,IAAI2F,GAAG,GAAG1H,KAAK,CAAC4G,qBAAqB,CAACjI,IAAI,CAAC;QAC3C,IAAIO,IAAI,GAAGc,KAAK,CAAC6G,SAAS,CAAClI,IAAI,CAACO,IAAI,CAAC;QACrC,IAAI,CAACc,KAAK,CAACwF,aAAa,CAAC2B,CAAC,EAAEO,GAAG,EAAExI,IAAI,CAAC,EAAE;UACpC,IAAIwH,IAAI,GAAG1G,KAAK,CAAC+B,WAAW;UAC5B/B,KAAK,CAAC+B,WAAW,GAAG,IAAI;UACxB/B,KAAK,CAACwH,IAAI,CAAC,WAAW,EAAEpL,QAAQ,CAACA,QAAQ,CAAC,CAAC,CAAC,EAAEgL,SAAS,CAAC,EAAE;YAAEV,IAAI,EAAEA;UAAK,CAAC,CAAC,CAAC;UAC1E1G,KAAK,CAACyH,8BAA8B,CAAC,CAAC;UACtC;QACJ;MACJ;MACA,IAAIzH,KAAK,CAACvB,QAAQ,CAACkJ,qBAAqB,KAAK,IAAI,EAAE;QAC/C3H,KAAK,CAAC4H,oBAAoB,CAACR,SAAS,CAAC;MACzC,CAAC,MACI,IAAIpH,KAAK,CAACvB,QAAQ,CAACkJ,qBAAqB,KAAK,UAAU,EAAE;QAC1D,IAAI,CAAC3H,KAAK,CAACqC,qBAAqB,EAC5BrC,KAAK,CAACqC,qBAAqB,GAAG,CAAC,CAAC,EAAErE,OAAO,CAAC6J,YAAY,EAAE,YAAY;UAChE7H,KAAK,CAAC4H,oBAAoB,CAACR,SAAS,CAAC;UACrCpH,KAAK,CAACqC,qBAAqB,GAAG,IAAI;QACtC,CAAC,CAAC;MACV;IACJ,CAAC;IACD;IACA,IAAIyF,mBAAmB,GAAG,SAAAA,CAAUC,SAAS,EAAE;MAC3C,OAAO,UAAUZ,CAAC,EAAE;QAChB,IAAIC,SAAS,GAAG;UACZC,KAAK,EAAEF,CAAC;UACRG,mBAAmB,EAAE,SAAAA,CAAA,EAAY;YAC7BH,CAAC,CAACG,mBAAmB,CAAC,CAAC;UAC3B;QACJ,CAAC;QACD,IAAIU,qBAAqB,GAAGb,CAAC,CAACc,QAAQ,CAACD,qBAAqB;QAC5D,IAAIxB,cAAc,GAAGwB,qBAAqB,GAAGhI,KAAK,CAACoG,iBAAiB,CAACe,CAAC,CAAC,GAAGnH,KAAK,CAAC+B,WAAW;QAC3F,IAAIyE,cAAc,EACd,OAAOxG,KAAK,CAACwH,IAAI,CAAC,EAAE,CAAC3I,MAAM,CAACkJ,SAAS,EAAE,MAAM,CAAC,EAAE3L,QAAQ,CAACA,QAAQ,CAAC,CAAC,CAAC,EAAEgL,SAAS,CAAC,EAAE;UAAEV,IAAI,EAAEF;QAAe,CAAC,CAAC,CAAC;QAChH,IAAIuB,SAAS,KAAK,OAAO,GAAG/H,KAAK,CAACvB,QAAQ,CAACyJ,qBAAqB,GAAGlI,KAAK,CAACvB,QAAQ,CAAC0J,qBAAqB,EAAE;UACrG,IAAIC,IAAI,GAAGpI,KAAK,CAACqI,cAAc,CAAClB,CAAC,CAACrG,CAAC,EAAEqG,CAAC,CAACpG,CAAC,CAAC;UACzC,IAAIqH,IAAI,EACJ,OAAOpI,KAAK,CAACwH,IAAI,CAAC,EAAE,CAAC3I,MAAM,CAACkJ,SAAS,EAAE,MAAM,CAAC,EAAE3L,QAAQ,CAACA,QAAQ,CAAC,CAAC,CAAC,EAAEgL,SAAS,CAAC,EAAE;YAAEgB,IAAI,EAAEA;UAAK,CAAC,CAAC,CAAC;QAC1G;QACA,OAAOpI,KAAK,CAACwH,IAAI,CAAC,EAAE,CAAC3I,MAAM,CAACkJ,SAAS,EAAE,OAAO,CAAC,EAAEX,SAAS,CAAC;MAC/D,CAAC;IACL,CAAC;IACD,IAAI,CAAChH,eAAe,CAACkI,WAAW,GAAGR,mBAAmB,CAAC,OAAO,CAAC;IAC/D,IAAI,CAAC1H,eAAe,CAACmI,gBAAgB,GAAGT,mBAAmB,CAAC,YAAY,CAAC;IACzE,IAAI,CAAC1H,eAAe,CAACoI,iBAAiB,GAAGV,mBAAmB,CAAC,aAAa,CAAC;IAC3E,IAAI,CAAC1H,eAAe,CAACqI,WAAW,GAAGX,mBAAmB,CAAC,OAAO,CAAC;IAC/D,IAAI,CAAC1H,eAAe,CAACsI,UAAU,GAAGZ,mBAAmB,CAAC,MAAM,CAAC;IAC7D,IAAI,CAAC5D,WAAW,CAACqB,EAAE,CAAC,WAAW,EAAE,IAAI,CAACnF,eAAe,CAAC8G,UAAU,CAAC;IACjE,IAAI,CAAChD,WAAW,CAACqB,EAAE,CAAC,OAAO,EAAE,IAAI,CAACnF,eAAe,CAACkI,WAAW,CAAC;IAC9D,IAAI,CAACpE,WAAW,CAACqB,EAAE,CAAC,YAAY,EAAE,IAAI,CAACnF,eAAe,CAACmI,gBAAgB,CAAC;IACxE,IAAI,CAACrE,WAAW,CAACqB,EAAE,CAAC,aAAa,EAAE,IAAI,CAACnF,eAAe,CAACoI,iBAAiB,CAAC;IAC1E,IAAI,CAACtE,WAAW,CAACqB,EAAE,CAAC,OAAO,EAAE,IAAI,CAACnF,eAAe,CAACqI,WAAW,CAAC;IAC9D,IAAI,CAACvE,WAAW,CAACqB,EAAE,CAAC,WAAW,EAAE,IAAI,CAACnF,eAAe,CAACsI,UAAU,CAAC;IACjE;IACA;IACA,OAAO,IAAI;EACf,CAAC;EACD;AACJ;AACA;AACA;AACA;EACI9I,KAAK,CAAChE,SAAS,CAAC0I,iBAAiB,GAAG,YAAY;IAC5C,IAAItE,KAAK,GAAG,IAAI;IAChB,IAAIF,KAAK,GAAG,IAAI,CAACA,KAAK;IACtB,IAAI,CAACM,eAAe,CAACuI,WAAW,GAAG,YAAY;MAC3C3I,KAAK,CAACmC,aAAa,GAAG,IAAI;MAC1BnC,KAAK,CAACsF,gBAAgB,CAAC,CAAC;IAC5B,CAAC;IACD,IAAI,CAAClF,eAAe,CAACwI,eAAe,GAAG,YAAY;MAC/C5I,KAAK,CAACoC,iBAAiB,GAAG,IAAI;MAC9BpC,KAAK,CAACsF,gBAAgB,CAAC,CAAC;IAC5B,CAAC;IACD,IAAI,CAAClF,eAAe,CAACyI,mBAAmB,GAAG,UAAU1B,CAAC,EAAE;MACpD,OAAOnH,KAAK,CAACS,aAAa,CAAC0G,CAAC,CAACzI,GAAG,CAAC;MACjC,IAAIsB,KAAK,CAAC+B,WAAW,KAAKoF,CAAC,CAACzI,GAAG,EAC3BsB,KAAK,CAAC+B,WAAW,GAAG,IAAI;MAC5B/B,KAAK,CAACI,eAAe,CAACuI,WAAW,CAAC,CAAC;IACvC,CAAC;IACD,IAAI,CAACvI,eAAe,CAAC0I,mBAAmB,GAAG,UAAU3B,CAAC,EAAE;MACpD,OAAOnH,KAAK,CAACU,aAAa,CAACyG,CAAC,CAACzI,GAAG,CAAC;MACjC,IAAIsB,KAAK,CAACgC,WAAW,KAAKmF,CAAC,CAACzI,GAAG,EAC3BsB,KAAK,CAACgC,WAAW,GAAG,IAAI;MAC5BhC,KAAK,CAACI,eAAe,CAACuI,WAAW,CAAC,CAAC;IACvC,CAAC;IACD,IAAI,CAACvI,eAAe,CAAC2I,qBAAqB,GAAG,YAAY;MACrD/I,KAAK,CAACU,aAAa,GAAG,CAAC,CAAC;MACxBV,KAAK,CAACgC,WAAW,GAAG,IAAI;MACxBhC,KAAK,CAACI,eAAe,CAACuI,WAAW,CAAC,CAAC;IACvC,CAAC;IACD,IAAI,CAACvI,eAAe,CAAC4I,gBAAgB,GAAG,YAAY;MAChDhJ,KAAK,CAACS,aAAa,GAAG,CAAC,CAAC;MACxBT,KAAK,CAAC+B,WAAW,GAAG,IAAI;MACxB/B,KAAK,CAACI,eAAe,CAAC2I,qBAAqB,CAAC,CAAC;IACjD,CAAC;IACDjJ,KAAK,CAACyF,EAAE,CAAC,WAAW,EAAE,IAAI,CAACnF,eAAe,CAACuI,WAAW,CAAC;IACvD7I,KAAK,CAACyF,EAAE,CAAC,aAAa,EAAE,IAAI,CAACnF,eAAe,CAACyI,mBAAmB,CAAC;IACjE/I,KAAK,CAACyF,EAAE,CAAC,uBAAuB,EAAE,IAAI,CAACnF,eAAe,CAACwI,eAAe,CAAC;IACvE9I,KAAK,CAACyF,EAAE,CAAC,2BAA2B,EAAE,IAAI,CAACnF,eAAe,CAACuI,WAAW,CAAC;IACvE7I,KAAK,CAACyF,EAAE,CAAC,WAAW,EAAE,IAAI,CAACnF,eAAe,CAACuI,WAAW,CAAC;IACvD7I,KAAK,CAACyF,EAAE,CAAC,aAAa,EAAE,IAAI,CAACnF,eAAe,CAAC0I,mBAAmB,CAAC;IACjEhJ,KAAK,CAACyF,EAAE,CAAC,uBAAuB,EAAE,IAAI,CAACnF,eAAe,CAACwI,eAAe,CAAC;IACvE9I,KAAK,CAACyF,EAAE,CAAC,2BAA2B,EAAE,IAAI,CAACnF,eAAe,CAACuI,WAAW,CAAC;IACvE7I,KAAK,CAACyF,EAAE,CAAC,cAAc,EAAE,IAAI,CAACnF,eAAe,CAAC2I,qBAAqB,CAAC;IACpEjJ,KAAK,CAACyF,EAAE,CAAC,SAAS,EAAE,IAAI,CAACnF,eAAe,CAAC4I,gBAAgB,CAAC;IAC1D,OAAO,IAAI;EACf,CAAC;EACD;AACJ;AACA;AACA;AACA;EACIpJ,KAAK,CAAChE,SAAS,CAACqN,mBAAmB,GAAG,YAAY;IAC9C,IAAInJ,KAAK,GAAG,IAAI,CAACA,KAAK;IACtBA,KAAK,CAACoJ,cAAc,CAAC,WAAW,EAAE,IAAI,CAAC9I,eAAe,CAACuI,WAAW,CAAC;IACnE7I,KAAK,CAACoJ,cAAc,CAAC,aAAa,EAAE,IAAI,CAAC9I,eAAe,CAACyI,mBAAmB,CAAC;IAC7E/I,KAAK,CAACoJ,cAAc,CAAC,uBAAuB,EAAE,IAAI,CAAC9I,eAAe,CAACwI,eAAe,CAAC;IACnF9I,KAAK,CAACoJ,cAAc,CAAC,2BAA2B,EAAE,IAAI,CAAC9I,eAAe,CAACuI,WAAW,CAAC;IACnF7I,KAAK,CAACoJ,cAAc,CAAC,WAAW,EAAE,IAAI,CAAC9I,eAAe,CAACuI,WAAW,CAAC;IACnE7I,KAAK,CAACoJ,cAAc,CAAC,aAAa,EAAE,IAAI,CAAC9I,eAAe,CAAC0I,mBAAmB,CAAC;IAC7EhJ,KAAK,CAACoJ,cAAc,CAAC,uBAAuB,EAAE,IAAI,CAAC9I,eAAe,CAACwI,eAAe,CAAC;IACnF9I,KAAK,CAACoJ,cAAc,CAAC,2BAA2B,EAAE,IAAI,CAAC9I,eAAe,CAACuI,WAAW,CAAC;IACnF7I,KAAK,CAACoJ,cAAc,CAAC,cAAc,EAAE,IAAI,CAAC9I,eAAe,CAAC2I,qBAAqB,CAAC;IAChFjJ,KAAK,CAACoJ,cAAc,CAAC,SAAS,EAAE,IAAI,CAAC9I,eAAe,CAAC4I,gBAAgB,CAAC;EAC1E,CAAC;EACD;AACJ;AACA;AACA;AACA;EACIpJ,KAAK,CAAChE,SAAS,CAACgM,oBAAoB,GAAG,UAAUuB,OAAO,EAAE;IACtD,IAAIC,WAAW,GAAG,IAAI,CAACrH,WAAW,GAAG,IAAI,GAAG,IAAI,CAACsG,cAAc,CAACc,OAAO,CAAC9B,KAAK,CAACvG,CAAC,EAAEqI,OAAO,CAAC9B,KAAK,CAACtG,CAAC,CAAC;IACjG,IAAIqI,WAAW,KAAK,IAAI,CAACpH,WAAW,EAAE;MAClC,IAAI,IAAI,CAACA,WAAW,EAChB,IAAI,CAACwF,IAAI,CAAC,WAAW,EAAEpL,QAAQ,CAACA,QAAQ,CAAC,CAAC,CAAC,EAAE+M,OAAO,CAAC,EAAE;QAAEf,IAAI,EAAE,IAAI,CAACpG;MAAY,CAAC,CAAC,CAAC;MACvF,IAAIoH,WAAW,EACX,IAAI,CAAC5B,IAAI,CAAC,WAAW,EAAEpL,QAAQ,CAACA,QAAQ,CAAC,CAAC,CAAC,EAAE+M,OAAO,CAAC,EAAE;QAAEf,IAAI,EAAEgB;MAAY,CAAC,CAAC,CAAC;MAClF,IAAI,CAACpH,WAAW,GAAGoH,WAAW;IAClC;IACA,OAAO,IAAI;EACf,CAAC;EACD;AACJ;AACA;AACA;EACIxJ,KAAK,CAAChE,SAAS,CAACyM,cAAc,GAAG,UAAUvH,CAAC,EAAEC,CAAC,EAAE;IAC7C,IAAIsI,GAAG,EAAE5D,EAAE;IACX,IAAIzF,KAAK,GAAG,IAAI;IAChB,IAAI0F,EAAE,GAAG,IAAI;MAAEhF,aAAa,GAAGgF,EAAE,CAAChF,aAAa;MAAED,aAAa,GAAGiF,EAAE,CAACjF,aAAa;IACjF;IACA;IACA;IACA,IAAI,CAAC,CAAC,CAAC,EAAEpC,iBAAiB,CAACiL,cAAc,EAAE,IAAI,CAACnJ,aAAa,CAAC2D,KAAK,EAAEhD,CAAC,GAAG,IAAI,CAACY,UAAU,EAAEX,CAAC,GAAG,IAAI,CAACW,UAAU,CAAC,EAC1G,OAAO,IAAI;IACf;IACA,IAAI6H,EAAE,GAAG,IAAI,CAACC,eAAe,CAAC;QAAE1I,CAAC,EAAEA,CAAC;QAAEC,CAAC,EAAEA;MAAE,CAAC,CAAC;MAAE0I,MAAM,GAAGF,EAAE,CAACzI,CAAC;MAAE4I,MAAM,GAAGH,EAAE,CAACxI,CAAC;IAC3E;IACA;IACA;IACA,IAAI4I,mBAAmB,GAAG,CAAC;IAC3B,IAAI,CAAC7J,KAAK,CAAC8J,QAAQ,CAAC,UAAUlL,GAAG,EAAEmL,CAAC,EAAEC,QAAQ,EAAEC,QAAQ,EAAEtE,EAAE,EAAEC,EAAE,EAAE;MAC9D,IAAIsE,EAAE,GAAGvE,EAAE,CAAC3E,CAAC;QAAEmJ,EAAE,GAAGxE,EAAE,CAAC1E,CAAC;MACxB,IAAImJ,EAAE,GAAGxE,EAAE,CAAC5E,CAAC;QAAEqJ,EAAE,GAAGzE,EAAE,CAAC3E,CAAC;MACxB,IAAIL,aAAa,CAAChC,GAAG,CAAC,CAACS,MAAM,IAAIsB,aAAa,CAACqJ,QAAQ,CAAC,CAAC3K,MAAM,IAAIsB,aAAa,CAACsJ,QAAQ,CAAC,CAAC5K,MAAM,EAC7F,OAAO,KAAK;MAChB,IAAI6K,EAAE,KAAKE,EAAE,IAAID,EAAE,KAAKE,EAAE,EAAE;QACxB,IAAIC,WAAW,GAAGvE,IAAI,CAACC,IAAI,CAACD,IAAI,CAACE,GAAG,CAACmE,EAAE,GAAGF,EAAE,EAAE,CAAC,CAAC,GAAGnE,IAAI,CAACE,GAAG,CAACoE,EAAE,GAAGF,EAAE,EAAE,CAAC,CAAC,CAAC;QACxE,IAAIV,EAAE,GAAGvJ,KAAK,CAACqK,eAAe,CAAC;YAAEvJ,CAAC,EAAEkJ,EAAE;YAAEjJ,CAAC,EAAEkJ;UAAG,CAAC,CAAC;UAAEK,KAAK,GAAGf,EAAE,CAACzI,CAAC;UAAEyJ,KAAK,GAAGhB,EAAE,CAACxI,CAAC;QAC5E,IAAIyJ,EAAE,GAAGxK,KAAK,CAACqK,eAAe,CAAC;YAAEvJ,CAAC,EAAEoJ,EAAE;YAAEnJ,CAAC,EAAEoJ;UAAG,CAAC,CAAC;UAAEM,KAAK,GAAGD,EAAE,CAAC1J,CAAC;UAAE4J,KAAK,GAAGF,EAAE,CAACzJ,CAAC;QAC5E,IAAI4J,cAAc,GAAG9E,IAAI,CAACC,IAAI,CAACD,IAAI,CAACE,GAAG,CAAC0E,KAAK,GAAGH,KAAK,EAAE,CAAC,CAAC,GAAGzE,IAAI,CAACE,GAAG,CAAC2E,KAAK,GAAGH,KAAK,EAAE,CAAC,CAAC,CAAC;QACvFZ,mBAAmB,GAAGS,WAAW,GAAGO,cAAc;QAClD,OAAO,IAAI;MACf;IACJ,CAAC,CAAC;IACF;IACA,IAAI,CAAChB,mBAAmB,EACpB,OAAO,IAAI;IACf;IACA,IAAI7F,KAAK,GAAG,IAAI,CAAChE,KAAK,CAAC8K,WAAW,CAAC,UAAUlM,GAAG,EAAEmM,cAAc,EAAEf,QAAQ,EAAEC,QAAQ,EAAEe,cAAc,EAAEC,cAAc,EAAE;MAClH,IAAIrK,aAAa,CAAChC,GAAG,CAAC,CAACS,MAAM,IAAIsB,aAAa,CAACqJ,QAAQ,CAAC,CAAC3K,MAAM,IAAIsB,aAAa,CAACsJ,QAAQ,CAAC,CAAC5K,MAAM,EAC7F,OAAO,KAAK;MAChB,IAAI,CAAC,CAAC,EAAEd,iBAAiB,CAAC2M,sBAAsB,EAAEvB,MAAM,EAAEC,MAAM,EAAEoB,cAAc,CAAChK,CAAC,EAAEgK,cAAc,CAAC/J,CAAC,EAAEgK,cAAc,CAACjK,CAAC,EAAEiK,cAAc,CAAChK,CAAC;MACxI;MACCL,aAAa,CAAChC,GAAG,CAAC,CAACQ,IAAI,GAAGyK,mBAAmB,GAAI3J,KAAK,CAACuB,eAAe,CAAC,EAAE;QACtE,OAAO,IAAI;MACf;IACJ,CAAC,CAAC;IACF,IAAIuC,KAAK,CAACnH,MAAM,KAAK,CAAC,EAClB,OAAO,IAAI,CAAC,CAAC;IACjB;IACA,IAAIsO,YAAY,GAAGnH,KAAK,CAACA,KAAK,CAACnH,MAAM,GAAG,CAAC,CAAC;IAC1C;IACA,IAAIuO,aAAa,GAAG,CAAC3E,QAAQ;IAC7B,IAAI;MACA,KAAK,IAAI4E,OAAO,GAAGtO,QAAQ,CAACiH,KAAK,CAAC,EAAEsH,SAAS,GAAGD,OAAO,CAACjO,IAAI,CAAC,CAAC,EAAE,CAACkO,SAAS,CAAChO,IAAI,EAAEgO,SAAS,GAAGD,OAAO,CAACjO,IAAI,CAAC,CAAC,EAAE;QACzG,IAAIkL,IAAI,GAAGgD,SAAS,CAACjO,KAAK;QAC1B,IAAIqC,MAAM,GAAG,IAAI,CAACM,KAAK,CAACuL,gBAAgB,CAACjD,IAAI,EAAE,QAAQ,CAAC;QACxD,IAAI5I,MAAM,IAAI0L,aAAa,EAAE;UACzBD,YAAY,GAAG7C,IAAI;UACnB8C,aAAa,GAAG1L,MAAM;QAC1B;MACJ;IACJ,CAAC,CACD,OAAO8L,KAAK,EAAE;MAAEjC,GAAG,GAAG;QAAEkC,KAAK,EAAED;MAAM,CAAC;IAAE,CAAC,SACjC;MACJ,IAAI;QACA,IAAIF,SAAS,IAAI,CAACA,SAAS,CAAChO,IAAI,KAAKqI,EAAE,GAAG0F,OAAO,CAACK,MAAM,CAAC,EAAE/F,EAAE,CAAC3J,IAAI,CAACqP,OAAO,CAAC;MAC/E,CAAC,SACO;QAAE,IAAI9B,GAAG,EAAE,MAAMA,GAAG,CAACkC,KAAK;MAAE;IACxC;IACA,OAAON,YAAY;EACvB,CAAC;EACD;AACJ;AACA;AACA;AACA;EACIrL,KAAK,CAAChE,SAAS,CAAC4I,OAAO,GAAG,UAAUiH,UAAU,EAAE;IAC5C,IAAIzL,KAAK,GAAG,IAAI;IAChB,IAAIyL,UAAU,KAAK,KAAK,CAAC,EAAE;MAAEA,UAAU,GAAG,KAAK;IAAE;IACjD,IAAI3L,KAAK,GAAG,IAAI,CAACA,KAAK;IACtB,IAAIrB,QAAQ,GAAG,IAAI,CAACA,QAAQ;IAC5B,IAAIiN,UAAU,GAAG,IAAI,CAACC,aAAa,CAAC,CAAC;IACrC,IAAIC,WAAW,GAAG,CAACrF,QAAQ,EAAE,CAACA,QAAQ,CAAC;IACvC,IAAIsF,WAAW,GAAG,CAACtF,QAAQ,EAAE,CAACA,QAAQ,CAAC;IACvC;IACA,IAAI,CAAClG,QAAQ,CAACyL,KAAK,CAAC,CAAC;IACrB;IACA;IACA,IAAI,CAACvL,SAAS,CAACwL,cAAc,CAACL,UAAU,EAAEjN,QAAQ,CAACuN,iBAAiB,CAAC;IACrE;IACA,IAAI,CAAClK,gBAAgB,GAAG,IAAID,GAAG,CAAC,CAAC;IACjC;IACA,IAAI,CAAChB,UAAU,GAAG,CAAC,CAAC,EAAE7C,OAAO,CAACiO,WAAW,EAAEnM,KAAK,CAAC;IACjD;IACA,IAAI,CAACa,qBAAqB,GAAG,EAAE;IAC/B,IAAI,CAACC,qBAAqB,GAAG,EAAE;IAC/B;IACA;IACA,IAAIsL,UAAU,GAAG,IAAItO,QAAQ,CAAC0C,OAAO,CAAC,CAAC;IACvC,IAAI6L,gBAAgB,GAAG,CAAC,CAAC,EAAEnO,OAAO,CAACoO,gBAAgB,EAAEF,UAAU,CAACG,QAAQ,CAAC,CAAC,EAAE,IAAI,CAACV,aAAa,CAAC,CAAC,EAAE,IAAI,CAACW,kBAAkB,CAAC,CAAC,EAAE,IAAI,CAACC,UAAU,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;IAClK;IACA,IAAI,CAAClL,qBAAqB,GAAG,CAAC,CAAC,EAAErD,OAAO,CAACsD,2BAA2B,EAAE,IAAI,CAACF,UAAU,IAAI,IAAI,CAACP,UAAU,CAAC;IACzG,IAAI2L,gBAAgB,GAAG,CAAC,CAAC;IACzB,IAAIhJ,KAAK,GAAG1D,KAAK,CAAC0D,KAAK,CAAC,CAAC;IACzB,KAAK,IAAIhH,CAAC,GAAG,CAAC,EAAEiK,CAAC,GAAGjD,KAAK,CAAC7G,MAAM,EAAEH,CAAC,GAAGiK,CAAC,EAAEjK,CAAC,EAAE,EAAE;MAC1C,IAAIkK,IAAI,GAAGlD,KAAK,CAAChH,CAAC,CAAC;MACnB;MACA;MACA;MACA;MACA;MACA;MACA;MACA,IAAIiQ,IAAI,GAAGlR,MAAM,CAACc,MAAM,CAAC,CAAC,CAAC,EAAEyD,KAAK,CAAC4M,iBAAiB,CAAChG,IAAI,CAAC,CAAC;MAC3D,IAAIjI,QAAQ,CAACkO,WAAW,EACpBF,IAAI,GAAGhO,QAAQ,CAACkO,WAAW,CAACjG,IAAI,EAAE+F,IAAI,CAAC;MAC3C,IAAI9N,IAAI,GAAGH,iBAAiB,CAAC,IAAI,CAACC,QAAQ,EAAEiI,IAAI,EAAE+F,IAAI,CAAC;MACvDD,gBAAgB,CAAC7N,IAAI,CAACW,IAAI,CAAC,GAAG,CAACkN,gBAAgB,CAAC7N,IAAI,CAACW,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC;MACpE,IAAI,CAACmB,aAAa,CAACiG,IAAI,CAAC,GAAG/H,IAAI;MAC/B,IAAI,CAAC0C,qBAAqB,CAACuL,OAAO,CAACjO,IAAI,CAAC;MACxC,IAAIA,IAAI,CAACU,UAAU,EACf,IAAI,CAACsB,qBAAqB,CAACkM,IAAI,CAACnG,IAAI,CAAC;MACzC,IAAI,IAAI,CAACjI,QAAQ,CAACe,MAAM,EAAE;QACtB,IAAIb,IAAI,CAACa,MAAM,GAAGoM,WAAW,CAAC,CAAC,CAAC,EAC5BA,WAAW,CAAC,CAAC,CAAC,GAAGjN,IAAI,CAACa,MAAM;QAChC,IAAIb,IAAI,CAACa,MAAM,GAAGoM,WAAW,CAAC,CAAC,CAAC,EAC5BA,WAAW,CAAC,CAAC,CAAC,GAAGjN,IAAI,CAACa,MAAM;MACpC;IACJ;IACA,KAAK,IAAIF,IAAI,IAAI,IAAI,CAACgD,YAAY,EAAE;MAChC,IAAI,CAAC,IAAI,CAACA,YAAY,CAACzG,cAAc,CAACyD,IAAI,CAAC,EAAE;QACzC,MAAM,IAAIV,KAAK,CAAC,2DAA2D,CAACC,MAAM,CAACS,IAAI,EAAE,KAAK,CAAC,CAAC;MACpG;MACA,IAAI,CAACmM,UAAU,EACX,IAAI,CAACnJ,YAAY,CAAChD,IAAI,CAAC,CAACwN,QAAQ,CAACN,gBAAgB,CAAClN,IAAI,CAAC,IAAI,CAAC,CAAC;MACjE;MACAkN,gBAAgB,CAAClN,IAAI,CAAC,GAAG,CAAC;IAC9B;IACA;IACA;IACA,IAAI,IAAI,CAACb,QAAQ,CAACe,MAAM,IAAIoM,WAAW,CAAC,CAAC,CAAC,KAAKA,WAAW,CAAC,CAAC,CAAC,EACzDpI,KAAK,GAAG,CAAC,CAAC,EAAExF,OAAO,CAAC+O,cAAc,EAAEnB,WAAW,EAAE,UAAUlF,IAAI,EAAE;MAAE,OAAO1G,KAAK,CAACS,aAAa,CAACiG,IAAI,CAAC,CAAClH,MAAM;IAAE,CAAC,EAAEgE,KAAK,CAAC;IACzH,KAAK,IAAIhH,CAAC,GAAG,CAAC,EAAEiK,CAAC,GAAGjD,KAAK,CAAC7G,MAAM,EAAEH,CAAC,GAAGiK,CAAC,EAAEjK,CAAC,EAAE,EAAE;MAC1C,IAAIkK,IAAI,GAAGlD,KAAK,CAAChH,CAAC,CAAC;MACnB,IAAImC,IAAI,GAAG,IAAI,CAAC8B,aAAa,CAACiG,IAAI,CAAC;MACnC,IAAI,CAACrG,QAAQ,CAAC2M,GAAG,CAACtG,IAAI,EAAE/H,IAAI,CAACmC,CAAC,EAAE,CAAC,GAAGnC,IAAI,CAACoC,CAAC,EAAEpC,IAAI,CAACO,IAAI,GAAG,IAAI,CAACsC,KAAK,CAAC;MACnE,IAAI,OAAO7C,IAAI,CAACK,KAAK,KAAK,QAAQ,IAAI,CAACL,IAAI,CAACQ,MAAM,EAC9C,IAAI,CAACoB,SAAS,CAACyM,GAAG,CAACtG,IAAI,EAAE/H,IAAI,CAACO,IAAI,EAAE,IAAI,CAAC0H,qBAAqB,CAACjI,IAAI,EAAE;QAAEqC,MAAM,EAAEmL;MAAiB,CAAC,CAAC,CAAC;MACvG,IAAIc,WAAW,GAAG,IAAI,CAAC3K,YAAY,CAAC3D,IAAI,CAACW,IAAI,CAAC;MAC9C,IAAI,CAAC2N,WAAW,EACZ,MAAM,IAAIrO,KAAK,CAAC,2DAA2D,CAACC,MAAM,CAACF,IAAI,CAACW,IAAI,EAAE,KAAK,CAAC,CAAC;MACzG2N,WAAW,CAACzI,OAAO,CAAC7F,IAAI,EAAEA,IAAI,CAACQ,MAAM,EAAEqN,gBAAgB,CAAC7N,IAAI,CAACW,IAAI,CAAC,EAAE,CAAC;MACrE;MACA,IAAIX,IAAI,CAACS,WAAW,IAAI,CAACT,IAAI,CAACQ,MAAM,EAChC,IAAI,CAAC2C,gBAAgB,CAACkL,GAAG,CAACtG,IAAI,CAAC;IACvC;IACA,IAAI,CAACnG,SAAS,CAAC2M,QAAQ,CAAC,CAAC;IACzB,IAAIC,gBAAgB,GAAG,CAAC,CAAC;IACzB,IAAIrJ,KAAK,GAAGhE,KAAK,CAACgE,KAAK,CAAC,CAAC;IACzB,KAAK,IAAItH,CAAC,GAAG,CAAC,EAAEiK,CAAC,GAAG3C,KAAK,CAACnH,MAAM,EAAEH,CAAC,GAAGiK,CAAC,EAAEjK,CAAC,EAAE,EAAE;MAC1C,IAAI4L,IAAI,GAAGtE,KAAK,CAACtH,CAAC,CAAC;MACnB;MACA;MACA;MACA;MACA;MACA;MACA,IAAIiQ,IAAI,GAAGlR,MAAM,CAACc,MAAM,CAAC,CAAC,CAAC,EAAEyD,KAAK,CAACsN,iBAAiB,CAAChF,IAAI,CAAC,CAAC;MAC3D,IAAI3J,QAAQ,CAAC4O,WAAW,EACpBZ,IAAI,GAAGhO,QAAQ,CAAC4O,WAAW,CAACjF,IAAI,EAAEqE,IAAI,CAAC;MAC3C,IAAI9N,IAAI,GAAGc,iBAAiB,CAAC,IAAI,CAAChB,QAAQ,EAAE2J,IAAI,EAAEqE,IAAI,CAAC;MACvDU,gBAAgB,CAACxO,IAAI,CAACW,IAAI,CAAC,GAAG,CAAC6N,gBAAgB,CAACxO,IAAI,CAACW,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC;MACpE,IAAI,CAACoB,aAAa,CAAC0H,IAAI,CAAC,GAAGzJ,IAAI;MAC/B,IAAIA,IAAI,CAACU,UAAU,IAAI,CAACV,IAAI,CAACQ,MAAM,EAC/B,IAAI,CAACyB,qBAAqB,CAACiM,IAAI,CAACzE,IAAI,CAAC;MACzC,IAAI,IAAI,CAAC3J,QAAQ,CAACe,MAAM,EAAE;QACtB,IAAIb,IAAI,CAACa,MAAM,GAAGqM,WAAW,CAAC,CAAC,CAAC,EAC5BA,WAAW,CAAC,CAAC,CAAC,GAAGlN,IAAI,CAACa,MAAM;QAChC,IAAIb,IAAI,CAACa,MAAM,GAAGqM,WAAW,CAAC,CAAC,CAAC,EAC5BA,WAAW,CAAC,CAAC,CAAC,GAAGlN,IAAI,CAACa,MAAM;MACpC;IACJ;IACA,KAAK,IAAIF,IAAI,IAAI,IAAI,CAACkD,YAAY,EAAE;MAChC,IAAI,CAAC,IAAI,CAACA,YAAY,CAAC3G,cAAc,CAACyD,IAAI,CAAC,EAAE;QACzC,MAAM,IAAIV,KAAK,CAAC,2DAA2D,CAACC,MAAM,CAACS,IAAI,EAAE,KAAK,CAAC,CAAC;MACpG;MACA,IAAI,CAACmM,UAAU,EACX,IAAI,CAACjJ,YAAY,CAAClD,IAAI,CAAC,CAACwN,QAAQ,CAACK,gBAAgB,CAAC7N,IAAI,CAAC,IAAI,CAAC,CAAC;MACjE;MACA6N,gBAAgB,CAAC7N,IAAI,CAAC,GAAG,CAAC;IAC9B;IACA;IACA,IAAI,IAAI,CAACb,QAAQ,CAACe,MAAM,IAAIqM,WAAW,CAAC,CAAC,CAAC,KAAKA,WAAW,CAAC,CAAC,CAAC,EACzD/H,KAAK,GAAG,CAAC,CAAC,EAAE9F,OAAO,CAAC+O,cAAc,EAAElB,WAAW,EAAE,UAAUzD,IAAI,EAAE;MAAE,OAAOpI,KAAK,CAACU,aAAa,CAAC0H,IAAI,CAAC,CAAC5I,MAAM;IAAE,CAAC,EAAEsE,KAAK,CAAC;IACzH,KAAK,IAAItH,CAAC,GAAG,CAAC,EAAEiK,CAAC,GAAG3C,KAAK,CAACnH,MAAM,EAAEH,CAAC,GAAGiK,CAAC,EAAEjK,CAAC,EAAE,EAAE;MAC1C,IAAI4L,IAAI,GAAGtE,KAAK,CAACtH,CAAC,CAAC;MACnB,IAAImC,IAAI,GAAG,IAAI,CAAC+B,aAAa,CAAC0H,IAAI,CAAC;MACnC,IAAIkF,WAAW,GAAGxN,KAAK,CAACwN,WAAW,CAAClF,IAAI,CAAC;QAAEmF,UAAU,GAAG,IAAI,CAAC9M,aAAa,CAAC6M,WAAW,CAAC,CAAC,CAAC,CAAC;QAAEE,UAAU,GAAG,IAAI,CAAC/M,aAAa,CAAC6M,WAAW,CAAC,CAAC,CAAC,CAAC;MAC3I,IAAInO,MAAM,GAAGR,IAAI,CAACQ,MAAM,IAAIoO,UAAU,CAACpO,MAAM,IAAIqO,UAAU,CAACrO,MAAM;MAClE,IAAI,CAACqD,YAAY,CAAC7D,IAAI,CAACW,IAAI,CAAC,CAACkF,OAAO,CAAC+I,UAAU,EAAEC,UAAU,EAAE7O,IAAI,EAAEQ,MAAM,EAAEgO,gBAAgB,CAACxO,IAAI,CAACW,IAAI,CAAC,EAAE,CAAC;IAC7G;IACA,KAAK,IAAIA,IAAI,IAAI,IAAI,CAACkD,YAAY,EAAE;MAChC,IAAIiL,OAAO,GAAG,IAAI,CAACjL,YAAY,CAAClD,IAAI,CAAC;MACrC,IAAI,CAACmM,UAAU,IAAI,OAAOgC,OAAO,CAACC,cAAc,KAAK,UAAU,EAC3DD,OAAO,CAACC,cAAc,CAAC,CAAC;IAChC;IACA,OAAO,IAAI;EACf,CAAC;EACD;AACJ;AACA;AACA;EACI9N,KAAK,CAAChE,SAAS,CAAC2I,oBAAoB,GAAG,YAAY;IAC/C,IAAI,CAACP,MAAM,CAAC2J,QAAQ,GAAG,IAAI,CAAClP,QAAQ,CAACmP,cAAc;IACnD,IAAI,CAAC5J,MAAM,CAAC6J,QAAQ,GAAG,IAAI,CAACpP,QAAQ,CAACqP,cAAc;IACnD,IAAI,CAAC9J,MAAM,CAAC+J,QAAQ,CAAC,IAAI,CAAC/J,MAAM,CAACgK,aAAa,CAAC,IAAI,CAAChK,MAAM,CAACqI,QAAQ,CAAC,CAAC,CAAC,CAAC;IACvE,OAAO,IAAI;EACf,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;EACIzM,KAAK,CAAChE,SAAS,CAACqS,QAAQ,GAAG,YAAY;IACnC;IACA,IAAI,IAAI,CAAC9L,aAAa,EAAE;MACpB,IAAI,CAACqC,OAAO,CAAC,CAAC;IAClB,CAAC,MACI,IAAI,IAAI,CAACpC,iBAAiB,EAAE;MAC7B,IAAI,CAACoC,OAAO,CAAC,IAAI,CAAC;IACtB;IACA;IACA,IAAI,CAACrC,aAAa,GAAG,KAAK;IAC1B,IAAI,CAACC,iBAAiB,GAAG,KAAK;IAC9B;IACA,IAAI,CAACqC,MAAM,CAAC,CAAC;IACb,OAAO,IAAI;EACf,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;EACI7E,KAAK,CAAChE,SAAS,CAAC0J,gBAAgB,GAAG,YAAY;IAC3C,IAAItF,KAAK,GAAG,IAAI;IAChB,IAAI,CAAC,IAAI,CAACiC,WAAW,EAAE;MACnB,IAAI,CAACA,WAAW,GAAG,CAAC,CAAC,EAAEjE,OAAO,CAAC6J,YAAY,EAAE,YAAY;QACrD7H,KAAK,CAACiO,QAAQ,CAAC,CAAC;QAChBjO,KAAK,CAACiC,WAAW,GAAG,IAAI;MAC5B,CAAC,CAAC;IACN;IACA,OAAO,IAAI;EACf,CAAC;EACD;AACJ;AACA;AACA;AACA;EACIrC,KAAK,CAAChE,SAAS,CAACsS,YAAY,GAAG,YAAY;IACvC,IAAI,CAAC,IAAI,CAACzP,QAAQ,CAACyP,YAAY,EAC3B,OAAO,IAAI;IACf,IAAIC,WAAW,GAAG,IAAI,CAACnK,MAAM,CAACqI,QAAQ,CAAC,CAAC;IACxC;IACA,IAAI+B,eAAe,GAAG,IAAI,CAAC7N,SAAS,CAAC8N,kBAAkB,CAACF,WAAW,CAACG,KAAK,EAAE,IAAI,CAAC7P,QAAQ,CAAC8P,YAAY,CAAC;IACtG,CAAC,CAAC,EAAE7Q,QAAQ,CAAC4C,OAAO,EAAE8N,eAAe,EAAE,IAAI,CAACzN,qBAAqB,CAAC;IAClE,IAAI,CAACiB,eAAe,GAAG,IAAIC,GAAG,CAAC,CAAC;IAChC;IACA,IAAIwD,OAAO,GAAG,IAAI,CAACnF,cAAc,CAACsO,MAAM;IACxC,KAAK,IAAIhS,CAAC,GAAG,CAAC,EAAEiK,CAAC,GAAG2H,eAAe,CAACzR,MAAM,EAAEH,CAAC,GAAGiK,CAAC,EAAEjK,CAAC,EAAE,EAAE;MACpD,IAAIkK,IAAI,GAAG0H,eAAe,CAAC5R,CAAC,CAAC;MAC7B,IAAImC,IAAI,GAAG,IAAI,CAAC8B,aAAa,CAACiG,IAAI,CAAC;MACnC;MACA;MACA;MACA,IAAI,IAAI,CAAC9E,eAAe,CAAC6M,GAAG,CAAC/H,IAAI,CAAC,EAC9B;MACJ;MACA,IAAI/H,IAAI,CAACQ,MAAM,EACX;MACJ,IAAIsG,EAAE,GAAG,IAAI,CAACmB,qBAAqB,CAACjI,IAAI,CAAC;QAAEmC,CAAC,GAAG2E,EAAE,CAAC3E,CAAC;QAAEC,CAAC,GAAG0E,EAAE,CAAC1E,CAAC;MAC7D;MACA,IAAI7B,IAAI,GAAG,IAAI,CAAC2H,SAAS,CAAClI,IAAI,CAACO,IAAI,CAAC;MACpC;MACA,IAAI,CAACP,IAAI,CAACU,UAAU,IAAIH,IAAI,GAAG,IAAI,CAACT,QAAQ,CAACiQ,0BAA0B,EACnE;MACJ;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA,IAAI5N,CAAC,GAAG,CAACxC,cAAc,IACnBwC,CAAC,GAAG,IAAI,CAACU,KAAK,GAAGlD,cAAc,IAC/ByC,CAAC,GAAG,CAACxC,cAAc,IACnBwC,CAAC,GAAG,IAAI,CAACU,MAAM,GAAGlD,cAAc,EAChC;MACJ;MACA;MACA;MACA;MACA;MACA,IAAI,CAACqD,eAAe,CAACoL,GAAG,CAACtG,IAAI,CAAC;MAC9B,IAAI,CAACjI,QAAQ,CAACkQ,aAAa,CAACtJ,OAAO,EAAEjJ,QAAQ,CAACA,QAAQ,CAAC;QAAEsC,GAAG,EAAEgI;MAAK,CAAC,EAAE/H,IAAI,CAAC,EAAE;QAAEO,IAAI,EAAEA,IAAI;QAAE4B,CAAC,EAAEA,CAAC;QAAEC,CAAC,EAAEA;MAAE,CAAC,CAAC,EAAE,IAAI,CAACtC,QAAQ,CAAC;IAC5H;IACA,OAAO,IAAI;EACf,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;EACImB,KAAK,CAAChE,SAAS,CAACgT,gBAAgB,GAAG,YAAY;IAC3C,IAAI,CAAC,IAAI,CAACnQ,QAAQ,CAACmQ,gBAAgB,EAC/B,OAAO,IAAI;IACf,IAAIvJ,OAAO,GAAG,IAAI,CAACnF,cAAc,CAAC2O,UAAU;IAC5C;IACAxJ,OAAO,CAACyJ,SAAS,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI,CAACtN,KAAK,EAAE,IAAI,CAACC,MAAM,CAAC;IAChD,IAAIsN,mBAAmB,GAAG,CAAC,CAAC,EAAE9Q,QAAQ,CAAC+Q,4BAA4B,EAAE;MACjElP,KAAK,EAAE,IAAI,CAACA,KAAK;MACjBiC,WAAW,EAAE,IAAI,CAACA,WAAW;MAC7BkN,mBAAmB,EAAE,IAAI,CAACrN,eAAe;MACzCE,gBAAgB,EAAE,IAAI,CAACA;IAC3B,CAAC,CAAC,CAACjD,MAAM,CAAC,IAAI,CAAC+B,qBAAqB,CAAC;IACrC,IAAIgB,eAAe,GAAG,IAAIC,GAAG,CAAC,CAAC;IAC/B,KAAK,IAAIrF,CAAC,GAAG,CAAC,EAAEiK,CAAC,GAAGsI,mBAAmB,CAACpS,MAAM,EAAEH,CAAC,GAAGiK,CAAC,EAAEjK,CAAC,EAAE,EAAE;MACxD,IAAI4L,IAAI,GAAG2G,mBAAmB,CAACvS,CAAC,CAAC;QAAE8Q,WAAW,GAAG,IAAI,CAACxN,KAAK,CAACwN,WAAW,CAAClF,IAAI,CAAC;QAAEmF,UAAU,GAAG,IAAI,CAAC9M,aAAa,CAAC6M,WAAW,CAAC,CAAC,CAAC,CAAC;QAAEE,UAAU,GAAG,IAAI,CAAC/M,aAAa,CAAC6M,WAAW,CAAC,CAAC,CAAC,CAAC;QAAE4B,QAAQ,GAAG,IAAI,CAACxO,aAAa,CAAC0H,IAAI,CAAC;MACpN;MACA;MACA,IAAIxG,eAAe,CAAC6M,GAAG,CAACrG,IAAI,CAAC,EACzB;MACJ;MACA;MACA,IAAI8G,QAAQ,CAAC/P,MAAM,IAAIoO,UAAU,CAACpO,MAAM,IAAIqO,UAAU,CAACrO,MAAM,EAAE;QAC3D;MACJ;MACA,IAAI,CAACV,QAAQ,CAAC0Q,iBAAiB,CAAC9J,OAAO,EAAEjJ,QAAQ,CAACA,QAAQ,CAAC;QAAEsC,GAAG,EAAE0J;MAAK,CAAC,EAAE8G,QAAQ,CAAC,EAAE;QAAEhQ,IAAI,EAAE,IAAI,CAAC2H,SAAS,CAACqI,QAAQ,CAAChQ,IAAI;MAAE,CAAC,CAAC,EAAE9C,QAAQ,CAACA,QAAQ,CAACA,QAAQ,CAAC;QAAEsC,GAAG,EAAE4O,WAAW,CAAC,CAAC;MAAE,CAAC,EAAEC,UAAU,CAAC,EAAE,IAAI,CAAC3G,qBAAqB,CAAC2G,UAAU,CAAC,CAAC,EAAE;QAAErO,IAAI,EAAE,IAAI,CAAC2H,SAAS,CAAC0G,UAAU,CAACrO,IAAI;MAAE,CAAC,CAAC,EAAE9C,QAAQ,CAACA,QAAQ,CAACA,QAAQ,CAAC;QAAEsC,GAAG,EAAE4O,WAAW,CAAC,CAAC;MAAE,CAAC,EAAEE,UAAU,CAAC,EAAE,IAAI,CAAC5G,qBAAqB,CAAC4G,UAAU,CAAC,CAAC,EAAE;QAAEtO,IAAI,EAAE,IAAI,CAAC2H,SAAS,CAAC2G,UAAU,CAACtO,IAAI;MAAE,CAAC,CAAC,EAAE,IAAI,CAACT,QAAQ,CAAC;MACzbmD,eAAe,CAACoL,GAAG,CAAC5E,IAAI,CAAC;IAC7B;IACA,OAAO,IAAI;EACf,CAAC;EACD;AACJ;AACA;AACA;AACA;EACIxI,KAAK,CAAChE,SAAS,CAACwT,sBAAsB,GAAG,YAAY;IACjD,IAAIpP,KAAK,GAAG,IAAI;IAChB,IAAIqF,OAAO,GAAG,IAAI,CAACnF,cAAc,CAACmP,MAAM;IACxC;IACAhK,OAAO,CAACyJ,SAAS,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI,CAACtN,KAAK,EAAE,IAAI,CAACC,MAAM,CAAC;IAChD;IACA,IAAIgD,MAAM,GAAG,SAAAA,CAAUiC,IAAI,EAAE;MACzB,IAAI/H,IAAI,GAAGqB,KAAK,CAACS,aAAa,CAACiG,IAAI,CAAC;MACpC,IAAIjB,EAAE,GAAGzF,KAAK,CAAC4G,qBAAqB,CAACjI,IAAI,CAAC;QAAEmC,CAAC,GAAG2E,EAAE,CAAC3E,CAAC;QAAEC,CAAC,GAAG0E,EAAE,CAAC1E,CAAC;MAC9D,IAAI7B,IAAI,GAAGc,KAAK,CAAC6G,SAAS,CAAClI,IAAI,CAACO,IAAI,CAAC;MACrCc,KAAK,CAACvB,QAAQ,CAAC6Q,aAAa,CAACjK,OAAO,EAAEjJ,QAAQ,CAACA,QAAQ,CAAC;QAAEsC,GAAG,EAAEgI;MAAK,CAAC,EAAE/H,IAAI,CAAC,EAAE;QAAEO,IAAI,EAAEA,IAAI;QAAE4B,CAAC,EAAEA,CAAC;QAAEC,CAAC,EAAEA;MAAE,CAAC,CAAC,EAAEf,KAAK,CAACvB,QAAQ,CAAC;IAC9H,CAAC;IACD,IAAI8Q,aAAa,GAAG,EAAE;IACtB,IAAI,IAAI,CAACxN,WAAW,IAAI,CAAC,IAAI,CAACtB,aAAa,CAAC,IAAI,CAACsB,WAAW,CAAC,CAAC5C,MAAM,EAAE;MAClEoQ,aAAa,CAAC1C,IAAI,CAAC,IAAI,CAAC9K,WAAW,CAAC;IACxC;IACA,IAAI,CAACD,gBAAgB,CAAC0N,OAAO,CAAC,UAAU9I,IAAI,EAAE;MAC1C;MACA,IAAIA,IAAI,KAAK1G,KAAK,CAAC+B,WAAW,EAC1BwN,aAAa,CAAC1C,IAAI,CAACnG,IAAI,CAAC;IAChC,CAAC,CAAC;IACF;IACA6I,aAAa,CAACC,OAAO,CAAC,UAAU9I,IAAI,EAAE;MAAE,OAAOjC,MAAM,CAACiC,IAAI,CAAC;IAAE,CAAC,CAAC;IAC/D;IACA,IAAI8F,gBAAgB,GAAG,CAAC,CAAC;IACzB;IACA+C,aAAa,CAACC,OAAO,CAAC,UAAU9I,IAAI,EAAE;MAClC,IAAIpH,IAAI,GAAGU,KAAK,CAACS,aAAa,CAACiG,IAAI,CAAC,CAACpH,IAAI;MACzCkN,gBAAgB,CAAClN,IAAI,CAAC,GAAG,CAACkN,gBAAgB,CAAClN,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC;IAC9D,CAAC,CAAC;IACF;IACA,KAAK,IAAIA,IAAI,IAAI,IAAI,CAACiD,iBAAiB,EAAE;MACrC,IAAI,CAACA,iBAAiB,CAACjD,IAAI,CAAC,CAACwN,QAAQ,CAACN,gBAAgB,CAAClN,IAAI,CAAC,IAAI,CAAC,CAAC;MAClE;MACAkN,gBAAgB,CAAClN,IAAI,CAAC,GAAG,CAAC;IAC9B;IACA;IACAiQ,aAAa,CAACC,OAAO,CAAC,UAAU9I,IAAI,EAAE;MAClC,IAAI/H,IAAI,GAAGqB,KAAK,CAACS,aAAa,CAACiG,IAAI,CAAC;MACpC1G,KAAK,CAACuC,iBAAiB,CAAC5D,IAAI,CAACW,IAAI,CAAC,CAACkF,OAAO,CAAC7F,IAAI,EAAEA,IAAI,CAACQ,MAAM,EAAEqN,gBAAgB,CAAC7N,IAAI,CAACW,IAAI,CAAC,EAAE,CAAC;IAChG,CAAC,CAAC;IACF;IACA,IAAI,CAACa,aAAa,CAACwD,UAAU,CAACmI,KAAK,CAAC,IAAI,CAAC3L,aAAa,CAACwD,UAAU,CAAC8L,gBAAgB,CAAC;IACnF;IACA,KAAK,IAAInQ,IAAI,IAAI,IAAI,CAACiD,iBAAiB,EAAE;MACrC,IAAIkL,OAAO,GAAG,IAAI,CAAClL,iBAAiB,CAACjD,IAAI,CAAC;MAC1CmO,OAAO,CAACiC,IAAI,CAAC,CAAC;MACdjC,OAAO,CAACkC,UAAU,CAAC,CAAC;MACpBlC,OAAO,CAAChJ,MAAM,CAAC;QACXzD,MAAM,EAAE,IAAI,CAACA,MAAM;QACnBQ,KAAK,EAAE,IAAI,CAACA,KAAK;QACjBC,MAAM,EAAE,IAAI,CAACA,MAAM;QACnB6M,KAAK,EAAE,IAAI,CAACtK,MAAM,CAACsK,KAAK;QACxBnN,eAAe,EAAE,IAAI,CAACA,eAAe,GAAG,IAAI,CAAC6C,MAAM,CAACsK,KAAK;QACzDsB,YAAY,EAAE,IAAI,CAAClO;MACvB,CAAC,CAAC;IACN;EACJ,CAAC;EACD;AACJ;AACA;AACA;EACI9B,KAAK,CAAChE,SAAS,CAAC6L,8BAA8B,GAAG,YAAY;IACzD,IAAIzH,KAAK,GAAG,IAAI;IAChB,IAAI,IAAI,CAACkC,2BAA2B,IAAI,IAAI,CAACD,WAAW,EACpD;IACJ,IAAI,CAACC,2BAA2B,GAAG,CAAC,CAAC,EAAElE,OAAO,CAAC6J,YAAY,EAAE,YAAY;MACrE;MACA7H,KAAK,CAACkC,2BAA2B,GAAG,IAAI;MACxC;MACAlC,KAAK,CAACoP,sBAAsB,CAAC,CAAC;MAC9BpP,KAAK,CAAC4O,gBAAgB,CAAC,CAAC;IAC5B,CAAC,CAAC;EACN,CAAC;EACD;AACJ;AACA;AACA;AACA;EACIhP,KAAK,CAAChE,SAAS,CAAC6I,MAAM,GAAG,YAAY;IACjC,IAAIzE,KAAK,GAAG,IAAI;IAChB,IAAI,CAACwH,IAAI,CAAC,cAAc,CAAC;IACzB,IAAIqI,UAAU,GAAG,SAAAA,CAAA,EAAY;MACzB7P,KAAK,CAACwH,IAAI,CAAC,aAAa,CAAC;MACzB,OAAOxH,KAAK;IAChB,CAAC;IACD;IACA,IAAI,IAAI,CAACiC,WAAW,EAAE;MAClB,CAAC,CAAC,EAAEjE,OAAO,CAAC8R,WAAW,EAAE,IAAI,CAAC7N,WAAW,CAAC;MAC1C,IAAI,CAACA,WAAW,GAAG,IAAI;MACvB,IAAI,CAACE,aAAa,GAAG,KAAK;MAC1B,IAAI,CAACC,iBAAiB,GAAG,KAAK;IAClC;IACA;IACA,IAAI,CAAC2B,MAAM,CAAC,CAAC;IACb;IACA,IAAI,CAAC+H,KAAK,CAAC,CAAC;IACZ;IACA,IAAI,CAACiE,kBAAkB,CAAC,CAAC;IACzB;IACA,IAAI,CAAC,IAAI,CAACjQ,KAAK,CAACkQ,KAAK,EACjB,OAAOH,UAAU,CAAC,CAAC;IACvB;IACA;IACA,IAAI3L,WAAW,GAAG,IAAI,CAACA,WAAW;IAClC,IAAI+L,MAAM,GAAG,IAAI,CAACjM,MAAM,CAACkM,UAAU,CAAC,CAAC,IACjChM,WAAW,CAACiM,QAAQ,IACpBjM,WAAW,CAACkM,aAAa,IACzBlM,WAAW,CAACmM,qBAAqB;IACrC;IACA,IAAIlC,WAAW,GAAG,IAAI,CAACnK,MAAM,CAACqI,QAAQ,CAAC,CAAC;IACxC,IAAIiE,kBAAkB,GAAG,IAAI,CAAC3E,aAAa,CAAC,CAAC;IAC7C,IAAI4E,eAAe,GAAG,IAAI,CAACjE,kBAAkB,CAAC,CAAC;IAC/C,IAAIkE,OAAO,GAAG,IAAI,CAACjE,UAAU,CAAC,cAAc,CAAC,IAAI,CAAC;IAClD,IAAI,CAACvL,MAAM,GAAG,CAAC,CAAC,EAAEhD,OAAO,CAACoO,gBAAgB,EAAE+B,WAAW,EAAEmC,kBAAkB,EAAEC,eAAe,EAAEC,OAAO,CAAC;IACtG,IAAI,CAACtP,SAAS,GAAG,CAAC,CAAC,EAAElD,OAAO,CAACoO,gBAAgB,EAAE+B,WAAW,EAAEmC,kBAAkB,EAAEC,eAAe,EAAEC,OAAO,EAAE,IAAI,CAAC;IAC/G,IAAI,CAACrP,eAAe,GAAG,CAAC,CAAC,EAAEnD,OAAO,CAACyS,eAAe,EAAE,IAAI,CAACzP,MAAM,EAAEmN,WAAW,EAAEmC,kBAAkB,CAAC;IACjG;IACA,KAAK,IAAIhR,IAAI,IAAI,IAAI,CAACgD,YAAY,EAAE;MAChC,IAAImL,OAAO,GAAG,IAAI,CAACnL,YAAY,CAAChD,IAAI,CAAC;MACrCmO,OAAO,CAACiC,IAAI,CAAC,CAAC;MACdjC,OAAO,CAACkC,UAAU,CAAC,CAAC;MACpBlC,OAAO,CAAChJ,MAAM,CAAC;QACXzD,MAAM,EAAE,IAAI,CAACA,MAAM;QACnBQ,KAAK,EAAE,IAAI,CAACA,KAAK;QACjBC,MAAM,EAAE,IAAI,CAACA,MAAM;QACnB6M,KAAK,EAAEH,WAAW,CAACG,KAAK;QACxBnN,eAAe,EAAE,IAAI,CAACA,eAAe,GAAGgN,WAAW,CAACG,KAAK;QACzDsB,YAAY,EAAE,IAAI,CAAClO;MACvB,CAAC,CAAC;IACN;IACA;IACA,IAAI,CAAC,IAAI,CAACjD,QAAQ,CAACiS,eAAe,IAAI,CAACT,MAAM,EAAE;MAC3C,KAAK,IAAI3Q,IAAI,IAAI,IAAI,CAACkD,YAAY,EAAE;QAChC,IAAIiL,OAAO,GAAG,IAAI,CAACjL,YAAY,CAAClD,IAAI,CAAC;QACrCmO,OAAO,CAACiC,IAAI,CAAC,CAAC;QACdjC,OAAO,CAACkC,UAAU,CAAC,CAAC;QACpBlC,OAAO,CAAChJ,MAAM,CAAC;UACXzD,MAAM,EAAE,IAAI,CAACA,MAAM;UACnBQ,KAAK,EAAE,IAAI,CAACA,KAAK;UACjBC,MAAM,EAAE,IAAI,CAACA,MAAM;UACnB6M,KAAK,EAAEH,WAAW,CAACG,KAAK;UACxBnN,eAAe,EAAE,IAAI,CAACA,eAAe,GAAGgN,WAAW,CAACG,KAAK;UACzDsB,YAAY,EAAE,IAAI,CAAClO;QACvB,CAAC,CAAC;MACN;IACJ;IACA;IACA,IAAI,IAAI,CAACjD,QAAQ,CAACkS,gBAAgB,IAAIV,MAAM,EACxC,OAAOJ,UAAU,CAAC,CAAC;IACvB,IAAI,CAAC3B,YAAY,CAAC,CAAC;IACnB,IAAI,CAACU,gBAAgB,CAAC,CAAC;IACvB,IAAI,CAACQ,sBAAsB,CAAC,CAAC;IAC7B,OAAOS,UAAU,CAAC,CAAC;EACvB,CAAC;EACD;AACJ;AACA;AACA;EACIjQ,KAAK,CAAChE,SAAS,CAACmU,kBAAkB,GAAG,YAAY;IAC7C,IAAIzB,KAAK,GAAG,IAAI,CAACtK,MAAM,CAACqI,QAAQ,CAAC,CAAC,CAACiC,KAAK;IACxC,IAAI,CAAC/M,eAAe,GAAGsE,IAAI,CAACC,IAAI,CAACwI,KAAK,CAAC;EAC3C,CAAC;EACD;AACJ;AACA;AACA;EACI;AACJ;AACA;AACA;AACA;EACI1O,KAAK,CAAChE,SAAS,CAACgV,SAAS,GAAG,YAAY;IACpC,OAAO,IAAI,CAAC5M,MAAM;EACtB,CAAC;EACD;AACJ;AACA;AACA;AACA;EACIpE,KAAK,CAAChE,SAAS,CAACiV,YAAY,GAAG,YAAY;IACvC,OAAO,IAAI,CAAC9Q,SAAS;EACzB,CAAC;EACD;AACJ;AACA;AACA;AACA;EACIH,KAAK,CAAChE,SAAS,CAACkV,QAAQ,GAAG,YAAY;IACnC,OAAO,IAAI,CAAChR,KAAK;EACrB,CAAC;EACD;AACJ;AACA;AACA;AACA;EACIF,KAAK,CAAChE,SAAS,CAACmV,QAAQ,GAAG,UAAUjR,KAAK,EAAE;IACxC,IAAIA,KAAK,KAAK,IAAI,CAACA,KAAK,EACpB;IACJ;IACA,IAAI,CAACmJ,mBAAmB,CAAC,CAAC;IAC1B;IACA,IAAI,CAACxI,aAAa,GAAG,CAAC,CAAC;IACvB,IAAI,CAACC,aAAa,GAAG,CAAC,CAAC;IACvB;IACA,IAAI,CAACkB,eAAe,CAACkK,KAAK,CAAC,CAAC;IAC5B,IAAI,CAAChK,gBAAgB,CAACgK,KAAK,CAAC,CAAC;IAC7B,IAAI,CAAC/J,WAAW,GAAG,IAAI;IACvB,IAAI,CAACC,WAAW,GAAG,IAAI;IACvB,IAAI,CAACrB,qBAAqB,CAAChE,MAAM,GAAG,CAAC;IACrC,IAAI,CAACiE,qBAAqB,CAACjE,MAAM,GAAG,CAAC;IACrC,IAAI,IAAI,CAAC0F,qBAAqB,KAAK,IAAI,EAAE;MACrC,CAAC,CAAC,EAAErE,OAAO,CAAC8R,WAAW,EAAE,IAAI,CAACzN,qBAAqB,CAAC;MACpD,IAAI,CAACA,qBAAqB,GAAG,IAAI;IACrC;IACA;IACA,IAAI,CAACvC,KAAK,GAAGA,KAAK;IAClB;IACA,IAAI,CAACwE,iBAAiB,CAAC,CAAC;IACxB;IACA,IAAI,CAACE,OAAO,CAAC,CAAC;IACd,IAAI,CAACC,MAAM,CAAC,CAAC;EACjB,CAAC;EACD;AACJ;AACA;AACA;AACA;EACI7E,KAAK,CAAChE,SAAS,CAACoV,cAAc,GAAG,YAAY;IACzC,OAAO,IAAI,CAAC9M,WAAW;EAC3B,CAAC;EACD;AACJ;AACA;AACA;AACA;EACItE,KAAK,CAAChE,SAAS,CAACqV,cAAc,GAAG,YAAY;IACzC,OAAO,IAAI,CAAC7M,WAAW;EAC3B,CAAC;EACD;AACJ;AACA;AACA;AACA;EACIxE,KAAK,CAAChE,SAAS,CAAC+P,aAAa,GAAG,YAAY;IACxC,OAAO;MAAEnK,KAAK,EAAE,IAAI,CAACA,KAAK;MAAEC,MAAM,EAAE,IAAI,CAACA;IAAO,CAAC;EACrD,CAAC;EACD;AACJ;AACA;AACA;AACA;EACI7B,KAAK,CAAChE,SAAS,CAAC0Q,kBAAkB,GAAG,YAAY;IAC7C,IAAI4E,MAAM,GAAG,IAAI,CAAC9P,UAAU,IAAI,IAAI,CAACP,UAAU;IAC/C,OAAO;MACHW,KAAK,EAAE0P,MAAM,CAACpQ,CAAC,CAAC,CAAC,CAAC,GAAGoQ,MAAM,CAACpQ,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;MACrCW,MAAM,EAAEyP,MAAM,CAACnQ,CAAC,CAAC,CAAC,CAAC,GAAGmQ,MAAM,CAACnQ,CAAC,CAAC,CAAC,CAAC,IAAI;IACzC,CAAC;EACL,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACInB,KAAK,CAAChE,SAAS,CAACuV,kBAAkB,GAAG,UAAUzS,GAAG,EAAE;IAChD,IAAIgI,IAAI,GAAG,IAAI,CAACjG,aAAa,CAAC/B,GAAG,CAAC;IAClC,OAAOgI,IAAI,GAAGnL,MAAM,CAACc,MAAM,CAAC,CAAC,CAAC,EAAEqK,IAAI,CAAC,GAAGzH,SAAS;EACrD,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;EACIW,KAAK,CAAChE,SAAS,CAACwV,kBAAkB,GAAG,UAAU1S,GAAG,EAAE;IAChD,IAAI0J,IAAI,GAAG,IAAI,CAAC1H,aAAa,CAAChC,GAAG,CAAC;IAClC,OAAO0J,IAAI,GAAG7M,MAAM,CAACc,MAAM,CAAC,CAAC,CAAC,EAAE+L,IAAI,CAAC,GAAGnJ,SAAS;EACrD,CAAC;EACD;AACJ;AACA;AACA;AACA;EACIW,KAAK,CAAChE,SAAS,CAACyV,WAAW,GAAG,YAAY;IACtC,OAAOjV,QAAQ,CAAC,CAAC,CAAC,EAAE,IAAI,CAACqC,QAAQ,CAAC;EACtC,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;EACImB,KAAK,CAAChE,SAAS,CAAC2Q,UAAU,GAAG,UAAU7N,GAAG,EAAE;IACxC,OAAO,IAAI,CAACD,QAAQ,CAACC,GAAG,CAAC;EAC7B,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIkB,KAAK,CAAChE,SAAS,CAAC0V,UAAU,GAAG,UAAU5S,GAAG,EAAEvB,KAAK,EAAE;IAC/C,IAAI,CAACsB,QAAQ,CAACC,GAAG,CAAC,GAAGvB,KAAK;IAC1B,CAAC,CAAC,EAAEe,UAAU,CAACwE,gBAAgB,EAAE,IAAI,CAACjE,QAAQ,CAAC;IAC/C,IAAI,CAAC8F,oBAAoB,CAAC,CAAC;IAC3B,IAAI,CAACpC,aAAa,GAAG,IAAI,CAAC,CAAC;IAC3B,IAAI,CAACmD,gBAAgB,CAAC,CAAC;IACvB,OAAO,IAAI;EACf,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI1F,KAAK,CAAChE,SAAS,CAAC2V,aAAa,GAAG,UAAU7S,GAAG,EAAE8S,OAAO,EAAE;IACpD,IAAI,CAAC/S,QAAQ,CAACC,GAAG,CAAC,GAAG8S,OAAO,CAAC,IAAI,CAAC/S,QAAQ,CAACC,GAAG,CAAC,CAAC;IAChD,CAAC,CAAC,EAAER,UAAU,CAACwE,gBAAgB,EAAE,IAAI,CAACjE,QAAQ,CAAC;IAC/C,IAAI,CAAC8F,oBAAoB,CAAC,CAAC;IAC3B,IAAI,CAACpC,aAAa,GAAG,IAAI,CAAC,CAAC;IAC3B,IAAI,CAACmD,gBAAgB,CAAC,CAAC;IACvB,OAAO,IAAI;EACf,CAAC;EACD;AACJ;AACA;AACA;AACA;EACI1F,KAAK,CAAChE,SAAS,CAACmI,MAAM,GAAG,YAAY;IACjC,IAAI0N,aAAa,GAAG,IAAI,CAACjQ,KAAK;MAAEkQ,cAAc,GAAG,IAAI,CAACjQ,MAAM;IAC5D,IAAI,CAACD,KAAK,GAAG,IAAI,CAACzB,SAAS,CAAC4R,WAAW;IACvC,IAAI,CAAClQ,MAAM,GAAG,IAAI,CAAC1B,SAAS,CAAC6R,YAAY;IACzC,IAAI,CAAClQ,UAAU,GAAG,CAAC,CAAC,EAAE1D,OAAO,CAAC2D,aAAa,EAAE,CAAC;IAC9C,IAAI,IAAI,CAACH,KAAK,KAAK,CAAC,EAAE;MAClB,IAAI,IAAI,CAAC/C,QAAQ,CAACoT,qBAAqB,EACnC,IAAI,CAACrQ,KAAK,GAAG,CAAC,CAAC,KAEf,MAAM,IAAI5C,KAAK,CAAC,iHAAiH,CAAC;IAC1I;IACA,IAAI,IAAI,CAAC6C,MAAM,KAAK,CAAC,EAAE;MACnB,IAAI,IAAI,CAAChD,QAAQ,CAACoT,qBAAqB,EACnC,IAAI,CAACpQ,MAAM,GAAG,CAAC,CAAC,KAEhB,MAAM,IAAI7C,KAAK,CAAC,kHAAkH,CAAC;IAC3I;IACA;IACA,IAAI6S,aAAa,KAAK,IAAI,CAACjQ,KAAK,IAAIkQ,cAAc,KAAK,IAAI,CAACjQ,MAAM,EAC9D,OAAO,IAAI;IACf,IAAI,CAAC+F,IAAI,CAAC,QAAQ,CAAC;IACnB;IACA,KAAK,IAAI7C,EAAE,IAAI,IAAI,CAAC1E,QAAQ,EAAE;MAC1B,IAAI6R,OAAO,GAAG,IAAI,CAAC7R,QAAQ,CAAC0E,EAAE,CAAC;MAC/BmN,OAAO,CAACC,KAAK,CAACvQ,KAAK,GAAG,IAAI,CAACA,KAAK,GAAG,IAAI;MACvCsQ,OAAO,CAACC,KAAK,CAACtQ,MAAM,GAAG,IAAI,CAACA,MAAM,GAAG,IAAI;IAC7C;IACA;IACA,KAAK,IAAIkD,EAAE,IAAI,IAAI,CAACzE,cAAc,EAAE;MAChC,IAAI,CAACD,QAAQ,CAAC0E,EAAE,CAAC,CAACqN,YAAY,CAAC,OAAO,EAAE,IAAI,CAACxQ,KAAK,GAAG,IAAI,CAACE,UAAU,GAAG,IAAI,CAAC;MAC5E,IAAI,CAACzB,QAAQ,CAAC0E,EAAE,CAAC,CAACqN,YAAY,CAAC,QAAQ,EAAE,IAAI,CAACvQ,MAAM,GAAG,IAAI,CAACC,UAAU,GAAG,IAAI,CAAC;MAC9E,IAAI,IAAI,CAACA,UAAU,KAAK,CAAC,EACrB,IAAI,CAACxB,cAAc,CAACyE,EAAE,CAAC,CAACsN,KAAK,CAAC,IAAI,CAACvQ,UAAU,EAAE,IAAI,CAACA,UAAU,CAAC;IACvE;IACA;IACA,KAAK,IAAIiD,EAAE,IAAI,IAAI,CAACxE,aAAa,EAAE;MAC/B,IAAI,CAACF,QAAQ,CAAC0E,EAAE,CAAC,CAACqN,YAAY,CAAC,OAAO,EAAE,IAAI,CAACxQ,KAAK,GAAG,IAAI,CAACE,UAAU,GAAG,IAAI,CAAC;MAC5E,IAAI,CAACzB,QAAQ,CAAC0E,EAAE,CAAC,CAACqN,YAAY,CAAC,QAAQ,EAAE,IAAI,CAACvQ,MAAM,GAAG,IAAI,CAACC,UAAU,GAAG,IAAI,CAAC;MAC9E,IAAI,CAACvB,aAAa,CAACwE,EAAE,CAAC,CAACuN,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC1Q,KAAK,GAAG,IAAI,CAACE,UAAU,EAAE,IAAI,CAACD,MAAM,GAAG,IAAI,CAACC,UAAU,CAAC;IACtG;IACA,OAAO,IAAI;EACf,CAAC;EACD;AACJ;AACA;AACA;AACA;EACI9B,KAAK,CAAChE,SAAS,CAACkQ,KAAK,GAAG,YAAY;IAChC,IAAI,CAAC3L,aAAa,CAACqD,KAAK,CAACsI,KAAK,CAAC,IAAI,CAAC3L,aAAa,CAACqD,KAAK,CAACiM,gBAAgB,CAAC;IACzE,IAAI,CAACtP,aAAa,CAAC2D,KAAK,CAACgI,KAAK,CAAC,IAAI,CAAC3L,aAAa,CAAC2D,KAAK,CAAC2L,gBAAgB,CAAC;IACzE,IAAI,CAACtP,aAAa,CAACwD,UAAU,CAACmI,KAAK,CAAC,IAAI,CAAC3L,aAAa,CAACwD,UAAU,CAAC8L,gBAAgB,CAAC;IACnF,IAAI,CAACvP,cAAc,CAACsO,MAAM,CAACM,SAAS,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI,CAACtN,KAAK,EAAE,IAAI,CAACC,MAAM,CAAC;IACnE,IAAI,CAACvB,cAAc,CAACmP,MAAM,CAACP,SAAS,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI,CAACtN,KAAK,EAAE,IAAI,CAACC,MAAM,CAAC;IACnE,IAAI,CAACvB,cAAc,CAAC2O,UAAU,CAACC,SAAS,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI,CAACtN,KAAK,EAAE,IAAI,CAACC,MAAM,CAAC;IACvE,OAAO,IAAI;EACf,CAAC;EACD;AACJ;AACA;AACA;AACA;EACI7B,KAAK,CAAChE,SAAS,CAACuW,OAAO,GAAG,YAAY;IAClC,IAAI,CAAChQ,aAAa,GAAG,IAAI;IACzB,IAAI,CAAC8L,QAAQ,CAAC,CAAC;IACf,OAAO,IAAI;EACf,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;EACIrO,KAAK,CAAChE,SAAS,CAACwW,eAAe,GAAG,YAAY;IAC1C,IAAI,CAACjQ,aAAa,GAAG,IAAI;IACzB,IAAI,CAACmD,gBAAgB,CAAC,CAAC;IACvB,OAAO,IAAI;EACf,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI1F,KAAK,CAAChE,SAAS,CAACyW,sBAAsB,GAAG,UAAUC,cAAc,EAAEC,QAAQ,EAAE;IACzE,IAAI9M,EAAE,GAAG,IAAI,CAACzB,MAAM,CAACqI,QAAQ,CAAC,CAAC;MAAEiC,KAAK,GAAG7I,EAAE,CAAC6I,KAAK;MAAEkE,KAAK,GAAG/M,EAAE,CAAC+M,KAAK;MAAE1R,CAAC,GAAG2E,EAAE,CAAC3E,CAAC;MAAEC,CAAC,GAAG0E,EAAE,CAAC1E,CAAC;IACvF;IACA,IAAI0R,SAAS,GAAGF,QAAQ,GAAGjE,KAAK;IAChC,IAAIoE,MAAM,GAAG;MACT5R,CAAC,EAAE,IAAI,CAACU,KAAK,GAAG,CAAC;MACjBT,CAAC,EAAE,IAAI,CAACU,MAAM,GAAG;IACrB,CAAC;IACD,IAAIkR,kBAAkB,GAAG,IAAI,CAACzM,qBAAqB,CAACoM,cAAc,CAAC;IACnE,IAAIM,mBAAmB,GAAG,IAAI,CAAC1M,qBAAqB,CAACwM,MAAM,CAAC;IAC5D,OAAO;MACHF,KAAK,EAAEA,KAAK;MACZ1R,CAAC,EAAE,CAAC6R,kBAAkB,CAAC7R,CAAC,GAAG8R,mBAAmB,CAAC9R,CAAC,KAAK,CAAC,GAAG2R,SAAS,CAAC,GAAG3R,CAAC;MACvEC,CAAC,EAAE,CAAC4R,kBAAkB,CAAC5R,CAAC,GAAG6R,mBAAmB,CAAC7R,CAAC,KAAK,CAAC,GAAG0R,SAAS,CAAC,GAAG1R,CAAC;MACvEuN,KAAK,EAAEiE;IACX,CAAC;EACL,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;EACI3S,KAAK,CAAChE,SAAS,CAACiX,aAAa,GAAG,YAAY;IACxC;IACA,IAAIC,OAAO,GAAI,CAAC,GAAG,IAAI,CAACtR,KAAK,GAAI,CAAC;MAAEuR,OAAO,GAAI,CAAC,GAAG,IAAI,CAACtR,MAAM,GAAI,CAAC;IACnE,IAAIuR,EAAE,GAAG,IAAI,CAAC9M,qBAAqB,CAAC;QAAEpF,CAAC,EAAE,CAAC,GAAGgS,OAAO;QAAE/R,CAAC,EAAE,CAAC,GAAGgS;MAAQ,CAAC,CAAC;MAAEE,EAAE,GAAG,IAAI,CAAC/M,qBAAqB,CAAC;QAAEpF,CAAC,EAAE,IAAI,CAACU,KAAK,GAAGsR,OAAO;QAAE/R,CAAC,EAAE,CAAC,GAAGgS;MAAQ,CAAC,CAAC;MAAEG,CAAC,GAAG,IAAI,CAAChN,qBAAqB,CAAC;QAAEpF,CAAC,EAAE,CAAC;QAAEC,CAAC,EAAE,IAAI,CAACU,MAAM,GAAGsR;MAAQ,CAAC,CAAC;IACzN,OAAO;MACHI,EAAE,EAAEH,EAAE,CAAClS,CAAC;MACRsS,EAAE,EAAEJ,EAAE,CAACjS,CAAC;MACRsS,EAAE,EAAEJ,EAAE,CAACnS,CAAC;MACRwS,EAAE,EAAEL,EAAE,CAAClS,CAAC;MACRU,MAAM,EAAEwR,EAAE,CAAClS,CAAC,GAAGmS,CAAC,CAACnS;IACrB,CAAC;EACL,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;EACInB,KAAK,CAAChE,SAAS,CAACgL,qBAAqB,GAAG,UAAU2M,WAAW,EAAEC,QAAQ,EAAE;IACrE,IAAIA,QAAQ,KAAK,KAAK,CAAC,EAAE;MAAEA,QAAQ,GAAG,CAAC,CAAC;IAAE;IAC1C,IAAIC,eAAe,GAAG,CAAC,CAACD,QAAQ,CAACrF,WAAW,IAAI,CAAC,CAACqF,QAAQ,CAAClD,kBAAkB,IAAI,CAAC,CAACkD,QAAQ,CAACjD,eAAe;IAC3G,IAAIvP,MAAM,GAAGwS,QAAQ,CAACxS,MAAM,GACtBwS,QAAQ,CAACxS,MAAM,GACfyS,eAAe,GACX,CAAC,CAAC,EAAEzV,OAAO,CAACoO,gBAAgB,EAAEoH,QAAQ,CAACrF,WAAW,IAAI,IAAI,CAACnK,MAAM,CAACqI,QAAQ,CAAC,CAAC,EAAEmH,QAAQ,CAAClD,kBAAkB,IAAI,IAAI,CAAC3E,aAAa,CAAC,CAAC,EAAE6H,QAAQ,CAACjD,eAAe,IAAI,IAAI,CAACjE,kBAAkB,CAAC,CAAC,EAAEkH,QAAQ,CAAChD,OAAO,IAAI,IAAI,CAACjE,UAAU,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,GACnP,IAAI,CAACvL,MAAM;IACrB,IAAI0S,WAAW,GAAG,CAAC,CAAC,EAAEtV,UAAU,CAACuV,YAAY,EAAE3S,MAAM,EAAEuS,WAAW,CAAC;IACnE,OAAO;MACHzS,CAAC,EAAG,CAAC,CAAC,GAAG4S,WAAW,CAAC5S,CAAC,IAAI,IAAI,CAACU,KAAK,GAAI,CAAC;MACzCT,CAAC,EAAG,CAAC,CAAC,GAAG2S,WAAW,CAAC3S,CAAC,IAAI,IAAI,CAACU,MAAM,GAAI;IAC7C,CAAC;EACL,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;EACI7B,KAAK,CAAChE,SAAS,CAACsK,qBAAqB,GAAG,UAAUqN,WAAW,EAAEC,QAAQ,EAAE;IACrE,IAAIA,QAAQ,KAAK,KAAK,CAAC,EAAE;MAAEA,QAAQ,GAAG,CAAC,CAAC;IAAE;IAC1C,IAAIC,eAAe,GAAG,CAAC,CAACD,QAAQ,CAACrF,WAAW,IAAI,CAAC,CAACqF,QAAQ,CAAClD,kBAAkB,IAAI,CAACkD,QAAQ,CAACjD,eAAe;IAC1G,IAAIrP,SAAS,GAAGsS,QAAQ,CAACxS,MAAM,GACzBwS,QAAQ,CAACxS,MAAM,GACfyS,eAAe,GACX,CAAC,CAAC,EAAEzV,OAAO,CAACoO,gBAAgB,EAAEoH,QAAQ,CAACrF,WAAW,IAAI,IAAI,CAACnK,MAAM,CAACqI,QAAQ,CAAC,CAAC,EAAEmH,QAAQ,CAAClD,kBAAkB,IAAI,IAAI,CAAC3E,aAAa,CAAC,CAAC,EAAE6H,QAAQ,CAACjD,eAAe,IAAI,IAAI,CAACjE,kBAAkB,CAAC,CAAC,EAAEkH,QAAQ,CAAChD,OAAO,IAAI,IAAI,CAACjE,UAAU,CAAC,cAAc,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC,GACzP,IAAI,CAACrL,SAAS;IACxB,IAAI0S,GAAG,GAAG,CAAC,CAAC,EAAExV,UAAU,CAACuV,YAAY,EAAEzS,SAAS,EAAE;MAC9CJ,CAAC,EAAGyS,WAAW,CAACzS,CAAC,GAAG,IAAI,CAACU,KAAK,GAAI,CAAC,GAAG,CAAC;MACvCT,CAAC,EAAE,CAAC,GAAIwS,WAAW,CAACxS,CAAC,GAAG,IAAI,CAACU,MAAM,GAAI;IAC3C,CAAC,CAAC;IACF,IAAIoS,KAAK,CAACD,GAAG,CAAC9S,CAAC,CAAC,EACZ8S,GAAG,CAAC9S,CAAC,GAAG,CAAC;IACb,IAAI+S,KAAK,CAACD,GAAG,CAAC7S,CAAC,CAAC,EACZ6S,GAAG,CAAC7S,CAAC,GAAG,CAAC;IACb,OAAO6S,GAAG;EACd,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIhU,KAAK,CAAChE,SAAS,CAAC4N,eAAe,GAAG,UAAUsK,aAAa,EAAEN,QAAQ,EAAE;IACjE,IAAIA,QAAQ,KAAK,KAAK,CAAC,EAAE;MAAEA,QAAQ,GAAG,CAAC,CAAC;IAAE;IAC1C,OAAO,IAAI,CAACnS,qBAAqB,CAAC0S,OAAO,CAAC,IAAI,CAAC7N,qBAAqB,CAAC4N,aAAa,EAAEN,QAAQ,CAAC,CAAC;EAClG,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI5T,KAAK,CAAChE,SAAS,CAACyO,eAAe,GAAG,UAAU2J,UAAU,EAAER,QAAQ,EAAE;IAC9D,IAAIA,QAAQ,KAAK,KAAK,CAAC,EAAE;MAAEA,QAAQ,GAAG,CAAC,CAAC;IAAE;IAC1C,OAAO,IAAI,CAAC5M,qBAAqB,CAAC,IAAI,CAACvF,qBAAqB,CAAC2S,UAAU,CAAC,EAAER,QAAQ,CAAC;EACvF,CAAC;EACD;AACJ;AACA;AACA;AACA;EACI5T,KAAK,CAAChE,SAAS,CAACqY,OAAO,GAAG,YAAY;IAClC,OAAO,CAAC,CAAC,EAAEjW,OAAO,CAACiO,WAAW,EAAE,IAAI,CAACnM,KAAK,CAAC;EAC/C,CAAC;EACD;AACJ;AACA;AACA;AACA;EACIF,KAAK,CAAChE,SAAS,CAACsY,aAAa,GAAG,YAAY;IACxC,OAAO,IAAI,CAAC9S,UAAU;EAC1B,CAAC;EACD;AACJ;AACA;AACA;AACA;EACIxB,KAAK,CAAChE,SAAS,CAACuY,aAAa,GAAG,UAAU/S,UAAU,EAAE;IAClD,IAAI,CAACA,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACkE,gBAAgB,CAAC,CAAC;IACvB,OAAO,IAAI;EACf,CAAC;EACD;AACJ;AACA;AACA;AACA;EACI1F,KAAK,CAAChE,SAAS,CAACwY,IAAI,GAAG,YAAY;IAC/B;IACA,IAAI,CAAC5M,IAAI,CAAC,MAAM,CAAC;IACjB;IACA,IAAI,CAAC6M,kBAAkB,CAAC,CAAC;IACzB;IACA,IAAI,CAACrQ,MAAM,CAACkF,cAAc,CAAC,SAAS,EAAE,IAAI,CAAC9I,eAAe,CAAC4D,MAAM,CAAC;IAClE;IACAgD,MAAM,CAACsN,mBAAmB,CAAC,QAAQ,EAAE,IAAI,CAAClU,eAAe,CAAC2G,YAAY,CAAC;IACvE,IAAI,CAAC7C,WAAW,CAACkQ,IAAI,CAAC,CAAC;IACvB,IAAI,CAAChQ,WAAW,CAACgQ,IAAI,CAAC,CAAC;IACvB;IACA,IAAI,CAACnL,mBAAmB,CAAC,CAAC;IAC1B;IACA,IAAI,CAAC5I,QAAQ,GAAG,IAAIvC,UAAU,CAACwC,OAAO,CAAC,CAAC;IACxC,IAAI,CAACG,aAAa,GAAG,CAAC,CAAC;IACvB,IAAI,CAACC,aAAa,GAAG,CAAC,CAAC;IACvB,IAAI,CAACC,qBAAqB,GAAG,EAAE;IAC/B,IAAI,CAACC,qBAAqB,GAAG,EAAE;IAC/B,IAAI,CAACkB,gBAAgB,CAACgK,KAAK,CAAC,CAAC;IAC7B;IACA,IAAI,IAAI,CAAC7J,WAAW,EAAE;MAClB,CAAC,CAAC,EAAEjE,OAAO,CAAC8R,WAAW,EAAE,IAAI,CAAC7N,WAAW,CAAC;MAC1C,IAAI,CAACA,WAAW,GAAG,IAAI;IAC3B;IACA,IAAI,IAAI,CAACC,2BAA2B,EAAE;MAClC,CAAC,CAAC,EAAElE,OAAO,CAAC8R,WAAW,EAAE,IAAI,CAAC5N,2BAA2B,CAAC;MAC1D,IAAI,CAACA,2BAA2B,GAAG,IAAI;IAC3C;IACA;IACA,IAAInC,SAAS,GAAG,IAAI,CAACA,SAAS;IAC9B,OAAOA,SAAS,CAACwU,UAAU,EACvBxU,SAAS,CAACyU,WAAW,CAACzU,SAAS,CAACwU,UAAU,CAAC;EACnD,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;EACI3U,KAAK,CAAChE,SAAS,CAACiL,SAAS,GAAG,UAAU3H,IAAI,EAAE;IACxC,OAAOA,IAAI,GAAG,IAAI,CAACqC,eAAe;EACtC,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI3B,KAAK,CAAChE,SAAS,CAAC6Y,WAAW,GAAG,YAAY;IACtC,OAAOrY,QAAQ,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC6D,QAAQ,CAAC;EACtC,CAAC;EACD,OAAOL,KAAK;AAChB,CAAC,CAAC7B,OAAO,CAAC2W,iBAAiB,CAAE;AAC7BjX,OAAO,CAAC6C,OAAO,GAAGV,KAAK"},"metadata":{},"sourceType":"script","externalDependencies":[]}