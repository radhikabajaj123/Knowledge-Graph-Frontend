{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.edgeLabelsToDisplayFromNodes = exports.LabelGrid = void 0;\n/**\n * Class representing a single candidate for the label grid selection.\n *\n * It also describes a deterministic way to compare two candidates to assess\n * which one is better.\n */\nvar LabelCandidate = /** @class */function () {\n  function LabelCandidate(key, size) {\n    this.key = key;\n    this.size = size;\n  }\n  LabelCandidate.compare = function (first, second) {\n    // First we compare by size\n    if (first.size > second.size) return -1;\n    if (first.size < second.size) return 1;\n    // Then since no two nodes can have the same key, we use it to\n    // deterministically tie-break by key\n    if (first.key > second.key) return 1;\n    // NOTE: this comparator cannot return 0\n    return -1;\n  };\n  return LabelCandidate;\n}();\n/**\n * Class representing a 2D spatial grid divided into constant-size cells.\n */\nvar LabelGrid = /** @class */function () {\n  function LabelGrid() {\n    this.width = 0;\n    this.height = 0;\n    this.cellSize = 0;\n    this.columns = 0;\n    this.rows = 0;\n    this.cells = {};\n  }\n  LabelGrid.prototype.resizeAndClear = function (dimensions, cellSize) {\n    this.width = dimensions.width;\n    this.height = dimensions.height;\n    this.cellSize = cellSize;\n    this.columns = Math.ceil(dimensions.width / cellSize);\n    this.rows = Math.ceil(dimensions.height / cellSize);\n    this.cells = {};\n  };\n  LabelGrid.prototype.getIndex = function (pos) {\n    var xIndex = Math.floor(pos.x / this.cellSize);\n    var yIndex = Math.floor(pos.y / this.cellSize);\n    return yIndex * this.columns + xIndex;\n  };\n  LabelGrid.prototype.add = function (key, size, pos) {\n    var candidate = new LabelCandidate(key, size);\n    var index = this.getIndex(pos);\n    var cell = this.cells[index];\n    if (!cell) {\n      cell = [];\n      this.cells[index] = cell;\n    }\n    cell.push(candidate);\n  };\n  LabelGrid.prototype.organize = function () {\n    for (var k in this.cells) {\n      var cell = this.cells[k];\n      cell.sort(LabelCandidate.compare);\n    }\n  };\n  LabelGrid.prototype.getLabelsToDisplay = function (ratio, density) {\n    // TODO: work on visible nodes to optimize? ^ -> threshold outside so that memoization works?\n    // TODO: adjust threshold lower, but increase cells a bit?\n    // TODO: hunt for geom issue in disguise\n    // TODO: memoize while ratio does not move. method to force recompute\n    var cellArea = this.cellSize * this.cellSize;\n    var scaledCellArea = cellArea / ratio / ratio;\n    var scaledDensity = scaledCellArea * density / cellArea;\n    var labelsToDisplayPerCell = Math.ceil(scaledDensity);\n    var labels = [];\n    for (var k in this.cells) {\n      var cell = this.cells[k];\n      for (var i = 0; i < Math.min(labelsToDisplayPerCell, cell.length); i++) {\n        labels.push(cell[i].key);\n      }\n    }\n    return labels;\n  };\n  return LabelGrid;\n}();\nexports.LabelGrid = LabelGrid;\n/**\n * Label heuristic selecting edge labels to display, based on displayed node\n * labels\n *\n * @param  {object} params                 - Parameters:\n * @param  {Set}      displayedNodeLabels  - Currently displayed node labels.\n * @param  {Set}      highlightedNodes     - Highlighted nodes.\n * @param  {Graph}    graph                - The rendered graph.\n * @param  {string}   hoveredNode          - Hovered node (optional)\n * @return {Array}                         - The selected labels.\n */\nfunction edgeLabelsToDisplayFromNodes(params) {\n  var graph = params.graph,\n    hoveredNode = params.hoveredNode,\n    highlightedNodes = params.highlightedNodes,\n    displayedNodeLabels = params.displayedNodeLabels;\n  var worthyEdges = [];\n  // TODO: the code below can be optimized using #.forEach and batching the code per adj\n  // We should display an edge's label if:\n  //   - Any of its extremities is highlighted or hovered\n  //   - Both of its extremities has its label shown\n  graph.forEachEdge(function (edge, _, source, target) {\n    if (source === hoveredNode || target === hoveredNode || highlightedNodes.has(source) || highlightedNodes.has(target) || displayedNodeLabels.has(source) && displayedNodeLabels.has(target)) {\n      worthyEdges.push(edge);\n    }\n  });\n  return worthyEdges;\n}\nexports.edgeLabelsToDisplayFromNodes = edgeLabelsToDisplayFromNodes;","map":{"version":3,"names":["Object","defineProperty","exports","value","edgeLabelsToDisplayFromNodes","LabelGrid","LabelCandidate","key","size","compare","first","second","width","height","cellSize","columns","rows","cells","prototype","resizeAndClear","dimensions","Math","ceil","getIndex","pos","xIndex","floor","x","yIndex","y","add","candidate","index","cell","push","organize","k","sort","getLabelsToDisplay","ratio","density","cellArea","scaledCellArea","scaledDensity","labelsToDisplayPerCell","labels","i","min","length","params","graph","hoveredNode","highlightedNodes","displayedNodeLabels","worthyEdges","forEachEdge","edge","_","source","target","has"],"sources":["/Users/radhika.bajaj/Documents/GitHub/Knowledge-Graph-Frontend/node_modules/sigma/core/labels.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.edgeLabelsToDisplayFromNodes = exports.LabelGrid = void 0;\n/**\n * Class representing a single candidate for the label grid selection.\n *\n * It also describes a deterministic way to compare two candidates to assess\n * which one is better.\n */\nvar LabelCandidate = /** @class */ (function () {\n    function LabelCandidate(key, size) {\n        this.key = key;\n        this.size = size;\n    }\n    LabelCandidate.compare = function (first, second) {\n        // First we compare by size\n        if (first.size > second.size)\n            return -1;\n        if (first.size < second.size)\n            return 1;\n        // Then since no two nodes can have the same key, we use it to\n        // deterministically tie-break by key\n        if (first.key > second.key)\n            return 1;\n        // NOTE: this comparator cannot return 0\n        return -1;\n    };\n    return LabelCandidate;\n}());\n/**\n * Class representing a 2D spatial grid divided into constant-size cells.\n */\nvar LabelGrid = /** @class */ (function () {\n    function LabelGrid() {\n        this.width = 0;\n        this.height = 0;\n        this.cellSize = 0;\n        this.columns = 0;\n        this.rows = 0;\n        this.cells = {};\n    }\n    LabelGrid.prototype.resizeAndClear = function (dimensions, cellSize) {\n        this.width = dimensions.width;\n        this.height = dimensions.height;\n        this.cellSize = cellSize;\n        this.columns = Math.ceil(dimensions.width / cellSize);\n        this.rows = Math.ceil(dimensions.height / cellSize);\n        this.cells = {};\n    };\n    LabelGrid.prototype.getIndex = function (pos) {\n        var xIndex = Math.floor(pos.x / this.cellSize);\n        var yIndex = Math.floor(pos.y / this.cellSize);\n        return yIndex * this.columns + xIndex;\n    };\n    LabelGrid.prototype.add = function (key, size, pos) {\n        var candidate = new LabelCandidate(key, size);\n        var index = this.getIndex(pos);\n        var cell = this.cells[index];\n        if (!cell) {\n            cell = [];\n            this.cells[index] = cell;\n        }\n        cell.push(candidate);\n    };\n    LabelGrid.prototype.organize = function () {\n        for (var k in this.cells) {\n            var cell = this.cells[k];\n            cell.sort(LabelCandidate.compare);\n        }\n    };\n    LabelGrid.prototype.getLabelsToDisplay = function (ratio, density) {\n        // TODO: work on visible nodes to optimize? ^ -> threshold outside so that memoization works?\n        // TODO: adjust threshold lower, but increase cells a bit?\n        // TODO: hunt for geom issue in disguise\n        // TODO: memoize while ratio does not move. method to force recompute\n        var cellArea = this.cellSize * this.cellSize;\n        var scaledCellArea = cellArea / ratio / ratio;\n        var scaledDensity = (scaledCellArea * density) / cellArea;\n        var labelsToDisplayPerCell = Math.ceil(scaledDensity);\n        var labels = [];\n        for (var k in this.cells) {\n            var cell = this.cells[k];\n            for (var i = 0; i < Math.min(labelsToDisplayPerCell, cell.length); i++) {\n                labels.push(cell[i].key);\n            }\n        }\n        return labels;\n    };\n    return LabelGrid;\n}());\nexports.LabelGrid = LabelGrid;\n/**\n * Label heuristic selecting edge labels to display, based on displayed node\n * labels\n *\n * @param  {object} params                 - Parameters:\n * @param  {Set}      displayedNodeLabels  - Currently displayed node labels.\n * @param  {Set}      highlightedNodes     - Highlighted nodes.\n * @param  {Graph}    graph                - The rendered graph.\n * @param  {string}   hoveredNode          - Hovered node (optional)\n * @return {Array}                         - The selected labels.\n */\nfunction edgeLabelsToDisplayFromNodes(params) {\n    var graph = params.graph, hoveredNode = params.hoveredNode, highlightedNodes = params.highlightedNodes, displayedNodeLabels = params.displayedNodeLabels;\n    var worthyEdges = [];\n    // TODO: the code below can be optimized using #.forEach and batching the code per adj\n    // We should display an edge's label if:\n    //   - Any of its extremities is highlighted or hovered\n    //   - Both of its extremities has its label shown\n    graph.forEachEdge(function (edge, _, source, target) {\n        if (source === hoveredNode ||\n            target === hoveredNode ||\n            highlightedNodes.has(source) ||\n            highlightedNodes.has(target) ||\n            (displayedNodeLabels.has(source) && displayedNodeLabels.has(target))) {\n            worthyEdges.push(edge);\n        }\n    });\n    return worthyEdges;\n}\nexports.edgeLabelsToDisplayFromNodes = edgeLabelsToDisplayFromNodes;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}