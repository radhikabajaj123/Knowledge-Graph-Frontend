{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.doEdgeCollideWithPoint = exports.isPixelColored = void 0;\n/**\n * This helper returns true is the pixel at (x,y) in the given WebGL context is\n * colored, and false else.\n */\nfunction isPixelColored(gl, x, y) {\n  var pixels = new Uint8Array(4);\n  gl.readPixels(x, gl.drawingBufferHeight - y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixels);\n  return pixels[3] > 0;\n}\nexports.isPixelColored = isPixelColored;\n/**\n * This helper checks whether or not a point (x, y) collides with an\n * edge, connecting a source (xS, yS) to a target (xT, yT) with a thickness in\n * pixels.\n */\nfunction doEdgeCollideWithPoint(x, y, xS, yS, xT, yT, thickness) {\n  // Check first if point is out of the rectangle which opposite corners are the\n  // source and the target, rectangle we expand by `thickness` in every\n  // directions:\n  if (x < xS - thickness && x < xT - thickness) return false;\n  if (y < yS - thickness && y < yT - thickness) return false;\n  if (x > xS + thickness && x > xT + thickness) return false;\n  if (y > yS + thickness && y > yT + thickness) return false;\n  // Check actual collision now: Since we now the point is in this big rectangle\n  // we \"just\" need to check that the distance between the point and the line\n  // connecting the source and the target is less than `thickness`:\n  // https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\n  var distance = Math.abs((xT - xS) * (yS - y) - (xS - x) * (yT - yS)) / Math.sqrt(Math.pow(xT - xS, 2) + Math.pow(yT - yS, 2));\n  return distance < thickness / 2;\n}\nexports.doEdgeCollideWithPoint = doEdgeCollideWithPoint;","map":{"version":3,"names":["Object","defineProperty","exports","value","doEdgeCollideWithPoint","isPixelColored","gl","x","y","pixels","Uint8Array","readPixels","drawingBufferHeight","RGBA","UNSIGNED_BYTE","xS","yS","xT","yT","thickness","distance","Math","abs","sqrt","pow"],"sources":["/Users/radhika.bajaj/Documents/GitHub/Knowledge-Graph-Frontend/node_modules/sigma/utils/edge-collisions.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.doEdgeCollideWithPoint = exports.isPixelColored = void 0;\n/**\n * This helper returns true is the pixel at (x,y) in the given WebGL context is\n * colored, and false else.\n */\nfunction isPixelColored(gl, x, y) {\n    var pixels = new Uint8Array(4);\n    gl.readPixels(x, gl.drawingBufferHeight - y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixels);\n    return pixels[3] > 0;\n}\nexports.isPixelColored = isPixelColored;\n/**\n * This helper checks whether or not a point (x, y) collides with an\n * edge, connecting a source (xS, yS) to a target (xT, yT) with a thickness in\n * pixels.\n */\nfunction doEdgeCollideWithPoint(x, y, xS, yS, xT, yT, thickness) {\n    // Check first if point is out of the rectangle which opposite corners are the\n    // source and the target, rectangle we expand by `thickness` in every\n    // directions:\n    if (x < xS - thickness && x < xT - thickness)\n        return false;\n    if (y < yS - thickness && y < yT - thickness)\n        return false;\n    if (x > xS + thickness && x > xT + thickness)\n        return false;\n    if (y > yS + thickness && y > yT + thickness)\n        return false;\n    // Check actual collision now: Since we now the point is in this big rectangle\n    // we \"just\" need to check that the distance between the point and the line\n    // connecting the source and the target is less than `thickness`:\n    // https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\n    var distance = Math.abs((xT - xS) * (yS - y) - (xS - x) * (yT - yS)) / Math.sqrt(Math.pow(xT - xS, 2) + Math.pow(yT - yS, 2));\n    return distance < thickness / 2;\n}\nexports.doEdgeCollideWithPoint = doEdgeCollideWithPoint;\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,sBAAsB,GAAGF,OAAO,CAACG,cAAc,GAAG,KAAK,CAAC;AAChE;AACA;AACA;AACA;AACA,SAASA,cAAcA,CAACC,EAAE,EAAEC,CAAC,EAAEC,CAAC,EAAE;EAC9B,IAAIC,MAAM,GAAG,IAAIC,UAAU,CAAC,CAAC,CAAC;EAC9BJ,EAAE,CAACK,UAAU,CAACJ,CAAC,EAAED,EAAE,CAACM,mBAAmB,GAAGJ,CAAC,EAAE,CAAC,EAAE,CAAC,EAAEF,EAAE,CAACO,IAAI,EAAEP,EAAE,CAACQ,aAAa,EAAEL,MAAM,CAAC;EACrF,OAAOA,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC;AACxB;AACAP,OAAO,CAACG,cAAc,GAAGA,cAAc;AACvC;AACA;AACA;AACA;AACA;AACA,SAASD,sBAAsBA,CAACG,CAAC,EAAEC,CAAC,EAAEO,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,SAAS,EAAE;EAC7D;EACA;EACA;EACA,IAAIZ,CAAC,GAAGQ,EAAE,GAAGI,SAAS,IAAIZ,CAAC,GAAGU,EAAE,GAAGE,SAAS,EACxC,OAAO,KAAK;EAChB,IAAIX,CAAC,GAAGQ,EAAE,GAAGG,SAAS,IAAIX,CAAC,GAAGU,EAAE,GAAGC,SAAS,EACxC,OAAO,KAAK;EAChB,IAAIZ,CAAC,GAAGQ,EAAE,GAAGI,SAAS,IAAIZ,CAAC,GAAGU,EAAE,GAAGE,SAAS,EACxC,OAAO,KAAK;EAChB,IAAIX,CAAC,GAAGQ,EAAE,GAAGG,SAAS,IAAIX,CAAC,GAAGU,EAAE,GAAGC,SAAS,EACxC,OAAO,KAAK;EAChB;EACA;EACA;EACA;EACA,IAAIC,QAAQ,GAAGC,IAAI,CAACC,GAAG,CAAC,CAACL,EAAE,GAAGF,EAAE,KAAKC,EAAE,GAAGR,CAAC,CAAC,GAAG,CAACO,EAAE,GAAGR,CAAC,KAAKW,EAAE,GAAGF,EAAE,CAAC,CAAC,GAAGK,IAAI,CAACE,IAAI,CAACF,IAAI,CAACG,GAAG,CAACP,EAAE,GAAGF,EAAE,EAAE,CAAC,CAAC,GAAGM,IAAI,CAACG,GAAG,CAACN,EAAE,GAAGF,EAAE,EAAE,CAAC,CAAC,CAAC;EAC7H,OAAOI,QAAQ,GAAGD,SAAS,GAAG,CAAC;AACnC;AACAjB,OAAO,CAACE,sBAAsB,GAAGA,sBAAsB"},"metadata":{},"sourceType":"script","externalDependencies":[]}