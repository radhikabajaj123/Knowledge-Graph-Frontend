{"ast":null,"code":"var _jsxFileName = \"/Users/radhika.bajaj/Documents/GitHub/Knowledge-Graph-Frontend/src/components/NetworkDiagram.js\",\n  _s = $RefreshSig$();\nimport * as d3 from 'd3';\nimport { useEffect, useRef } from 'react';\nimport DrawNetwork from './DrawNetwork';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const NetworkDiagram = ({\n  graph\n}) => {\n  _s();\n  // The force simulation mutates links and nodes, so create a copy first\n  // Node positions are initialized by d3\n  const RADIUS = 40;\n  const links = graph.links.map(d => ({\n    ...d\n  }));\n  const nodes = graph.nodes.map(d => ({\n    ...d\n  }));\n  const canvasRef = useRef(null);\n  useEffect(() => {\n    // set dimension of the canvas element\n    const canvas = canvasRef.current;\n    const context = canvas === null || canvas === void 0 ? void 0 : canvas.getContext('2d');\n    if (!context) {\n      return;\n    }\n\n    // let cameraOffset = { x: window.innerWidth/2, y: window.innerHeight/2 }\n    // let cameraZoom = 1\n    // let MAX_ZOOM = 5\n    // let MIN_ZOOM = 0.1\n    // let SCROLL_SENSITIVITY = 0.0005\n\n    // context.translate( window.innerWidth / 2, window.innerHeight / 2 )\n    // context.scale(cameraZoom, cameraZoom)\n    // context.translate( -window.innerWidth / 2 + cameraOffset.x, -window.innerHeight / 2 + cameraOffset.y )\n\n    // // Gets the relevant location from a mouse or single touch event\n    // function getEventLocation(e) {\n    //     if (e.touches && e.touches.length === 1)\n    //     {\n    //         return { x:e.touches[0].clientX, y: e.touches[0].clientY }\n    //     }\n    //     else if (e.clientX && e.clientY)\n    //     {\n    //         return { x: e.clientX, y: e.clientY }        \n    //     }\n    // }\n\n    // let isDragging = false\n    // let dragStart = { x: 0, y: 0 }\n\n    // function onPointerDown(e) {\n    //     isDragging = true\n    //     dragStart.x = getEventLocation(e).x/cameraZoom - cameraOffset.x\n    //     dragStart.y = getEventLocation(e).y/cameraZoom - cameraOffset.y\n    // }\n\n    // function onPointerUp(e) {\n    //     isDragging = false\n    //     initialPinchDistance = null\n    //     lastZoom = cameraZoom\n    // }\n\n    // function onPointerMove(e) {\n    //     if (isDragging)\n    //     {\n    //         cameraOffset.x = getEventLocation(e).x/cameraZoom - dragStart.x\n    //         cameraOffset.y = getEventLocation(e).y/cameraZoom - dragStart.y\n    //     }\n    // }\n\n    // function handleTouch(e, singleTouchHandler) {\n    //     if ( e.touches.length === 1 )\n    //     {\n    //         singleTouchHandler(e)\n    //     }\n    //     else if (e.type === \"touchmove\" && e.touches.length === 2)\n    //     {\n    //         isDragging = false\n    //         handlePinch(e)\n    //     }\n    // }\n\n    // let initialPinchDistance = null\n    // let lastZoom = cameraZoom\n\n    // function handlePinch(e) {\n    //     e.preventDefault()\n\n    //     let touch1 = { x: e.touches[0].clientX, y: e.touches[0].clientY }\n    //     let touch2 = { x: e.touches[1].clientX, y: e.touches[1].clientY }\n\n    //     // This is distance squared, but no need for an expensive sqrt as it's only used in ratio\n    //     let currentDistance = (touch1.x - touch2.x)**2 + (touch1.y - touch2.y)**2\n\n    //     if (initialPinchDistance == null)\n    //     {\n    //         initialPinchDistance = currentDistance\n    //     }\n    //     else\n    //     {\n    //         adjustZoom( null, currentDistance/initialPinchDistance )\n    //     }\n    // }\n\n    // function adjustZoom(zoomAmount, zoomFactor) {\n    //     if (!isDragging)\n    //     {\n    //         if (zoomAmount)\n    //         {\n    //             cameraZoom += zoomAmount\n    //         }\n    //         else if (zoomFactor)\n    //         {\n    //             console.log(zoomFactor)\n    //             cameraZoom = zoomFactor*lastZoom\n    //         }\n\n    //         cameraZoom = Math.min( cameraZoom, MAX_ZOOM )\n    //         cameraZoom = Math.max( cameraZoom, MIN_ZOOM )\n\n    //         console.log(zoomAmount)\n    //     }\n    // }\n\n    // canvas.addEventListener('mousedown', onPointerDown)\n    // canvas.addEventListener('touchstart', (e) => handleTouch(e, onPointerDown))\n    // canvas.addEventListener('mouseup', onPointerUp)\n    // canvas.addEventListener('touchend',  (e) => handleTouch(e, onPointerUp))\n    // canvas.addEventListener('mousemove', onPointerMove)\n    // canvas.addEventListener('touchmove', (e) => handleTouch(e, onPointerMove))\n    // canvas.addEventListener( 'wheel', (e) => adjustZoom(e.deltaY*SCROLL_SENSITIVITY))\n\n    // run d3-force to find the position of nodes on the canvas\n    d3.forceSimulation(nodes)\n\n    // list of forces we apply to get node positions\n    .force('link', d3.forceLink(links).id(d => d.id)).force('collide', d3.forceCollide().radius(RADIUS)).force('charge', d3.forceManyBody()).force('center', d3.forceCenter(window.innerWidth / 2, window.innerHeight / 2))\n\n    // at each iteration of the simulation, draw the network diagram with the new node positions\n    .on('tick', () => {\n      DrawNetwork(context, window.innerWidth, window.innerHeight, nodes, links, RADIUS);\n    });\n  }, [nodes, links]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      style: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        backgroundColor: \"#F2F1F1\"\n      },\n      width: window.innerWidth,\n      height: window.innerHeight\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 152,\n      columnNumber: 17\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 151,\n    columnNumber: 17\n  }, this);\n};\n_s(NetworkDiagram, \"UJgi7ynoup7eqypjnwyX/s32POg=\");\n_c = NetworkDiagram;\nvar _c;\n$RefreshReg$(_c, \"NetworkDiagram\");","map":{"version":3,"names":["d3","useEffect","useRef","DrawNetwork","jsxDEV","_jsxDEV","NetworkDiagram","graph","_s","RADIUS","links","map","d","nodes","canvasRef","canvas","current","context","getContext","forceSimulation","force","forceLink","id","forceCollide","radius","forceManyBody","forceCenter","window","innerWidth","innerHeight","on","children","ref","style","width","height","backgroundColor","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/radhika.bajaj/Documents/GitHub/Knowledge-Graph-Frontend/src/components/NetworkDiagram.js"],"sourcesContent":["import * as d3 from 'd3';\nimport { useEffect, useRef } from 'react';\nimport DrawNetwork from './DrawNetwork';\n\nexport const NetworkDiagram = ({graph}) => {\n  // The force simulation mutates links and nodes, so create a copy first\n  // Node positions are initialized by d3\n  const RADIUS = 40;\n  const links = graph.links.map((d) => ({ ...d }));\n  const nodes = graph.nodes.map((d) => ({ ...d }));\n\n  const canvasRef = useRef(null);\n  \n\n  useEffect(() => {\n    // set dimension of the canvas element\n    const canvas = canvasRef.current;\n    const context = canvas?.getContext('2d');\n\n    if (!context) {\n      return;\n    }\n\n    // let cameraOffset = { x: window.innerWidth/2, y: window.innerHeight/2 }\n    // let cameraZoom = 1\n    // let MAX_ZOOM = 5\n    // let MIN_ZOOM = 0.1\n    // let SCROLL_SENSITIVITY = 0.0005\n\n    // context.translate( window.innerWidth / 2, window.innerHeight / 2 )\n    // context.scale(cameraZoom, cameraZoom)\n    // context.translate( -window.innerWidth / 2 + cameraOffset.x, -window.innerHeight / 2 + cameraOffset.y )\n\n    // // Gets the relevant location from a mouse or single touch event\n    // function getEventLocation(e) {\n    //     if (e.touches && e.touches.length === 1)\n    //     {\n    //         return { x:e.touches[0].clientX, y: e.touches[0].clientY }\n    //     }\n    //     else if (e.clientX && e.clientY)\n    //     {\n    //         return { x: e.clientX, y: e.clientY }        \n    //     }\n    // }\n\n    // let isDragging = false\n    // let dragStart = { x: 0, y: 0 }\n\n    // function onPointerDown(e) {\n    //     isDragging = true\n    //     dragStart.x = getEventLocation(e).x/cameraZoom - cameraOffset.x\n    //     dragStart.y = getEventLocation(e).y/cameraZoom - cameraOffset.y\n    // }\n\n    // function onPointerUp(e) {\n    //     isDragging = false\n    //     initialPinchDistance = null\n    //     lastZoom = cameraZoom\n    // }\n\n    // function onPointerMove(e) {\n    //     if (isDragging)\n    //     {\n    //         cameraOffset.x = getEventLocation(e).x/cameraZoom - dragStart.x\n    //         cameraOffset.y = getEventLocation(e).y/cameraZoom - dragStart.y\n    //     }\n    // }\n\n    // function handleTouch(e, singleTouchHandler) {\n    //     if ( e.touches.length === 1 )\n    //     {\n    //         singleTouchHandler(e)\n    //     }\n    //     else if (e.type === \"touchmove\" && e.touches.length === 2)\n    //     {\n    //         isDragging = false\n    //         handlePinch(e)\n    //     }\n    // }\n\n    // let initialPinchDistance = null\n    // let lastZoom = cameraZoom\n\n    // function handlePinch(e) {\n    //     e.preventDefault()\n        \n    //     let touch1 = { x: e.touches[0].clientX, y: e.touches[0].clientY }\n    //     let touch2 = { x: e.touches[1].clientX, y: e.touches[1].clientY }\n        \n    //     // This is distance squared, but no need for an expensive sqrt as it's only used in ratio\n    //     let currentDistance = (touch1.x - touch2.x)**2 + (touch1.y - touch2.y)**2\n        \n    //     if (initialPinchDistance == null)\n    //     {\n    //         initialPinchDistance = currentDistance\n    //     }\n    //     else\n    //     {\n    //         adjustZoom( null, currentDistance/initialPinchDistance )\n    //     }\n    // }\n\n    // function adjustZoom(zoomAmount, zoomFactor) {\n    //     if (!isDragging)\n    //     {\n    //         if (zoomAmount)\n    //         {\n    //             cameraZoom += zoomAmount\n    //         }\n    //         else if (zoomFactor)\n    //         {\n    //             console.log(zoomFactor)\n    //             cameraZoom = zoomFactor*lastZoom\n    //         }\n            \n    //         cameraZoom = Math.min( cameraZoom, MAX_ZOOM )\n    //         cameraZoom = Math.max( cameraZoom, MIN_ZOOM )\n            \n    //         console.log(zoomAmount)\n    //     }\n    // }\n\n    // canvas.addEventListener('mousedown', onPointerDown)\n    // canvas.addEventListener('touchstart', (e) => handleTouch(e, onPointerDown))\n    // canvas.addEventListener('mouseup', onPointerUp)\n    // canvas.addEventListener('touchend',  (e) => handleTouch(e, onPointerUp))\n    // canvas.addEventListener('mousemove', onPointerMove)\n    // canvas.addEventListener('touchmove', (e) => handleTouch(e, onPointerMove))\n    // canvas.addEventListener( 'wheel', (e) => adjustZoom(e.deltaY*SCROLL_SENSITIVITY))\n\n    // run d3-force to find the position of nodes on the canvas\n    d3.forceSimulation(nodes)\n\n      // list of forces we apply to get node positions\n      .force(\n        'link',\n        d3.forceLink(links).id((d) => d.id)\n      )\n      .force('collide', d3.forceCollide().radius(RADIUS))\n      .force('charge', d3.forceManyBody())\n      .force('center', d3.forceCenter(window.innerWidth / 2, window.innerHeight / 2))\n\n      // at each iteration of the simulation, draw the network diagram with the new node positions\n      .on('tick', () => {\n        DrawNetwork(context, window.innerWidth, window.innerHeight, nodes, links, RADIUS);\n      });\n  }, [nodes, links]);\n\n    \n    return (\n                <div>\n                <canvas\n                    ref={canvasRef}\n                    style={{\n                    width: window.innerWidth,\n                    height: window.innerHeight,\n                    backgroundColor: \"#F2F1F1\"\n                    }}\n                    width={window.innerWidth}\n                    height={window.innerHeight}\n                />\n                </div>\n        \n    );\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}