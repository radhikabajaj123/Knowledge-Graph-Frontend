{"ast":null,"code":"(() => {\n  \"use strict\";\n\n  var a = {\n      d: (e, t) => {\n        for (var o in t) a.o(t, o) && !a.o(e, o) && Object.defineProperty(e, o, {\n          enumerable: !0,\n          get: t[o]\n        });\n      },\n      o: (a, e) => Object.prototype.hasOwnProperty.call(a, e),\n      r: a => {\n        \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(a, Symbol.toStringTag, {\n          value: \"Module\"\n        }), Object.defineProperty(a, \"__esModule\", {\n          value: !0\n        });\n      }\n    },\n    e = {};\n  a.r(e), a.d(e, {\n    default: () => t\n  });\n  const t = \"attribute vec2 a_position;\\nattribute vec2 a_normal;\\nattribute float a_radius;\\nattribute vec4 a_color;\\nattribute vec3 a_barycentric;\\n\\nuniform mat3 u_matrix;\\nuniform float u_sqrtZoomRatio;\\nuniform float u_correctionRatio;\\n\\nvarying vec4 v_color;\\n\\nconst float minThickness = 1.7;\\nconst float bias = 255.0 / 254.0;\\nconst float arrowHeadWidthLengthRatio = 0.66;\\nconst float arrowHeadLengthThicknessRatio = 2.5;\\n\\nvoid main() {\\n  float normalLength = length(a_normal);\\n  vec2 unitNormal = a_normal / normalLength;\\n\\n  // These first computations are taken from edge.vert.glsl and\\n  // edge.clamped.vert.glsl. Please read it to get better comments on what's\\n  // happening:\\n  float pixelsThickness = max(normalLength, minThickness * u_sqrtZoomRatio);\\n  float webGLThickness = pixelsThickness * u_correctionRatio;\\n  float adaptedWebGLThickness = webGLThickness * u_sqrtZoomRatio;\\n  float adaptedWebGLNodeRadius = a_radius * 2.0 * u_correctionRatio * u_sqrtZoomRatio;\\n  float adaptedWebGLArrowHeadLength = adaptedWebGLThickness * 2.0 * arrowHeadLengthThicknessRatio;\\n  float adaptedWebGLArrowHeadHalfWidth = adaptedWebGLArrowHeadLength * arrowHeadWidthLengthRatio / 2.0;\\n\\n  float da = a_barycentric.x;\\n  float db = a_barycentric.y;\\n  float dc = a_barycentric.z;\\n\\n  vec2 delta = vec2(\\n      da * (adaptedWebGLNodeRadius * unitNormal.y)\\n    + db * ((adaptedWebGLNodeRadius + adaptedWebGLArrowHeadLength) * unitNormal.y + adaptedWebGLArrowHeadHalfWidth * unitNormal.x)\\n    + dc * ((adaptedWebGLNodeRadius + adaptedWebGLArrowHeadLength) * unitNormal.y - adaptedWebGLArrowHeadHalfWidth * unitNormal.x),\\n\\n      da * (-adaptedWebGLNodeRadius * unitNormal.x)\\n    + db * (-(adaptedWebGLNodeRadius + adaptedWebGLArrowHeadLength) * unitNormal.x + adaptedWebGLArrowHeadHalfWidth * unitNormal.y)\\n    + dc * (-(adaptedWebGLNodeRadius + adaptedWebGLArrowHeadLength) * unitNormal.x - adaptedWebGLArrowHeadHalfWidth * unitNormal.y)\\n  );\\n\\n  vec2 position = (u_matrix * vec3(a_position + delta, 1)).xy;\\n\\n  gl_Position = vec4(position, 0, 1);\\n\\n  // Extract the color:\\n  v_color = a_color;\\n  v_color.a *= bias;\\n}\\n\";\n  module.exports = e;\n})();","map":{"version":3,"names":["a","d","e","t","o","Object","defineProperty","enumerable","get","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","default","module","exports"],"sources":["/Users/radhika.bajaj/Documents/GitHub/Knowledge-Graph-Frontend/node_modules/sigma/rendering/webgl/shaders/edge.arrowHead.vert.glsl.js"],"sourcesContent":["(()=>{\"use strict\";var a={d:(e,t)=>{for(var o in t)a.o(t,o)&&!a.o(e,o)&&Object.defineProperty(e,o,{enumerable:!0,get:t[o]})},o:(a,e)=>Object.prototype.hasOwnProperty.call(a,e),r:a=>{\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(a,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(a,\"__esModule\",{value:!0})}},e={};a.r(e),a.d(e,{default:()=>t});const t=\"attribute vec2 a_position;\\nattribute vec2 a_normal;\\nattribute float a_radius;\\nattribute vec4 a_color;\\nattribute vec3 a_barycentric;\\n\\nuniform mat3 u_matrix;\\nuniform float u_sqrtZoomRatio;\\nuniform float u_correctionRatio;\\n\\nvarying vec4 v_color;\\n\\nconst float minThickness = 1.7;\\nconst float bias = 255.0 / 254.0;\\nconst float arrowHeadWidthLengthRatio = 0.66;\\nconst float arrowHeadLengthThicknessRatio = 2.5;\\n\\nvoid main() {\\n  float normalLength = length(a_normal);\\n  vec2 unitNormal = a_normal / normalLength;\\n\\n  // These first computations are taken from edge.vert.glsl and\\n  // edge.clamped.vert.glsl. Please read it to get better comments on what's\\n  // happening:\\n  float pixelsThickness = max(normalLength, minThickness * u_sqrtZoomRatio);\\n  float webGLThickness = pixelsThickness * u_correctionRatio;\\n  float adaptedWebGLThickness = webGLThickness * u_sqrtZoomRatio;\\n  float adaptedWebGLNodeRadius = a_radius * 2.0 * u_correctionRatio * u_sqrtZoomRatio;\\n  float adaptedWebGLArrowHeadLength = adaptedWebGLThickness * 2.0 * arrowHeadLengthThicknessRatio;\\n  float adaptedWebGLArrowHeadHalfWidth = adaptedWebGLArrowHeadLength * arrowHeadWidthLengthRatio / 2.0;\\n\\n  float da = a_barycentric.x;\\n  float db = a_barycentric.y;\\n  float dc = a_barycentric.z;\\n\\n  vec2 delta = vec2(\\n      da * (adaptedWebGLNodeRadius * unitNormal.y)\\n    + db * ((adaptedWebGLNodeRadius + adaptedWebGLArrowHeadLength) * unitNormal.y + adaptedWebGLArrowHeadHalfWidth * unitNormal.x)\\n    + dc * ((adaptedWebGLNodeRadius + adaptedWebGLArrowHeadLength) * unitNormal.y - adaptedWebGLArrowHeadHalfWidth * unitNormal.x),\\n\\n      da * (-adaptedWebGLNodeRadius * unitNormal.x)\\n    + db * (-(adaptedWebGLNodeRadius + adaptedWebGLArrowHeadLength) * unitNormal.x + adaptedWebGLArrowHeadHalfWidth * unitNormal.y)\\n    + dc * (-(adaptedWebGLNodeRadius + adaptedWebGLArrowHeadLength) * unitNormal.x - adaptedWebGLArrowHeadHalfWidth * unitNormal.y)\\n  );\\n\\n  vec2 position = (u_matrix * vec3(a_position + delta, 1)).xy;\\n\\n  gl_Position = vec4(position, 0, 1);\\n\\n  // Extract the color:\\n  v_color = a_color;\\n  v_color.a *= bias;\\n}\\n\";module.exports=e})();"],"mappings":"AAAA,CAAC,MAAI;EAAC,YAAY;;EAAC,IAAIA,CAAC,GAAC;MAACC,CAAC,EAACA,CAACC,CAAC,EAACC,CAAC,KAAG;QAAC,KAAI,IAAIC,CAAC,IAAID,CAAC,EAACH,CAAC,CAACI,CAAC,CAACD,CAAC,EAACC,CAAC,CAAC,IAAE,CAACJ,CAAC,CAACI,CAAC,CAACF,CAAC,EAACE,CAAC,CAAC,IAAEC,MAAM,CAACC,cAAc,CAACJ,CAAC,EAACE,CAAC,EAAC;UAACG,UAAU,EAAC,CAAC,CAAC;UAACC,GAAG,EAACL,CAAC,CAACC,CAAC;QAAC,CAAC,CAAC;MAAA,CAAC;MAACA,CAAC,EAACA,CAACJ,CAAC,EAACE,CAAC,KAAGG,MAAM,CAACI,SAAS,CAACC,cAAc,CAACC,IAAI,CAACX,CAAC,EAACE,CAAC,CAAC;MAACU,CAAC,EAACZ,CAAC,IAAE;QAAC,WAAW,IAAE,OAAOa,MAAM,IAAEA,MAAM,CAACC,WAAW,IAAET,MAAM,CAACC,cAAc,CAACN,CAAC,EAACa,MAAM,CAACC,WAAW,EAAC;UAACC,KAAK,EAAC;QAAQ,CAAC,CAAC,EAACV,MAAM,CAACC,cAAc,CAACN,CAAC,EAAC,YAAY,EAAC;UAACe,KAAK,EAAC,CAAC;QAAC,CAAC,CAAC;MAAA;IAAC,CAAC;IAACb,CAAC,GAAC,CAAC,CAAC;EAACF,CAAC,CAACY,CAAC,CAACV,CAAC,CAAC,EAACF,CAAC,CAACC,CAAC,CAACC,CAAC,EAAC;IAACc,OAAO,EAACA,CAAA,KAAIb;EAAC,CAAC,CAAC;EAAC,MAAMA,CAAC,GAAC,ulEAAulE;EAACc,MAAM,CAACC,OAAO,GAAChB,CAAC;AAAA,CAAC,EAAE,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}